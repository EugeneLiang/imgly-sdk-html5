require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./index.js":[function(require,module,exports){
(function (global){
"use strict";
var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var ImglyKit = _interopRequire(require("./src/js/imglykit"));

/* istanbul ignore next */
(function () {
  if (typeof window !== "undefined") {
    window.ImglyKit = ImglyKit;
  } else if (typeof module !== "undefined") {
    module.exports = ImglyKit;
  } else if (typeof global !== "undefined") {
    global.ImglyKit = ImglyKit;
  }
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./src/js/imglykit":"/Users/sash/development/js/imglykit-rewrite/src/js/imglykit.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/any.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise) {
var SomePromiseArray = Promise._SomePromiseArray;
function any(promises) {
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    if (promise.isRejected()) {
        return promise;
    }
    ret.setHowMany(1);
    ret.setUnwrap();
    ret.init();
    return promise;
}

Promise.any = function (promises) {
    return any(promises);
};

Promise.prototype.any = function () {
    return any(this);
};

};

},{}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/async.js":[function(require,module,exports){
(function (process){
"use strict";
var firstLineError;
try {throw new Error(); } catch (e) {firstLineError = e;}
var schedule = require("./schedule.js");
var Queue = require("./queue.js");
var _process = typeof process !== "undefined" ? process : undefined;

function Async() {
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    var self = this;
    this.drainQueues = function () {
        self._drainQueues();
    };
    this._schedule =
        schedule.isStatic ? schedule(this.drainQueues) : schedule;
}

Async.prototype.haveItemsQueued = function () {
    return this._normalQueue.length() > 0;
};

Async.prototype._withDomain = function(fn) {
    if (_process !== undefined &&
        _process.domain != null &&
        !fn.domain) {
        fn = _process.domain.bind(fn);
    }
    return fn;
};

Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
        arg = fn;
        fn = function () { throw arg; };
    }
    fn = this._withDomain(fn);
    if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
            fn(arg);
        }, 0);
    } else try {
        this._schedule(function() {
            fn(arg);
        });
    } catch (e) {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
    }
};

Async.prototype.invokeLater = function (fn, receiver, arg) {
    fn = this._withDomain(fn);
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
};

Async.prototype.invokeFirst = function (fn, receiver, arg) {
    fn = this._withDomain(fn);
    this._normalQueue.unshift(fn, receiver, arg);
    this._queueTick();
};

Async.prototype.invoke = function (fn, receiver, arg) {
    fn = this._withDomain(fn);
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
};

Async.prototype.settlePromises = function(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
};

Async.prototype._drainQueue = function(queue) {
    while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
            fn._settlePromises();
            continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    }
};

Async.prototype._drainQueues = function () {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._drainQueue(this._lateQueue);
};

Async.prototype._queueTick = function () {
    if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    }
};

Async.prototype._reset = function () {
    this._isTickUsed = false;
};

module.exports = new Async();
module.exports.firstLineError = firstLineError;

}).call(this,require('_process'))
},{"./queue.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/queue.js","./schedule.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/schedule.js","_process":"/Users/sash/development/js/imglykit-rewrite/node_modules/browserify/node_modules/process/browser.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/bluebird.js":[function(require,module,exports){
"use strict";
var old;
if (typeof Promise !== "undefined") old = Promise;
function noConflict() {
    try { if (Promise === bluebird) Promise = old; }
    catch (e) {}
    return bluebird;
}
var bluebird = require("./promise.js")();
bluebird.noConflict = noConflict;
module.exports = bluebird;

},{"./promise.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/promise.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/call_get.js":[function(require,module,exports){
"use strict";
var cr = Object.create;
if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
}

module.exports = function(Promise) {
var util = require("./util.js");
var canEvaluate = util.canEvaluate;
var isIdentifier = util.isIdentifier;

function makeMethodCaller (methodName) {
    return new Function("obj", "                                             \n\
        'use strict'                                                         \n\
        var len = this.length;                                               \n\
        switch(len) {                                                        \n\
            case 1: return obj.methodName(this[0]);                          \n\
            case 2: return obj.methodName(this[0], this[1]);                 \n\
            case 3: return obj.methodName(this[0], this[1], this[2]);        \n\
            case 0: return obj.methodName();                                 \n\
            default: return obj.methodName.apply(obj, this);                 \n\
        }                                                                    \n\
        ".replace(/methodName/g, methodName));
}

function makeGetter (propertyName) {
    return new Function("obj", "                                             \n\
        'use strict';                                                        \n\
        return obj.propertyName;                                             \n\
        ".replace("propertyName", propertyName));
}

function getCompiled(name, compiler, cache) {
    var ret = cache[name];
    if (typeof ret !== "function") {
        if (!isIdentifier(name)) {
            return null;
        }
        ret = compiler(name);
        cache[name] = ret;
        cache[" size"]++;
        if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
        }
    }
    return ret;
}

function getMethodCaller(name) {
    return getCompiled(name, makeMethodCaller, callerCache);
}

function getGetter(name) {
    return getCompiled(name, makeGetter, getterCache);
}

function caller(obj) {
    return obj[this.pop()].apply(obj, this);
}
Promise.prototype.call = function (methodName) {
    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
    if (canEvaluate) {
        var maybeCaller = getMethodCaller(methodName);
        if (maybeCaller !== null) {
            return this._then(
                maybeCaller, undefined, undefined, args, undefined);
        }
    }
    args.push(methodName);
    return this._then(caller, undefined, undefined, args, undefined);
};

function namedGetter(obj) {
    return obj[this];
}
function indexedGetter(obj) {
    var index = +this;
    if (index < 0) index = Math.max(0, index + obj.length);
    return obj[index];
}
Promise.prototype.get = function (propertyName) {
    var isIndex = (typeof propertyName === "number");
    var getter;
    if (!isIndex) {
        if (canEvaluate) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
            getter = namedGetter;
        }
    } else {
        getter = indexedGetter;
    }
    return this._then(getter, undefined, undefined, propertyName, undefined);
};
};

},{"./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/cancel.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var errors = require("./errors.js");
var async = require("./async.js");
var CancellationError = errors.CancellationError;

Promise.prototype._cancel = function (reason) {
    if (!this.isCancellable()) return this;
    var parent;
    var promiseToReject = this;
    while ((parent = promiseToReject._cancellationParent) !== undefined &&
        parent.isCancellable()) {
        promiseToReject = parent;
    }
    this._unsetCancellable();
    var trace = errors.ensureErrorObject(reason);
    promiseToReject._attachExtraTrace(trace);
    promiseToReject._target()._rejectUnchecked(reason, trace);
};

Promise.prototype.cancel = function (reason) {
    if (!this.isCancellable()) return this;
    if (reason === undefined) reason = new CancellationError();
    async.invokeLater(this._cancel, this, reason);
    return this;
};

Promise.prototype.cancellable = function () {
    if (this._cancellable()) return this;
    this._setCancellable();
    this._cancellationParent = undefined;
    return this;
};

Promise.prototype.uncancellable = function () {
    var ret = new Promise(INTERNAL);
    ret._propagateFrom(this, 4);
    ret._follow(this);
    ret._unsetCancellable();
    return ret;
};

Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
    var ret = this._then(didFulfill, didReject, didProgress,
                         undefined, undefined);

    ret._setCancellable();
    ret._cancellationParent = undefined;
    return ret;
};
};

},{"./async.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/async.js","./errors.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/captured_trace.js":[function(require,module,exports){
(function (process){
"use strict";
module.exports = function() {
var async = require("./async.js");
var inherits = require("./util.js").inherits;
var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo)/;
var stackFramePattern = null;
var formatStack = null;

function CapturedTrace(parent) {
    this._parent = parent;
    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
    captureStackTrace(this, CapturedTrace);
    if (length > 32) this.uncycle();
}
inherits(CapturedTrace, Error);

CapturedTrace.prototype.uncycle = function() {
    var length = this._length;
    if (length < 2) return;
    var nodes = [];
    var stackToIndex = {};

    for (var i = 0, node = this; node !== undefined; ++i) {
        nodes.push(node);
        node = node._parent;
    }
    length = this._length = i;
    for (var i = length - 1; i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) {
            stackToIndex[stack] = i;
        }
    }
    for (var i = 0; i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined && index !== i) {
            if (index > 0) {
                nodes[index - 1]._parent = undefined;
                nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = undefined;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

            if (index < length - 1) {
                cycleEdgeNode._parent = nodes[index + 1];
                cycleEdgeNode._parent.uncycle();
                cycleEdgeNode._length =
                    cycleEdgeNode._parent._length + 1;
            } else {
                cycleEdgeNode._parent = undefined;
                cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
                nodes[j]._length = currentChildLength;
                currentChildLength++;
            }
            return;
        }
    }
};

CapturedTrace.prototype.parent = function() {
    return this._parent;
};

CapturedTrace.prototype.hasParent = function() {
    return this._parent !== undefined;
};

CapturedTrace.prototype.attachExtraTrace = function(error) {
    if (error.__stackCleaned__) return;
    this.uncycle();
    var trace = this;
    var stack = CapturedTrace.cleanStack(error, false);
    var headerLineCount = 1;
    var combinedTraces = 1;
    do {
        stack = trace.combine(stack);
        combinedTraces++;
    } while ((trace = trace.parent()) != null);

    stack = unProtectNewlines(stack);

    if (stack.length <= headerLineCount) {
        error.stack = "(No stack trace)";
    } else {
        error.stack = stack.join("\n");
    }
};

CapturedTrace.prototype.combine = function(current) {
    var prev = clean(this.stack.split("\n"), 0);
    var currentLastIndex = current.length - 1;
    var currentLastLine = current[currentLastIndex];
    var commonRootMeetPoint = -1;
    for (var i = prev.length - 1; i >= 0; --i) {
        if (prev[i] === currentLastLine) {
            commonRootMeetPoint = i;
            break;
        }
    }

    for (var i = commonRootMeetPoint; i >= 0; --i) {
        var line = prev[i];
        if (current[currentLastIndex] === line) {
            current.pop();
            currentLastIndex--;
        } else {
            break;
        }
    }

    if (current[current.length - 1] !== "From previous event:") {
        current.push("From previous event:");
    }
    return current.concat(prev);
};

function protectErrorMessageNewlines (stack) {
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
            break;
        }
    }

    if (i <= 1) return 1;

    var errorMessageLines = [];
    for (var j = 0; j < i; ++j) {
        errorMessageLines.push(stack.shift());
    }
    stack.unshift(errorMessageLines.join("\u0002\u0000\u0001"));
    return i;
}

function unProtectNewlines(stack) {
    if (stack.length > 0) {
        stack[0] = stack[0].split("\u0002\u0000\u0001").join("\n");
        if (stack[stack.length - 1] === "From previous event:") {
            stack.pop();
        }
    }
    return stack;
}

function clean(stack, initialIndex) {
    var ret = stack.slice(0, initialIndex);
    for (var i = initialIndex; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = stackFramePattern.test(line) ||
            "    (No stack trace)" === line;
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
            ret.push(line);
        }
    }
    return ret;
}

CapturedTrace.cleanStack = function(error, shouldUnProtectNewlines) {
    if (error.__stackCleaned__) return;
    error.__stackCleaned__ = true;
    var stack = error.stack;
    stack = typeof stack === "string"
        ? stack.split("\n")
        : [error.toString(), "    (No stack trace)"];
    var initialIndex = protectErrorMessageNewlines(stack);
    stack = clean(stack, initialIndex);
    if (shouldUnProtectNewlines) stack = unProtectNewlines(stack);
    error.stack = stack.join("\n");
    return stack;
};

CapturedTrace.formatAndLogError = function(error, title) {
    if (typeof console === "object") {
        var message;
        if (typeof error === "object" || typeof error === "function") {
            var stack = error.stack;
            message = title + formatStack(stack, error);
        } else {
            message = title + String(error);
        }
        if (typeof console.warn === "function" ||
            typeof console.warn === "object") {
            console.warn(message);
        } else if (typeof console.log === "function" ||
            typeof console.log === "object") {
            console.log(message);
        }
    }
};

CapturedTrace.unhandledRejection = function (reason) {
    CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
};

CapturedTrace.isSupported = function () {
    return typeof captureStackTrace === "function";
};

CapturedTrace.fireRejectionEvent =
function(name, localHandler, reason, promise) {
    var localEventFired = false;
    try {
        if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
                localHandler(promise);
            } else {
                localHandler(reason, promise);
            }
        }
    } catch (e) {
        async.throwLater(e);
    }

    var globalEventFired = false;
    try {
        globalEventFired = fireGlobalEvent(name, reason, promise);
    } catch (e) {
        globalEventFired = true;
        async.throwLater(e);
    }

    if (!globalEventFired && !localEventFired &&
        name === "unhandledRejection") {
        CapturedTrace.formatAndLogError(reason, "Possibly unhandled ");
    }
};

function formatNonError(obj) {
    var str;
    if (typeof obj === "function") {
        str = "[function " +
            (obj.name || "anonymous") +
            "]";
    } else {
        str = obj.toString();
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
            try {
                var newStr = JSON.stringify(obj);
                str = newStr;
            }
            catch(e) {

            }
        }
        if (str.length === 0) {
            str = "(empty array)";
        }
    }
    return ("(<" + snip(str) + ">, no stack trace)");
}

function snip(str) {
    var maxChars = 41;
    if (str.length < maxChars) {
        return str;
    }
    return str.substr(0, maxChars - 3) + "...";
}

var shouldIgnore = function() { return false; };
var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
function parseLineInfo(line) {
    var matches = line.match(parseLineInfoRegex);
    if (matches) {
        return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
        };
    }
}
CapturedTrace.setBounds = function(firstLineError, lastLineError) {
    if (!CapturedTrace.isSupported()) return;
    var firstStackLines = firstLineError.stack.split("\n");
    var lastStackLines = lastLineError.stack.split("\n");
    var firstIndex = -1;
    var lastIndex = -1;
    var firstFileName;
    var lastFileName;
    for (var i = 0; i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
        }
    }
    for (var i = 0; i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
        }
    }
    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
        firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
    }

    shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
            if (info.fileName === firstFileName &&
                (firstIndex <= info.line && info.line <= lastIndex)) {
                return true;
            }
        }
        return false;
    };
};

var captureStackTrace = (function stackDetection() {
    var v8stackFramePattern = /^\s*at\s*/;
    var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string") return stack;

        if (error.name !== undefined &&
            error.message !== undefined) {
            return error.name + ". " + error.message;
        }
        return formatNonError(error);
    };

    if (typeof Error.stackTraceLimit === "number" &&
        typeof Error.captureStackTrace === "function") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace = Error.captureStackTrace;

        shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
            captureStackTrace(receiver, ignoreUntil);
        };
    }
    var err = new Error();

    if (typeof err.stack === "string" &&
        typeof "".startsWith === "function" &&
        (err.stack.startsWith("stackDetection@")) &&
        stackDetection.name === "stackDetection") {

        stackFramePattern = /@/;
        var rline = /[@\n]/;

        formatStack = function(stack, error) {
            if (typeof stack === "string") {
                return (error.name + ". " + error.message + "\n" + stack);
            }

            if (error.name !== undefined &&
                error.message !== undefined) {
                return error.name + ". " + error.message;
            }
            return formatNonError(error);
        };

        return function captureStackTrace(o) {
            var stack = new Error().stack;
            var split = stack.split(rline);
            var len = split.length;
            var ret = "";
            for (var i = 0; i < len; i += 2) {
                ret += split[i];
                ret += "@";
                ret += split[i + 1];
                ret += "\n";
            }
            o.stack = ret;
        };
    }

    var hasStackAfterThrow;
    try { throw new Error(); }
    catch(e) {
        hasStackAfterThrow = ("stack" in e);
    }
    if (!("stack" in err) && hasStackAfterThrow) {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) {
            try { throw new Error(); }
            catch(e) { o.stack = e.stack; }
        };
    }

    formatStack = function(stack, error) {
        if (typeof stack === "string") return stack;

        if ((typeof error === "object" ||
            typeof error === "function") &&
            error.name !== undefined &&
            error.message !== undefined) {
            return error.name + ". " + error.message;
        }
        return formatNonError(error);
    };

    return null;

})();

var fireGlobalEvent = (function() {
    if (typeof process !== "undefined" &&
        typeof process.version === "string" &&
        typeof window === "undefined") {
        return function(name, reason, promise) {
            if (name === "rejectionHandled") {
                return process.emit(name, promise);
            } else {
                return process.emit(name, reason, promise);
            }
        };
    } else {
        var toWindowMethodNameMap = {};
        toWindowMethodNameMap["unhandledRejection"] = ("on" +
            "unhandledRejection").toLowerCase();
        toWindowMethodNameMap["rejectionHandled"] = ("on" +
            "rejectionHandled").toLowerCase();

        return function(name, reason, promise) {
            var methodName = toWindowMethodNameMap[name];
            var method = window[methodName];
            if (!method) return false;
            if (name === "rejectionHandled") {
                method.call(window, promise);
            } else {
                method.call(window, reason, promise);
            }
            return true;
        };
    }
})();

return CapturedTrace;
};

}).call(this,require('_process'))
},{"./async.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/async.js","./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js","_process":"/Users/sash/development/js/imglykit-rewrite/node_modules/browserify/node_modules/process/browser.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/catch_filter.js":[function(require,module,exports){
"use strict";
module.exports = function(NEXT_FILTER) {
var util = require("./util.js");
var errors = require("./errors.js");
var tryCatch1 = util.tryCatch1;
var errorObj = util.errorObj;
var keys = require("./es5.js").keys;
var TypeError = errors.TypeError;

function CatchFilter(instances, callback, promise) {
    this._instances = instances;
    this._callback = callback;
    this._promise = promise;
}

function safePredicate(predicate, e) {
    var safeObject = {};
    var retfilter = tryCatch1(predicate, safeObject, e);

    if (retfilter === errorObj) return retfilter;

    var safeKeys = keys(safeObject);
    if (safeKeys.length) {
        errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
        return errorObj;
    }
    return retfilter;
}

CatchFilter.prototype.doFilter = function (e) {
    var cb = this._callback;
    var promise = this._promise;
    var boundTo = promise._boundTo;
    for (var i = 0, len = this._instances.length; i < len; ++i) {
        var item = this._instances[i];
        var itemIsErrorType = item === Error ||
            (item != null && item.prototype instanceof Error);

        if (itemIsErrorType && e instanceof item) {
            var ret = tryCatch1(cb, boundTo, e);
            if (ret === errorObj) {
                NEXT_FILTER.e = ret.e;
                return NEXT_FILTER;
            }
            return ret;
        } else if (typeof item === "function" && !itemIsErrorType) {
            var shouldHandle = safePredicate(item, e);
            if (shouldHandle === errorObj) {
                var trace = errors.canAttachTrace(errorObj.e)
                    ? errorObj.e
                    : new Error(util.toString(errorObj.e));
                this._promise._attachExtraTrace(trace);
                e = errorObj.e;
                break;
            } else if (shouldHandle) {
                var ret = tryCatch1(cb, boundTo, e);
                if (ret === errorObj) {
                    NEXT_FILTER.e = ret.e;
                    return NEXT_FILTER;
                }
                return ret;
            }
        }
    }
    NEXT_FILTER.e = e;
    return NEXT_FILTER;
};

return CatchFilter;
};

},{"./errors.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors.js","./es5.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/es5.js","./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/direct_resolve.js":[function(require,module,exports){
"use strict";
var util = require("./util.js");
var isPrimitive = util.isPrimitive;
var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;

module.exports = function(Promise) {
var returner = function () {
    return this;
};
var thrower = function () {
    throw this;
};

var wrapper = function (value, action) {
    if (action === 1) {
        return function () {
            throw value;
        };
    } else if (action === 2) {
        return function () {
            return value;
        };
    }
};


Promise.prototype["return"] =
Promise.prototype.thenReturn = function (value) {
    if (wrapsPrimitiveReceiver && isPrimitive(value)) {
        return this._then(
            wrapper(value, 2),
            undefined,
            undefined,
            undefined,
            undefined
       );
    }
    return this._then(returner, undefined, undefined, value, undefined);
};

Promise.prototype["throw"] =
Promise.prototype.thenThrow = function (reason) {
    if (wrapsPrimitiveReceiver && isPrimitive(reason)) {
        return this._then(
            wrapper(reason, 1),
            undefined,
            undefined,
            undefined,
            undefined
       );
    }
    return this._then(thrower, undefined, undefined, reason, undefined);
};
};

},{"./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/each.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var PromiseReduce = Promise.reduce;

Promise.prototype.each = function (fn) {
    return PromiseReduce(this, fn, null, INTERNAL);
};

Promise.each = function (promises, fn) {
    return PromiseReduce(promises, fn, null, INTERNAL);
};
};

},{}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors.js":[function(require,module,exports){
"use strict";
var Objectfreeze = require("./es5.js").freeze;
var propertyIsWritable = require("./es5.js").propertyIsWritable;
var util = require("./util.js");
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;

function markAsOriginatingFromRejection(e) {
    try {
        notEnumerableProp(e, "isOperational", true);
    }
    catch(ignore) {}
}

function originatesFromRejection(e) {
    if (e == null) return false;
    return ((e instanceof OperationalError) ||
        e["isOperational"] === true);
}

function isError(obj) {
    return obj instanceof Error;
}

function canAttachTrace(obj) {
    return isError(obj) && propertyIsWritable(obj, "stack");
}

function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp(this, "message",
            typeof message === "string" ? message : defaultMessage);
        notEnumerableProp(this, "name", nameProperty);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
    inherits(SubError, Error);
    return SubError;
}

var _TypeError, _RangeError;
var CancellationError = subError("CancellationError", "cancellation error");
var TimeoutError = subError("TimeoutError", "timeout error");
var AggregateError = subError("AggregateError", "aggregate error");
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch(e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
}

var methods = ("join pop push shift unshift slice filter forEach some " +
    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}

AggregateError.prototype.length = 0;
AggregateError.prototype["isOperational"] = true;
var level = 0;
AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:" + "\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret += str + "\n";
    }
    level--;
    return ret;
};

function OperationalError(message) {
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;

    if (message instanceof Error) {
        notEnumerableProp(this, "message", message.message);
        notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }

}
inherits(OperationalError, Error);

var key = "__BluebirdErrorTypes__";
var errorTypes = Error[key];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    notEnumerableProp(Error, key, errorTypes);
}

var ensureErrorObject = (function() {
    if (!("stack" in new Error())) {
        return function(value) {
            if (canAttachTrace(value)) return value;
            try {throw new Error(util.toString(value));}
            catch(err) {return err;}
        };
    } else {
        return function(value) {
            if (canAttachTrace(value)) return value;
            return new Error(util.toString(value));
        };
    }
})();

module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject
};

},{"./es5.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/es5.js","./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors_api_rejection.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise) {
var TypeError = require("./errors.js").TypeError;

function apiRejection(msg) {
    var error = new TypeError(msg);
    var ret = Promise.reject(error);
    var parent = ret._peekContext();
    if (parent != null) {
        parent.attachExtraTrace(error);
    }
    return ret;
}

return apiRejection;
};

},{"./errors.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/es5.js":[function(require,module,exports){
var isES5 = (function(){
    "use strict";
    return this === undefined;
})();

if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        keys: Object.keys,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5,
        propertyIsWritable: function(obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
        }
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;

    var ObjectKeys = function (o) {
        var ret = [];
        for (var key in o) {
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    };

    var ObjectDefineProperty = function (o, key, desc) {
        o[key] = desc.value;
        return o;
    };

    var ObjectFreeze = function (obj) {
        return obj;
    };

    var ObjectGetPrototypeOf = function (obj) {
        try {
            return Object(obj).constructor.prototype;
        }
        catch (e) {
            return proto;
        }
    };

    var ArrayIsArray = function (obj) {
        try {
            return str.call(obj) === "[object Array]";
        }
        catch(e) {
            return false;
        }
    };

    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5,
        propertyIsWritable: function() {
            return true;
        }
    };
}

},{}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/filter.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var PromiseMap = Promise.map;

Promise.prototype.filter = function (fn, options) {
    return PromiseMap(this, fn, options, INTERNAL);
};

Promise.filter = function (promises, fn, options) {
    return PromiseMap(promises, fn, options, INTERNAL);
};
};

},{}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/finally.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
var util = require("./util.js");
var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
var isPrimitive = util.isPrimitive;
var thrower = util.thrower;

function returnThis() {
    return this;
}
function throwThis() {
    throw this;
}
function return$(r) {
    return function() {
        return r;
    };
}
function throw$(r) {
    return function() {
        throw r;
    };
}
function promisedFinally(ret, reasonOrValue, isFulfilled) {
    var then;
    if (wrapsPrimitiveReceiver && isPrimitive(reasonOrValue)) {
        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
    } else {
        then = isFulfilled ? returnThis : throwThis;
    }
    return ret._then(then, thrower, undefined, reasonOrValue, undefined);
}

function finallyHandler(reasonOrValue) {
    var promise = this.promise;
    var handler = this.handler;

    var ret = promise._isBound()
                    ? handler.call(promise._boundTo)
                    : handler();

    if (ret !== undefined) {
        var maybePromise = tryConvertToPromise(ret, undefined);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            return promisedFinally(maybePromise, reasonOrValue,
                                    promise.isFulfilled());
        }
    }

    if (promise.isRejected()) {
        NEXT_FILTER.e = reasonOrValue;
        return NEXT_FILTER;
    } else {
        return reasonOrValue;
    }
}

function tapHandler(value) {
    var promise = this.promise;
    var handler = this.handler;

    var ret = promise._isBound()
                    ? handler.call(promise._boundTo, value)
                    : handler(value);

    if (ret !== undefined) {
        var maybePromise = tryConvertToPromise(ret, undefined);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            return promisedFinally(maybePromise, value, true);
        }
    }
    return value;
}

Promise.prototype._passThroughHandler = function (handler, isFinally) {
    if (typeof handler !== "function") return this.then();

    var promiseAndHandler = {
        promise: this,
        handler: handler
    };

    return this._then(
            isFinally ? finallyHandler : tapHandler,
            isFinally ? finallyHandler : undefined, undefined,
            promiseAndHandler, undefined);
};

Promise.prototype.lastly =
Promise.prototype["finally"] = function (handler) {
    return this._passThroughHandler(handler, true);
};

Promise.prototype.tap = function (handler) {
    return this._passThroughHandler(handler, false);
};
};

},{"./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/generators.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise,
                          apiRejection,
                          INTERNAL,
                          tryConvertToPromise) {
var errors = require("./errors.js");
var TypeError = errors.TypeError;
var deprecated = require("./util.js").deprecated;
var util = require("./util.js");
var errorObj = util.errorObj;
var tryCatch1 = util.tryCatch1;
var yieldHandlers = [];

function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
    var _errorObj = errorObj;
    var _Promise = Promise;
    var len = yieldHandlers.length;
    for (var i = 0; i < len; ++i) {
        traceParent._pushContext();
        var result = tryCatch1(yieldHandlers[i], undefined, value);
        traceParent._popContext();
        if (result === _errorObj) {
            return _Promise.reject(_errorObj.e);
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof _Promise) return maybePromise;
    }
    return null;
}

function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
    var promise = this._promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    this._stack = stack;
    this._generatorFunction = generatorFunction;
    this._receiver = receiver;
    this._generator = undefined;
    this._yieldHandlers = typeof yieldHandler === "function"
        ? [yieldHandler].concat(yieldHandlers)
        : yieldHandlers;
}

PromiseSpawn.prototype.promise = function () {
    return this._promise;
};

PromiseSpawn.prototype._run = function () {
    this._generator = this._generatorFunction.call(this._receiver);
    this._receiver =
        this._generatorFunction = undefined;
    this._next(undefined);
};

PromiseSpawn.prototype._continue = function (result) {
    if (result === errorObj) {
        this._generator = undefined;
        var trace = errors.canAttachTrace(result.e)
            ? result.e : new Error(util.toString(result.e));
        this._promise._attachExtraTrace(trace);
        this._promise._reject(result.e, trace);
        return;
    }

    var value = result.value;
    if (result.done === true) {
        this._generator = undefined;
        if (!this._promise._tryFollow(value)) {
            this._promise._fulfill(value);
        }
    } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise)) {
            maybePromise =
                promiseFromYieldHandler(maybePromise,
                                        this._yieldHandlers,
                                        this._promise);
            if (maybePromise === null) {
                this._throw(
                    new TypeError(
                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
                        "From coroutine:\u000a" +
                        this._stack.split("\n").slice(1, -7).join("\n")
                    )
                );
                return;
            }
        }
        maybePromise._then(
            this._next,
            this._throw,
            undefined,
            this,
            null
       );
    }
};

PromiseSpawn.prototype._throw = function (reason) {
    if (errors.canAttachTrace(reason))
        this._promise._attachExtraTrace(reason);
    this._promise._pushContext();
    var result = tryCatch1(this._generator["throw"], this._generator, reason);
    this._promise._popContext();
    this._continue(result);
};

PromiseSpawn.prototype._next = function (value) {
    this._promise._pushContext();
    var result = tryCatch1(this._generator.next, this._generator, value);
    this._promise._popContext();
    this._continue(result);
};

Promise.coroutine = function (generatorFunction, options) {
    if (typeof generatorFunction !== "function") {
        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
    }
    var yieldHandler = Object(options).yieldHandler;
    var PromiseSpawn$ = PromiseSpawn;
    var stack = new Error().stack;
    return function () {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
                                      stack);
        spawn._generator = generator;
        spawn._next(undefined);
        return spawn.promise();
    };
};

Promise.coroutine.addYieldHandler = function(fn) {
    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    yieldHandlers.push(fn);
};

Promise.spawn = function (generatorFunction) {
    deprecated("Promise.spawn is deprecated. Use Promise.coroutine instead.");
    if (typeof generatorFunction !== "function") {
        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
    }
    var spawn = new PromiseSpawn(generatorFunction, this);
    var ret = spawn.promise();
    spawn._run(Promise.spawn);
    return ret;
};
};

},{"./errors.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors.js","./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/join.js":[function(require,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
var util = require("./util.js");
var canEvaluate = util.canEvaluate;
var tryCatch1 = util.tryCatch1;
var errorObj = util.errorObj;
var errors = require("./errors.js");

if (canEvaluate) {
    var thenCallback = function(i) {
        return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
    };

    var caller = function(count) {
        var values = [];
        for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
        return new Function("holder", "                                      \n\
            'use strict';                                                    \n\
            var callback = holder.fn;                                        \n\
            return callback(values);                                         \n\
            ".replace(/values/g, values.join(", ")));
    };
    var thenCallbacks = [];
    var callers = [undefined];
    for (var i = 1; i <= 5; ++i) {
        thenCallbacks.push(thenCallback(i));
        callers.push(caller(i));
    }

    var Holder = function(total, fn) {
        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
        this.fn = fn;
        this.total = total;
        this.now = 0;
    };

    Holder.prototype.callers = callers;
    Holder.prototype.checkFulfillment = function(promise) {
        var now = this.now;
        now++;
        var total = this.total;
        if (now >= total) {
            var handler = this.callers[total];
            promise._pushContext();
            var ret = tryCatch1(handler, undefined, this);
            promise._popContext();
            if (ret === errorObj) {
                var reason = ret.e;
                var trace = errors.ensureErrorObject(reason);
                promise._attachExtraTrace(trace);
                promise._rejectUnchecked(reason,
                    trace === reason ? undefined : trace);
            } else if (!promise._tryFollow(ret)) {
                promise._fulfillUnchecked(ret);
            }
        } else {
            this.now = now;
        }
    };
}

function reject(reason) {
    this._reject(reason);
}

Promise.join = function () {
    var last = arguments.length - 1;
    var fn;
    if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (last < 6 && canEvaluate) {
            var ret = new Promise(INTERNAL);
            ret._captureStackTrace();
            var holder = new Holder(last, fn);
            var callbacks = thenCallbacks;
            for (var i = 0; i < last; ++i) {
                var maybePromise = tryConvertToPromise(arguments[i], undefined);
                if (maybePromise instanceof Promise) {
                    maybePromise = maybePromise._target();
                    if (maybePromise._isPending()) {
                        maybePromise._then(callbacks[i], reject,
                                           undefined, ret, holder);
                    } else if (maybePromise._isFulfilled()) {
                        callbacks[i].call(ret,
                                          maybePromise._value(), holder);
                    } else {
                        ret._reject(maybePromise._reason());
                        maybePromise._unsetRejectionIsUnhandled();
                    }
                } else {
                    callbacks[i].call(ret, maybePromise, holder);
                }
            }
            return ret;
        }
    }
    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
    var ret = new PromiseArray(args).promise();
    return fn !== undefined ? ret.spread(fn) : ret;
};

};

},{"./errors.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors.js","./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/map.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL) {
var util = require("./util.js");
var tryCatch3 = util.tryCatch3;
var errorObj = util.errorObj;
var PENDING = {};
var EMPTY_ARRAY = [];

function MappingPromiseArray(promises, fn, limit, _filter) {
    this.constructor$(promises);
    this._promise._setIsSpreadable();
    this._promise._captureStackTrace();
    this._callback = fn;
    this._preservedValues = _filter === INTERNAL
        ? new Array(this.length())
        : null;
    this._limit = limit;
    this._inFlight = 0;
    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
    this._init$(undefined, -2);
}
util.inherits(MappingPromiseArray, PromiseArray);

MappingPromiseArray.prototype._init = function () {};

MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var values = this._values;
    var length = this.length();
    var preservedValues = this._preservedValues;
    var limit = this._limit;
    if (values[index] === PENDING) {
        values[index] = value;
        if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved()) return;
        }
    } else {
        if (limit >= 1 && this._inFlight >= limit) {
            values[index] = value;
            this._queue.push(index);
            return;
        }
        if (preservedValues !== null) preservedValues[index] = value;

        var callback = this._callback;
        var receiver = this._promise._boundTo;
        this._promise._pushContext();
        var ret = tryCatch3(callback, receiver, value, index, length);
        this._promise._popContext();
        if (ret === errorObj) return this._reject(ret.e);

        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            if (maybePromise._isPending()) {
                if (limit >= 1) this._inFlight++;
                values[index] = PENDING;
                return maybePromise._proxyPromiseArray(this, index);
            } else if (maybePromise._isFulfilled()) {
                ret = maybePromise._value();
            } else {
                maybePromise._unsetRejectionIsUnhandled();
                return this._reject(maybePromise._reason());
            }
        }
        values[index] = ret;
    }
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= length) {
        if (preservedValues !== null) {
            this._filter(values, preservedValues);
        } else {
            this._resolve(values);
        }

    }
};

MappingPromiseArray.prototype._drainQueue = function () {
    var queue = this._queue;
    var limit = this._limit;
    var values = this._values;
    while (queue.length > 0 && this._inFlight < limit) {
        if (this._isResolved()) return;
        var index = queue.pop();
        this._promiseFulfilled(values[index], index);
    }
};

MappingPromiseArray.prototype._filter = function (booleans, values) {
    var len = values.length;
    var ret = new Array(len);
    var j = 0;
    for (var i = 0; i < len; ++i) {
        if (booleans[i]) ret[j++] = values[i];
    }
    ret.length = j;
    this._resolve(ret);
};

MappingPromiseArray.prototype.preservedValues = function () {
    return this._preservedValues;
};

function map(promises, fn, options, _filter) {
    var limit = typeof options === "object" && options !== null
        ? options.concurrency
        : 0;
    limit = typeof limit === "number" &&
        isFinite(limit) && limit >= 1 ? limit : 0;
    return new MappingPromiseArray(promises, fn, limit, _filter);
}

Promise.prototype.map = function (fn, options) {
    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");

    return map(this, fn, options, null).promise();
};

Promise.map = function (promises, fn, options, _filter) {
    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    return map(promises, fn, options, _filter).promise();
};


};

},{"./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/nodeify.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise) {
var util = require("./util.js");
var async = require("./async.js");
var tryCatch2 = util.tryCatch2;
var tryCatch1 = util.tryCatch1;
var errorObj = util.errorObj;

function spreadAdapter(val, nodeback) {
    var promise = this;
    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
    var ret = util.tryCatchApply(nodeback,
                                 [null].concat(val), promise._boundTo);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

function successAdapter(val, nodeback) {
    var promise = this;
    var receiver = promise._boundTo;
    var ret = val === undefined
        ? tryCatch1(nodeback, receiver, null)
        : tryCatch2(nodeback, receiver, null, val);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}
function errorAdapter(reason, nodeback) {
    var promise = this;
    if (!reason) {
        var target = promise._target();
        var newReason = target._getCarriedStackTrace();
        newReason.cause = reason;
        reason = newReason;
    }
    var ret = tryCatch1(nodeback, promise._boundTo, reason);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

Promise.prototype.nodeify = function (nodeback, options) {
    if (typeof nodeback == "function") {
        var adapter = successAdapter;
        if (options !== undefined && Object(options).spread) {
            adapter = spreadAdapter;
        }
        this._then(
            adapter,
            errorAdapter,
            undefined,
            this,
            nodeback
        );
    }
    return this;
};
};

},{"./async.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/async.js","./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/progress.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise, PromiseArray) {
var util = require("./util.js");
var async = require("./async.js");
var errors = require("./errors.js");
var tryCatch1 = util.tryCatch1;
var errorObj = util.errorObj;

Promise.prototype.progressed = function (handler) {
    return this._then(undefined, undefined, handler, undefined, undefined);
};

Promise.prototype._progress = function (progressValue) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    this._target()._progressUnchecked(progressValue);

};

Promise.prototype._progressHandlerAt = function (index) {
    return index === 0
        ? this._progressHandler0
        : this[(index << 2) + index - 5 + 2];
};

Promise.prototype._doProgressWith = function (progression) {
    var progressValue = progression.value;
    var handler = progression.handler;
    var promise = progression.promise;
    var receiver = progression.receiver;

    var ret = tryCatch1(handler, receiver, progressValue);
    if (ret === errorObj) {
        if (ret.e != null &&
            ret.e.name !== "StopProgressPropagation") {
            var trace = errors.canAttachTrace(ret.e)
                ? ret.e : new Error(util.toString(ret.e));
            promise._attachExtraTrace(trace);
            promise._progress(ret.e);
        }
    } else if (ret instanceof Promise) {
        ret._then(promise._progress, null, null, promise, undefined);
    } else {
        promise._progress(ret);
    }
};


Promise.prototype._progressUnchecked = function (progressValue) {
    var len = this._length();
    var progress = this._progress;
    for (var i = 0; i < len; i++) {
        var handler = this._progressHandlerAt(i);
        var promise = this._promiseAt(i);
        if (!(promise instanceof Promise)) {
            var receiver = this._receiverAt(i);
            if (typeof handler === "function") {
                handler.call(receiver, progressValue, promise);
            } else if (receiver instanceof PromiseArray &&
                       !receiver._isResolved()) {
                receiver._promiseProgressed(progressValue, promise);
            }
            continue;
        }

        if (typeof handler === "function") {
            async.invoke(this._doProgressWith, this, {
                handler: handler,
                promise: promise,
                receiver: this._receiverAt(i),
                value: progressValue
            });
        } else {
            async.invoke(progress, promise, progressValue);
        }
    }
};
};

},{"./async.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/async.js","./errors.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors.js","./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/promise.js":[function(require,module,exports){
(function (process){
"use strict";
module.exports = function() {
var makeSelfResolutionError = function () {
    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
};
var reflect = function() {
    return new Promise.PromiseInspection(this._target());
};
var util = require("./util.js");
var async = require("./async.js");
var errors = require("./errors.js");
var INTERNAL = function(){};
var APPLY = {};
var NEXT_FILTER = {e: null};
var apiRejection = require("./errors_api_rejection")(Promise);
var tryConvertToPromise = require("./thenables.js")(Promise, INTERNAL);
var PromiseArray =
    require("./promise_array.js")(Promise, INTERNAL,
                                    tryConvertToPromise, apiRejection);
var CapturedTrace = require("./captured_trace.js")();
var CatchFilter = require("./catch_filter.js")(NEXT_FILTER);
var PromiseResolver = require("./promise_resolver.js");
var isArray = util.isArray;
var errorObj = util.errorObj;
var tryCatch0 = util.tryCatch0;
var tryCatch1 = util.tryCatch1;
var tryCatch2 = util.tryCatch2;
var tryCatchApply = util.tryCatchApply;
var RangeError = errors.RangeError;
var TypeError = errors.TypeError;
var CancellationError = errors.CancellationError;
var TimeoutError = errors.TimeoutError;
var OperationalError = errors.OperationalError;
var originatesFromRejection = errors.originatesFromRejection;
var markAsOriginatingFromRejection = errors.markAsOriginatingFromRejection;
var canAttachTrace = errors.canAttachTrace;
var unhandledRejectionHandled;
var possiblyUnhandledRejection;

var debugging = false || !!(
    typeof process !== "undefined" &&
    typeof process.execPath === "string" &&
    typeof process.env === "object" &&
    (process.env["BLUEBIRD_DEBUG"] ||
        process.env["NODE_ENV"] === "development")
);
function Promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
    }
    if (this.constructor !== Promise) {
        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
    }
    this._bitField = 0;
    this._fulfillmentHandler0 = undefined;
    this._rejectionHandler0 = undefined;
    this._progressHandler0 = undefined;
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._settledValue = undefined;
    this._boundTo = undefined;
    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
}

Promise.prototype.bind = function (thisArg) {
    var maybePromise = tryConvertToPromise(thisArg, this);
    var ret = new Promise(INTERNAL);
    ret._propagateFrom(this, 1);
    var target = this._target();
    if (maybePromise instanceof Promise) {
        target._then(INTERNAL, ret._reject, ret._progress, ret, null);
        maybePromise._then(function(thisArg) {
            if (ret._isPending()) {
                ret._setBoundTo(thisArg);
                ret._follow(target);
            }
        }, ret._reject, ret._progress, ret, null);
    } else {
        ret._setBoundTo(thisArg);
        ret._follow(target);
    }

    return ret;
};

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
    var len = arguments.length;
    if (len > 1) {
        var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (typeof item === "function") {
                catchInstances[j++] = item;
            } else {
                var error = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
                this._attachExtraTrace(error);
                return Promise.reject(error);
            }
        }
        catchInstances.length = j;
        fn = arguments[i];
        var catchFilter = new CatchFilter(catchInstances, fn, this);
        return this._then(undefined, catchFilter.doFilter, undefined,
            catchFilter, undefined);
    }
    return this._then(undefined, fn, undefined, undefined, undefined);
};

Promise.prototype.reflect = function () {
    return this._then(reflect, reflect, undefined, this, undefined);
};

Promise.prototype.then = function (didFulfill, didReject, didProgress) {
    return this._then(didFulfill, didReject, didProgress,
        undefined, undefined);
};


Promise.prototype.done = function (didFulfill, didReject, didProgress) {
    var promise = this._then(didFulfill, didReject, didProgress,
        undefined, undefined);
    promise._setIsFinal();
};

Promise.prototype.spread = function (didFulfill, didReject) {
    var followee = this._target();
    var target = followee._isSpreadable()
        ? (followee === this ? this : this.then())
        : this.all();
    return target._then(didFulfill, didReject, undefined, APPLY, undefined);
};

Promise.prototype.isCancellable = function () {
    return !this.isResolved() &&
        this._cancellable();
};

Promise.prototype.toJSON = function () {
    var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: undefined,
        rejectionReason: undefined
    };
    if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
    } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
    }
    return ret;
};

Promise.prototype.all = function () {
    var ret = new PromiseArray(this).promise();
    ret._setIsSpreadable();
    return ret;
};

Promise.prototype.error = function (fn) {
    return this.caught(originatesFromRejection, fn);
};

Promise.is = function (val) {
    return val instanceof Promise;
};

Promise.all = function (promises) {
    var ret = new PromiseArray(promises).promise();
    ret._setIsSpreadable();
    return ret;
};

Promise.method = function (fn) {
    if (typeof fn !== "function") {
        throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    }
    return function () {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        var value;
        ret._pushContext();
        switch(arguments.length) {
        case 0: value = tryCatch0(fn, this); break;
        case 1: value = tryCatch1(fn, this, arguments[0]); break;
        case 2: value = tryCatch2(fn, this, arguments[0], arguments[1]); break;
        default:
            var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
            value = tryCatchApply(fn, args, this); break;
        }
        ret._popContext();
        ret._resolveFromSyncValue(value);
        return ret;
    };
};

Promise.attempt = Promise["try"] = function (fn, args, ctx) {
    if (typeof fn !== "function") {
        return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    }
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._pushContext();
    var value = isArray(args)
        ? tryCatchApply(fn, args, ctx)
        : tryCatch1(fn, ctx, args);
    ret._popContext();
    ret._resolveFromSyncValue(value);
    return ret;
};

Promise.defer = Promise.pending = function () {
    var promise = new Promise(INTERNAL);
    return new PromiseResolver(promise);
};

Promise.bind = function (thisArg) {
    var maybePromise = tryConvertToPromise(thisArg, undefined);
    var ret = new Promise(INTERNAL);

    if (maybePromise instanceof Promise) {
        maybePromise._then(function(thisArg) {
            ret._setBoundTo(thisArg);
            ret._fulfill(undefined);
        }, ret._reject, ret._progress, ret, null);
    } else {
        ret._setBoundTo(thisArg);
        ret._setFulfilled();
    }
    return ret;
};

Promise.cast = function (obj) {
    var ret = tryConvertToPromise(obj, undefined);
    if (!(ret instanceof Promise)) {
        var val = ret;
        ret = new Promise(INTERNAL);
        ret._setFulfilled();
        ret._settledValue = val;
        ret._cleanValues();
    }
    return ret;
};

Promise.resolve = Promise.fulfilled = Promise.cast;

Promise.reject = Promise.rejected = function (reason) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    markAsOriginatingFromRejection(reason);
    var hasStack = canAttachTrace(reason) && typeof reason.stack === "string";
    var trace = errors.ensureErrorObject(reason);
    ret._attachExtraTrace(reason, hasStack);
    ret._rejectUnchecked(reason, trace === reason ? undefined : trace);
    return ret;
};

Promise.onPossiblyUnhandledRejection = function (fn) {
    possiblyUnhandledRejection = typeof fn === "function" ? fn : undefined;
};

Promise.onUnhandledRejectionHandled = function (fn) {
    unhandledRejectionHandled = typeof fn === "function" ? fn : undefined;
};

Promise.longStackTraces = function () {
    if (async.haveItemsQueued() &&
        debugging === false
   ) {
        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
    }
    debugging = CapturedTrace.isSupported();
};

Promise.hasLongStackTraces = function () {
    return debugging && CapturedTrace.isSupported();
};

Promise.setScheduler = function(fn) {
    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    async._schedule = fn;
};

Promise.prototype._then = function (
    didFulfill,
    didReject,
    didProgress,
    receiver,
    internalData
) {
    var haveInternalData = internalData !== undefined;
    var ret = haveInternalData ? internalData : new Promise(INTERNAL);

    if (!haveInternalData) {
        ret._propagateFrom(this, 4 | 1);
        ret._captureStackTrace();
    }

    var target = this._target();
    if (target !== this) {
        if (receiver === undefined) receiver = this._boundTo;
        if (!haveInternalData) ret._setIsMigrated();
    }

    var callbackIndex =
        target._addCallbacks(didFulfill, didReject, didProgress, ret, receiver);

    if (target._isResolved() && !target._isSettlePromisesQueued()) {
        async.invoke(
            target._settlePromiseAtPostResolution, target, callbackIndex);
    }

    return ret;
};

Promise.prototype._settlePromiseAtPostResolution = function (index) {
    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
    this._settlePromiseAt(index);
};

Promise.prototype._length = function () {
    return this._bitField & 131071;
};

Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
    return (this._bitField & 939524096) > 0;
};

Promise.prototype._isFollowing = function () {
    return (this._bitField & 536870912) === 536870912;
};

Promise.prototype._setLength = function (len) {
    this._bitField = (this._bitField & -131072) |
        (len & 131071);
};

Promise.prototype._setFulfilled = function () {
    this._bitField = this._bitField | 268435456;
};

Promise.prototype._setRejected = function () {
    this._bitField = this._bitField | 134217728;
};

Promise.prototype._setFollowing = function () {
    this._bitField = this._bitField | 536870912;
};

Promise.prototype._setIsFinal = function () {
    this._bitField = this._bitField | 33554432;
};

Promise.prototype._isFinal = function () {
    return (this._bitField & 33554432) > 0;
};

Promise.prototype._cancellable = function () {
    return (this._bitField & 67108864) > 0;
};

Promise.prototype._setCancellable = function () {
    this._bitField = this._bitField | 67108864;
};

Promise.prototype._unsetCancellable = function () {
    this._bitField = this._bitField & (~67108864);
};

Promise.prototype._setRejectionIsUnhandled = function () {
    this._bitField = this._bitField | 2097152;
};

Promise.prototype._unsetRejectionIsUnhandled = function () {
    this._bitField = this._bitField & (~2097152);
    if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
    }
};

Promise.prototype._isRejectionUnhandled = function () {
    return (this._bitField & 2097152) > 0;
};

Promise.prototype._isSpreadable = function () {
    return (this._bitField & 131072) > 0;
};

Promise.prototype._setIsSpreadable = function () {
    this._bitField = this._bitField | 131072;
};

Promise.prototype._setIsMigrated = function () {
    this._bitField = this._bitField | 4194304;
};

Promise.prototype._unsetIsMigrated = function () {
    this._bitField = this._bitField & (~4194304);
};

Promise.prototype._isMigrated = function () {
    return (this._bitField & 4194304) > 0;
};

Promise.prototype._setUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField | 524288;
};

Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField & (~524288);
};

Promise.prototype._isUnhandledRejectionNotified = function () {
    return (this._bitField & 524288) > 0;
};

Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
    this._bitField = this._bitField | 1048576;
    this._fulfillmentHandler0 = capturedTrace;
};

Promise.prototype._isCarryingStackTrace = function () {
    return (this._bitField & 1048576) > 0;
};

Promise.prototype._getCarriedStackTrace = function () {
    return this._isCarryingStackTrace()
        ? this._fulfillmentHandler0
        : undefined;
};

Promise.prototype._receiverAt = function (index) {
    var ret = index === 0
        ? this._receiver0
        : this[
            index * 5 - 5 + 4];
    if (this._isBound() && ret === undefined) {
        return this._boundTo;
    }
    return ret;
};

Promise.prototype._promiseAt = function (index) {
    return index === 0
        ? this._promise0
        : this[index * 5 - 5 + 3];
};

Promise.prototype._fulfillmentHandlerAt = function (index) {
    return index === 0
        ? this._fulfillmentHandler0
        : this[index * 5 - 5 + 0];
};

Promise.prototype._rejectionHandlerAt = function (index) {
    return index === 0
        ? this._rejectionHandler0
        : this[index * 5 - 5 + 1];
};

Promise.prototype._migrateCallbacks = function (
    fulfill,
    reject,
    progress,
    promise,
    receiver
) {
    if (promise instanceof Promise) promise._setIsMigrated();
    this._addCallbacks(fulfill, reject, progress, promise, receiver);
};

Promise.prototype._addCallbacks = function (
    fulfill,
    reject,
    progress,
    promise,
    receiver
) {
    var index = this._length();

    if (index >= 131071 - 5) {
        index = 0;
        this._setLength(0);
    }

    if (index === 0) {
        this._promise0 = promise;
        if (receiver !== undefined) this._receiver0 = receiver;
        if (typeof fulfill === "function" && !this._isCarryingStackTrace())
            this._fulfillmentHandler0 = fulfill;
        if (typeof reject === "function") this._rejectionHandler0 = reject;
        if (typeof progress === "function") this._progressHandler0 = progress;
    } else {
        var base = index * 5 - 5;
        this[base + 3] = promise;
        this[base + 4] = receiver;
        if (typeof fulfill === "function")
            this[base + 0] = fulfill;
        if (typeof reject === "function")
            this[base + 1] = reject;
        if (typeof progress === "function")
            this[base + 2] = progress;
    }
    this._setLength(index + 1);
    return index;
};

Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
    var index = this._length();

    if (index >= 131071 - 5) {
        index = 0;
        this._setLength(0);
    }
    if (index === 0) {
        this._promise0 = promiseSlotValue;
        this._receiver0 = receiver;
    } else {
        var base = index * 5 - 5;
        this[base + 3] = promiseSlotValue;
        this[base + 4] = receiver;
    }
    this._setLength(index + 1);
};

Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
    this._setProxyHandlers(promiseArray, index);
};

Promise.prototype._setBoundTo = function (obj) {
    if (obj !== undefined) {
        this._bitField = this._bitField | 8388608;
        this._boundTo = obj;
    } else {
        this._bitField = this._bitField & (~8388608);
    }
};

Promise.prototype._isBound = function () {
    return (this._bitField & 8388608) === 8388608;
};

Promise.prototype._resolveFromResolver = function (resolver) {
    var promise = this;
    var synchronous = true;

    this._captureStackTrace();
    this._pushContext();
    var r = tryCatch2(resolver, undefined, function(value) {
        if (promise._tryFollow(value)) {
            return;
        }
        promise._fulfill(value);
    }, function (reason) {
        markAsOriginatingFromRejection(reason);
        var trace = errors.ensureErrorObject(reason);
        var hasStack = canAttachTrace(reason) &&
            typeof trace.stack === "string";
        promise._attachExtraTrace(trace, synchronous ? hasStack : false);
        promise._reject(reason, trace === reason ? undefined : trace);
    });
    synchronous = false;
    this._popContext();

    if (r !== undefined && r === errorObj) {
        var reason = r.e;
        var hasStack = canAttachTrace(reason) &&
            typeof reason.stack === "string";
        var trace = errors.ensureErrorObject(reason);
        promise._attachExtraTrace(reason, hasStack);
        promise._reject(reason, trace === reason ? undefined : trace);
    }
};

Promise.prototype._settlePromiseFromHandler = function (
    handler, receiver, value, promise
) {
    if (promise._isRejected()) return;
    promise._pushContext();
    var x;
    if (receiver === APPLY && !this._isRejected()) {
        x = tryCatchApply(handler, value, this._boundTo);
    } else {
        x = tryCatch1(handler, receiver, value);
    }
    promise._popContext();

    if (x === errorObj || x === promise || x === NEXT_FILTER) {
        var err = x === promise
                    ? makeSelfResolutionError()
                    : x.e;
        var trace = canAttachTrace(err) ? err : new Error(util.toString(err));
        if (x !== NEXT_FILTER) promise._attachExtraTrace(trace);
        promise._rejectUnchecked(err, trace);
    } else {
        x = tryConvertToPromise(x, promise);
        if (x instanceof Promise) {
            x = x._target();
            if (x._isRejected() &&
                !x._isCarryingStackTrace() &&
                !canAttachTrace(x._reason())) {
                var trace = new Error(util.toString(x._reason()));
                promise._attachExtraTrace(trace);
                x._setCarriedStackTrace(trace);
            }
            promise._follow(x);
        } else {
            promise._fulfillUnchecked(x);
        }
    }
};

Promise.prototype._target = function() {
    var ret = this;
    while (ret._isFollowing()) ret = ret._followee();
    return ret;
};

Promise.prototype._followee = function() {
    return this._rejectionHandler0;
};

Promise.prototype._setFollowee = function(promise) {
    this._rejectionHandler0 = promise;
};

Promise.prototype._follow = function (promise) {
    if (promise._isPending()) {
        var len = this._length();
        for (var i = 0; i < len; ++i) {
            promise._migrateCallbacks(
                this._fulfillmentHandlerAt(i),
                this._rejectionHandlerAt(i),
                this._progressHandlerAt(i),
                this._promiseAt(i),
                this._receiverAt(i)
            );
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(promise);
        this._propagateFrom(promise, 1);
    } else if (promise._isFulfilled()) {
        this._fulfillUnchecked(promise._value());
    } else {
        this._rejectUnchecked(promise._reason(),
            promise._getCarriedStackTrace());
    }
    if (promise._isRejectionUnhandled()) promise._unsetRejectionIsUnhandled();
};

Promise.prototype._tryFollow = function (value) {
    if (this._isFollowingOrFulfilledOrRejected() ||
        value === this) {
        return false;
    }
    var maybePromise = tryConvertToPromise(value, this);
    if (!(maybePromise instanceof Promise)) {
        return false;
    }
    this._follow(maybePromise._target());
    return true;
};

Promise.prototype._captureStackTrace = function () {
    if (debugging) {
        this._trace = new CapturedTrace(this._peekContext());
    }
    return this;
};

Promise.prototype._canAttachTrace = function(error) {
    return debugging && canAttachTrace(error);
};

Promise.prototype._attachExtraTraceIgnoreSelf = function (error) {
    if (this._canAttachTrace(error) && this._trace._parent !== undefined) {
        this._trace._parent.attachExtraTrace(error);
    }
};

Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
    if (debugging && canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== undefined) {
            if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== undefined) {
            trace.attachExtraTrace(error);
        } else {
            CapturedTrace.cleanStack(error, true);
        }
    }
};

Promise.prototype._cleanValues = function () {
    if (this._cancellable()) {
        this._cancellationParent = undefined;
    }
};

Promise.prototype._propagateFrom = function (parent, flags) {
    if ((flags & 1) > 0 && parent._cancellable()) {
        this._setCancellable();
        this._cancellationParent = parent;
    }
    if ((flags & 4) > 0) {
        this._setBoundTo(parent._boundTo);
    }
};

Promise.prototype._fulfill = function (value) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    this._fulfillUnchecked(value);
};

Promise.prototype._reject = function (reason, carriedStackTrace) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    this._rejectUnchecked(reason, carriedStackTrace);
};

Promise.prototype._settlePromiseAt = function (index) {
    var promise = this._promiseAt(index);
    var isPromise = promise instanceof Promise;

    if (isPromise && promise._isMigrated()) {
        promise._unsetIsMigrated();
        return async.invoke(this._settlePromiseAt, this, index);
    }
    var handler = this._isFulfilled()
        ? this._fulfillmentHandlerAt(index)
        : this._rejectionHandlerAt(index);

    var carriedStackTrace =
        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
    var value = this._settledValue;
    var receiver = this._receiverAt(index);


    this._clearCallbackDataAtIndex(index);

    if (typeof handler === "function") {
        if (!isPromise) {
            handler.call(receiver, value, promise);
        } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (receiver instanceof PromiseArray) {
        if (!receiver._isResolved()) {
            if (this._isFulfilled()) {
                receiver._promiseFulfilled(value, promise);
            }
            else {
                receiver._promiseRejected(value, promise);
            }
        }
    } else if (isPromise) {
        if (this._isFulfilled()) {
            promise._fulfill(value);
        } else {
            promise._reject(value, carriedStackTrace);
        }
    }

    if (index >= 4 && (index & 31) === 4)
        async.invokeLater(this._setLength, this, 0);
};

Promise.prototype._clearCallbackDataAtIndex = function(index) {
    if (index === 0) {
        if (!this._isCarryingStackTrace()) {
            this._fulfillmentHandler0 = undefined;
        }
        this._rejectionHandler0 =
        this._progressHandler0 =
        this._receiver0 =
        this._promise0 = undefined;
    } else {
        var base = index * 5 - 5;
        this[base + 3] =
        this[base + 4] =
        this[base + 0] =
        this[base + 1] =
        this[base + 2] = undefined;
    }
};

Promise.prototype._isSettlePromisesQueued = function () {
    return (this._bitField &
            -1073741824) === -1073741824;
};

Promise.prototype._setSettlePromisesQueued = function () {
    this._bitField = this._bitField | -1073741824;
};

Promise.prototype._unsetSettlePromisesQueued = function () {
    this._bitField = this._bitField & (~-1073741824);
};

Promise.prototype._queueSettlePromises = function() {
    if (!this._isSettlePromisesQueued()) {
        async.settlePromises(this);
        this._setSettlePromisesQueued();
    }
};

Promise.prototype._fulfillUnchecked = function (value) {
    if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._rejectUnchecked(err, undefined);
    }
    this._setFulfilled();
    this._settledValue = value;
    this._cleanValues();

    if (this._length() > 0) {
        this._queueSettlePromises();
    }
};

Promise.prototype._rejectUncheckedCheckError = function (reason) {
    var trace = errors.ensureErrorObject(reason);
    this._rejectUnchecked(reason, trace === reason ? undefined : trace);
};

Promise.prototype._rejectUnchecked = function (reason, trace) {
    if (reason === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._rejectUnchecked(err);
    }
    this._setRejected();
    this._settledValue = reason;
    this._cleanValues();

    if (this._isFinal()) {
        async.throwLater(function(e) {
            if ("stack" in e) {
                async.invokeFirst(
                    CapturedTrace.unhandledRejection, undefined, e);
            }
            throw e;
        }, trace === undefined ? reason : trace);
        return;
    }

    if (trace !== undefined && trace !== reason) {
        this._setCarriedStackTrace(trace);
    }

    if (this._length() > 0) {
        this._queueSettlePromises();
    } else {
        this._ensurePossibleRejectionHandled();
    }
};

Promise.prototype._settlePromises = function () {
    this._unsetSettlePromisesQueued();
    var len = this._length();
    for (var i = 0; i < len; i++) {
        this._settlePromiseAt(i);
    }
};

Promise.prototype._ensurePossibleRejectionHandled = function () {
    this._setRejectionIsUnhandled();
    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
};

Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
    CapturedTrace.fireRejectionEvent("rejectionHandled",
                                  unhandledRejectionHandled, undefined, this);
};

Promise.prototype._notifyUnhandledRejection = function () {
    if (this._isRejectionUnhandled()) {
        var reason = this._getCarriedStackTrace() || this._settledValue;
        this._setUnhandledRejectionIsNotified();
        CapturedTrace.fireRejectionEvent("unhandledRejection",
                                      possiblyUnhandledRejection, reason, this);
    }
};

var contextStack = [];
function Context() {
    this._trace = new CapturedTrace(peekContext());
}
Context.prototype._pushContext = function () {
    if (!debugging) return;
    contextStack.push(this._trace);
};

Context.prototype._popContext = function () {
    if (!debugging) return;
    contextStack.pop();
};

 /*jshint unused:false*/
function createContext() {
    if (debugging) return new Context();
}

function peekContext() {
    var lastIndex = contextStack.length - 1;
    if (lastIndex >= 0) {
        return contextStack[lastIndex];
    }
    return undefined;
}

Promise.prototype._peekContext = peekContext;
Promise.prototype._pushContext = Context.prototype._pushContext;
Promise.prototype._popContext = Context.prototype._popContext;

Promise.prototype._resolveFromSyncValue = function (value) {
    if (value === errorObj) {
        this._setRejected();
        var reason = value.e;
        this._settledValue = reason;
        this._cleanValues();
        this._attachExtraTrace(reason);
        this._ensurePossibleRejectionHandled();
    } else {
        var maybePromise = tryConvertToPromise(value, this);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            this._follow(maybePromise);
        } else {
            this._setFulfilled();
            this._settledValue = value;
            this._cleanValues();
        }
    }
};



if (!CapturedTrace.isSupported()) {
    Promise.longStackTraces = function(){};
    debugging = false;
}

Promise._makeSelfResolutionError = makeSelfResolutionError;
require("./finally.js")(Promise, NEXT_FILTER, tryConvertToPromise);
require("./direct_resolve.js")(Promise);
require("./synchronous_inspection.js")(Promise);
require("./join.js")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
Promise.RangeError = RangeError;
Promise.CancellationError = CancellationError;
Promise.TimeoutError = TimeoutError;
Promise.TypeError = TypeError;
Promise.OperationalError = OperationalError;
Promise.RejectionError = OperationalError;
Promise.AggregateError = errors.AggregateError;

util.toFastProperties(Promise);
util.toFastProperties(Promise.prototype);
Promise.Promise = Promise;
CapturedTrace.setBounds(async.firstLineError, util.lastLineError);
require('./nodeify.js')(Promise);
require('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
require('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
require('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
require('./cancel.js')(Promise, INTERNAL);
require('./promisify.js')(Promise, INTERNAL);
require('./props.js')(Promise, PromiseArray, tryConvertToPromise);
require('./race.js')(Promise, INTERNAL, tryConvertToPromise);
require('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
require('./settle.js')(Promise, PromiseArray);
require('./call_get.js')(Promise);
require('./some.js')(Promise, PromiseArray, apiRejection);
require('./progress.js')(Promise, PromiseArray);
require('./any.js')(Promise);
require('./each.js')(Promise, INTERNAL);
require('./timers.js')(Promise, INTERNAL, tryConvertToPromise);
require('./filter.js')(Promise, INTERNAL);

Promise.prototype = Promise.prototype;
return Promise;

};

}).call(this,require('_process'))
},{"./any.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/any.js","./async.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/async.js","./call_get.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/call_get.js","./cancel.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/cancel.js","./captured_trace.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/captured_trace.js","./catch_filter.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/catch_filter.js","./direct_resolve.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/direct_resolve.js","./each.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/each.js","./errors.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors.js","./errors_api_rejection":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors_api_rejection.js","./filter.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/filter.js","./finally.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/finally.js","./generators.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/generators.js","./join.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/join.js","./map.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/map.js","./nodeify.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/nodeify.js","./progress.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/progress.js","./promise_array.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/promise_array.js","./promise_resolver.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/promise_resolver.js","./promisify.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/promisify.js","./props.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/props.js","./race.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/race.js","./reduce.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/reduce.js","./settle.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/settle.js","./some.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/some.js","./synchronous_inspection.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/synchronous_inspection.js","./thenables.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/thenables.js","./timers.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/timers.js","./using.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/using.js","./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js","_process":"/Users/sash/development/js/imglykit-rewrite/node_modules/browserify/node_modules/process/browser.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/promise_array.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise,
    apiRejection) {
var util = require("./util.js");
var errors = require("./errors.js");
var isArray = util.isArray;

function toResolutionValue(val) {
    switch(val) {
    case -1: return undefined;
    case -2: return [];
    case -3: return {};
    }
}

function PromiseArray(values) {
    var promise = this._promise = new Promise(INTERNAL);
    var parent;
    if (values instanceof Promise) {
        parent = values;
        promise._propagateFrom(parent, 1 | 4);
    }
    this._values = values;
    this._length = 0;
    this._totalResolved = 0;
    this._init(undefined, -2);
}
PromiseArray.prototype.length = function () {
    return this._length;
};

PromiseArray.prototype.promise = function () {
    return this._promise;
};

PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {

    var values = tryConvertToPromise(this._values, undefined);
    if (values instanceof Promise) {
        values._setBoundTo(this._promise._boundTo);
        values = values._target();
        this._values = values;
        if (values._isFulfilled()) {
            values = values._value();
            if (!isArray(values)) {
                var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
                this.__hardReject__(err);
                return;
            }
        } else if (values._isPending()) {
            values._then(
                init,
                this._reject,
                undefined,
                this,
                resolveValueIfEmpty
           );
            return;
        } else {
            values._unsetRejectionIsUnhandled();
            this._reject(values._reason());
            return;
        }
    } else if (!isArray(values)) {
        this._promise._follow(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a"));
        return;
    }

    if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
        }
        else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
    }
    var len = this.getActualLength(values.length);
    this._length = len;
    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
    var promise = this._promise;
    for (var i = 0; i < len; ++i) {
        var isResolved = this._isResolved();
        var maybePromise = tryConvertToPromise(values[i], promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            if (isResolved) {
                maybePromise._unsetRejectionIsUnhandled();
            } else if (maybePromise._isPending()) {
                maybePromise._proxyPromiseArray(this, i);
            } else if (maybePromise._isFulfilled()) {
                this._promiseFulfilled(maybePromise._value(), i);
            } else {
                maybePromise._unsetRejectionIsUnhandled();
                this._promiseRejected(maybePromise._reason(), i);
            }
        } else if (!isResolved) {
            this._promiseFulfilled(maybePromise, i);
        }
    }
};

PromiseArray.prototype._isResolved = function () {
    return this._values === null;
};

PromiseArray.prototype._resolve = function (value) {
    this._values = null;
    this._promise._fulfill(value);
};

PromiseArray.prototype.__hardReject__ =
PromiseArray.prototype._reject = function (reason) {
    this._values = null;
    var trace = errors.ensureErrorObject(reason);
    this._promise._attachExtraTrace(trace);
    this._promise._reject(reason, trace);
};

PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
    this._promise._progress({
        index: index,
        value: progressValue
    });
};


PromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
    }
};

PromiseArray.prototype._promiseRejected = function (reason, index) {
    this._totalResolved++;
    this._reject(reason);
};

PromiseArray.prototype.shouldCopyValues = function () {
    return true;
};

PromiseArray.prototype.getActualLength = function (len) {
    return len;
};

return PromiseArray;
};

},{"./errors.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors.js","./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/promise_resolver.js":[function(require,module,exports){
"use strict";
var util = require("./util.js");
var maybeWrapAsError = util.maybeWrapAsError;
var errors = require("./errors.js");
var TimeoutError = errors.TimeoutError;
var OperationalError = errors.OperationalError;
var async = require("./async.js");
var haveGetters = util.haveGetters;
var es5 = require("./es5.js");

function isUntypedError(obj) {
    return obj instanceof Error &&
        es5.getPrototypeOf(obj) === Error.prototype;
}

var rErrorKey = /^(?:name|message|stack|cause)$/;
function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
        ret.name = obj.name;
        ret.message = obj.message;
        ret.stack = obj.stack;
        var keys = es5.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!rErrorKey.test(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    errors.markAsOriginatingFromRejection(obj);
    return obj;
}

function nodebackForPromise(promise) {
    return function(err, value) {
        if (promise === null) return;

        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (arguments.length > 2) {
            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
            promise._fulfill(args);
        } else {
            promise._fulfill(value);
        }

        promise = null;
    };
}


var PromiseResolver;
if (!haveGetters) {
    PromiseResolver = function (promise) {
        this.promise = promise;
        this.asCallback = nodebackForPromise(promise);
        this.callback = this.asCallback;
    };
}
else {
    PromiseResolver = function (promise) {
        this.promise = promise;
    };
}
if (haveGetters) {
    var prop = {
        get: function() {
            return nodebackForPromise(this.promise);
        }
    };
    es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
    es5.defineProperty(PromiseResolver.prototype, "callback", prop);
}

PromiseResolver._nodebackForPromise = nodebackForPromise;

PromiseResolver.prototype.toString = function () {
    return "[object PromiseResolver]";
};

PromiseResolver.prototype.resolve =
PromiseResolver.prototype.fulfill = function (value) {
    if (!(this instanceof PromiseResolver)) {
        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
    }

    var promise = this.promise;
    if (promise._tryFollow(value)) {
        return;
    }
    async.invoke(promise._fulfill, promise, value);
};

PromiseResolver.prototype.reject = function (reason) {
    if (!(this instanceof PromiseResolver)) {
        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
    }

    var promise = this.promise;
    errors.markAsOriginatingFromRejection(reason);
    var trace = errors.ensureErrorObject(reason);
    async.invoke(promise._reject, promise, reason);
    if (trace !== reason) {
        async.invoke(this._setCarriedStackTrace, this, trace);
    }
};

PromiseResolver.prototype.progress = function (value) {
    if (!(this instanceof PromiseResolver)) {
        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
    }
    async.invoke(this.promise._progress, this.promise, value);
};

PromiseResolver.prototype.cancel = function () {
    async.invoke(this.promise.cancel, this.promise, undefined);
};

PromiseResolver.prototype.timeout = function () {
    this.reject(new TimeoutError("timeout"));
};

PromiseResolver.prototype.isResolved = function () {
    return this.promise.isResolved();
};

PromiseResolver.prototype.toJSON = function () {
    return this.promise.toJSON();
};

PromiseResolver.prototype._setCarriedStackTrace = function (trace) {
    if (this.promise.isRejected()) {
        this.promise._setCarriedStackTrace(trace);
    }
};

module.exports = PromiseResolver;

},{"./async.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/async.js","./errors.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors.js","./es5.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/es5.js","./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/promisify.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var THIS = {};
var util = require("./util.js");
var nodebackForPromise = require("./promise_resolver.js")
    ._nodebackForPromise;
var withAppended = util.withAppended;
var maybeWrapAsError = util.maybeWrapAsError;
var canEvaluate = util.canEvaluate;
var TypeError = require("./errors").TypeError;
var defaultSuffix = "Async";
var defaultFilter = function(name, func) {
    return util.isIdentifier(name) &&
        name.charAt(0) !== "_" &&
        !util.isClass(func);
};
var defaultPromisified = {__isPromisified__: true};


function escapeIdentRegex(str) {
    return str.replace(/([$])/, "\\$");
}

function isPromisified(fn) {
    try {
        return fn.__isPromisified__ === true;
    }
    catch (e) {
        return false;
    }
}

function hasPromisified(obj, key, suffix) {
    var val = util.getDataPropertyOrDefault(obj, key + suffix,
                                            defaultPromisified);
    return val ? isPromisified(val) : false;
}
function checkValid(ret, suffix, suffixRegexp) {
    for (var i = 0; i < ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (var j = 0; j < ret.length; j += 2) {
                if (ret[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
                        .replace("%s", suffix));
                }
            }
        }
    }
}

function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
    var keys = util.inheritedDataKeys(obj);
    var ret = [];
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var value = obj[key];
        var passesDefaultFilter = filter === defaultFilter
            ? true : defaultFilter(key, value, obj);
        if (typeof value === "function" &&
            !isPromisified(value) &&
            !hasPromisified(obj, key, suffix) &&
            filter(key, value, obj, passesDefaultFilter)) {
            ret.push(key, value);
        }
    }
    checkValid(ret, suffix, suffixRegexp);
    return ret;
}

function switchCaseArgumentOrder(likelyArgumentCount) {
    var ret = [likelyArgumentCount];
    var min = Math.max(0, likelyArgumentCount - 1 - 5);
    for(var i = likelyArgumentCount - 1; i >= min; --i) {
        if (i === likelyArgumentCount) continue;
        ret.push(i);
    }
    for(var i = likelyArgumentCount + 1; i <= 5; ++i) {
        ret.push(i);
    }
    return ret;
}

function argumentSequence(argumentCount) {
    return util.filledRange(argumentCount, "arguments[", "]");
}

function parameterDeclaration(parameterCount) {
    return util.filledRange(parameterCount, "_arg", "");
}

function parameterCount(fn) {
    if (typeof fn.length === "number") {
        return Math.max(Math.min(fn.length, 1023 + 1), 0);
    }
    return 0;
}

function generatePropertyAccess(key) {
    if (util.isIdentifier(key)) {
        return "." + key;
    }
    else return "['" + key.replace(/(['\\])/g, "\\$1") + "']";
}

function makeNodePromisifiedEval(callback, receiver, originalName, fn, suffix) {
    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
    var callbackName =
        (typeof originalName === "string" && util.isIdentifier(originalName)
            ? originalName + suffix
            : "promisified");

    function generateCallForArgumentCount(count) {
        var args = argumentSequence(count).join(", ");
        var comma = count > 0 ? ", " : "";
        var ret;
        if (typeof callback === "string") {
            ret = "                                                          \n\
                this.method({{args}}, fn);                                   \n\
                break;                                                       \n\
            ".replace(".method", generatePropertyAccess(callback));
        } else if (receiver === THIS) {
            ret =  "                                                         \n\
                callback.call(this, {{args}}, fn);                           \n\
                break;                                                       \n\
            ";
        } else if (receiver !== undefined) {
            ret =  "                                                         \n\
                callback.call(receiver, {{args}}, fn);                       \n\
                break;                                                       \n\
            ";
        } else {
            ret =  "                                                         \n\
                callback({{args}}, fn);                                      \n\
                break;                                                       \n\
            ";
        }
        return ret.replace("{{args}}", args).replace(", ", comma);
    }

    function generateArgumentSwitchCase() {
        var ret = "";
        for(var i = 0; i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] +":" +
                generateCallForArgumentCount(argumentOrder[i]);
        }
        var codeForCall;
        if (typeof callback === "string") {
            codeForCall = "                                                  \n\
                this.property.apply(this, args);                             \n\
            "
                .replace(".property", generatePropertyAccess(callback));
        } else if (receiver === THIS) {
            codeForCall = "                                                  \n\
                callback.apply(this, args);                                  \n\
            ";
        } else {
            codeForCall = "                                                  \n\
                callback.apply(receiver, args);                              \n\
            ";
        }

        ret += "                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i < len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = fn;                                                    \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        ".replace("[CodeForCall]", codeForCall);
        return ret;
    }

    return new Function("Promise",
                        "callback",
                        "receiver",
                        "withAppended",
                        "maybeWrapAsError",
                        "nodebackForPromise",
                        "INTERNAL","                                         \n\
        var ret = function (Parameters) {                        \n\
            'use strict';                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            promise._setIsSpreadable();                                      \n\
            var fn = nodebackForPromise(promise);                            \n\
            try {                                                            \n\
                switch(len) {                                                \n\
                    [CodeForSwitchCase]                                      \n\
                }                                                            \n\
            } catch (e) {                                                    \n\
                var wrapped = maybeWrapAsError(e);                           \n\
                promise._attachExtraTrace(wrapped);                          \n\
                promise._reject(wrapped);                                    \n\
            }                                                                \n\
            return promise;                                                  \n\
        };                                                                   \n\
        ret.__isPromisified__ = true;                                        \n\
        return ret;                                                          \n\
        "
        .replace("FunctionName", callbackName)
        .replace("Parameters", parameterDeclaration(newParameterCount))
        .replace("[CodeForSwitchCase]", generateArgumentSwitchCase()))(
            Promise,
            callback,
            receiver,
            withAppended,
            maybeWrapAsError,
            nodebackForPromise,
            INTERNAL
        );
}

function makeNodePromisifiedClosure(callback, receiver) {
    function promisified() {
        var _receiver = receiver;
        if (receiver === THIS) _receiver = this;
        if (typeof callback === "string") {
            callback = _receiver[callback];
        }
        var promise = new Promise(INTERNAL);
        promise._captureStackTrace();
        promise._setIsSpreadable();
        var fn = nodebackForPromise(promise);
        try {
            callback.apply(_receiver, withAppended(arguments, fn));
        } catch(e) {
            var wrapped = maybeWrapAsError(e);
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        }
        return promise;
    }
    promisified.__isPromisified__ = true;
    return promisified;
}

var makeNodePromisified = canEvaluate
    ? makeNodePromisifiedEval
    : makeNodePromisifiedClosure;

function promisifyAll(obj, suffix, filter, promisifier) {
    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
    var methods =
        promisifiableMethods(obj, suffix, suffixRegexp, filter);

    for (var i = 0, len = methods.length; i < len; i+= 2) {
        var key = methods[i];
        var fn = methods[i+1];
        var promisifiedKey = key + suffix;
        obj[promisifiedKey] = promisifier === makeNodePromisified
                ? makeNodePromisified(key, THIS, key, fn, suffix)
                : promisifier(fn, function() {
                    return makeNodePromisified(key, THIS, key, fn, suffix);
                });
    }
    util.toFastProperties(obj);
    return obj;
}

function promisify(callback, receiver) {
    return makeNodePromisified(callback, receiver, undefined, callback);
}

Promise.promisify = function (fn, receiver) {
    if (typeof fn !== "function") {
        throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    }
    if (isPromisified(fn)) {
        return fn;
    }
    return promisify(fn, arguments.length < 2 ? THIS : receiver);
};

Promise.promisifyAll = function (target, options) {
    if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
    }
    options = Object(options);
    var suffix = options.suffix;
    if (typeof suffix !== "string") suffix = defaultSuffix;
    var filter = options.filter;
    if (typeof filter !== "function") filter = defaultFilter;
    var promisifier = options.promisifier;
    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

    if (!util.isIdentifier(suffix)) {
        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
    }

    var keys = util.inheritedDataKeys(target, {includeHidden: true});
    for (var i = 0; i < keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== "constructor" &&
            util.isClass(value)) {
            promisifyAll(value.prototype, suffix, filter, promisifier);
            promisifyAll(value, suffix, filter, promisifier);
        }
    }

    return promisifyAll(target, suffix, filter, promisifier);
};
};


},{"./errors":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors.js","./promise_resolver.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/promise_resolver.js","./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/props.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise, PromiseArray, tryConvertToPromise) {
var util = require("./util.js");
var apiRejection = require("./errors_api_rejection")(Promise);
var isObject = util.isObject;
var es5 = require("./es5.js");

function PropertiesPromiseArray(obj) {
    var keys = es5.keys(obj);
    var len = keys.length;
    var values = new Array(len * 2);
    for (var i = 0; i < len; ++i) {
        var key = keys[i];
        values[i] = obj[key];
        values[i + len] = key;
    }
    this.constructor$(values);
}
util.inherits(PropertiesPromiseArray, PromiseArray);

PropertiesPromiseArray.prototype._init = function () {
    this._init$(undefined, -3) ;
};

PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        var val = {};
        var keyOffset = this.length();
        for (var i = 0, len = this.length(); i < len; ++i) {
            val[this._values[i + keyOffset]] = this._values[i];
        }
        this._resolve(val);
    }
};

PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
    this._promise._progress({
        key: this._values[index + this.length()],
        value: value
    });
};

PropertiesPromiseArray.prototype.shouldCopyValues = function () {
    return false;
};

PropertiesPromiseArray.prototype.getActualLength = function (len) {
    return len >> 1;
};

function props(promises) {
    var ret;
    var castValue = tryConvertToPromise(promises, undefined);

    if (!isObject(castValue)) {
        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
    } else if (castValue instanceof Promise) {
        ret = castValue._then(
            Promise.props, undefined, undefined, undefined, undefined);
    } else {
        ret = new PropertiesPromiseArray(castValue).promise();
    }

    if (castValue instanceof Promise) {
        ret._propagateFrom(castValue, 4);
    }
    return ret;
}

Promise.prototype.props = function () {
    return props(this);
};

Promise.props = function (promises) {
    return props(promises);
};
};

},{"./errors_api_rejection":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors_api_rejection.js","./es5.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/es5.js","./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/queue.js":[function(require,module,exports){
"use strict";
function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
}

Queue.prototype._willBeOverCapacity = function (size) {
    return this._capacity < size;
};

Queue.prototype._pushOne = function (arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = arg;
    this._length = length + 1;
};

Queue.prototype._unshiftOne = function(value) {
    var capacity = this._capacity;
    this._checkCapacity(this.length() + 1);
    var front = this._front;
    var i = (((( front - 1 ) &
                    ( capacity - 1) ) ^ capacity ) - capacity );
    this[i] = value;
    this._front = i;
    this._length = this.length() + 1;
};

Queue.prototype.unshift = function(fn, receiver, arg) {
    this._unshiftOne(arg);
    this._unshiftOne(receiver);
    this._unshiftOne(fn);
};

Queue.prototype.push = function (fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[(j + 0) & wrapMask] = fn;
    this[(j + 1) & wrapMask] = receiver;
    this[(j + 2) & wrapMask] = arg;
    this._length = length;
};

Queue.prototype.shift = function () {
    var front = this._front,
        ret = this[front];

    this[front] = undefined;
    this._front = (front + 1) & (this._capacity - 1);
    this._length--;
    return ret;
};

Queue.prototype.length = function () {
    return this._length;
};

Queue.prototype._checkCapacity = function (size) {
    if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
    }
};

Queue.prototype._resizeTo = function (capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    if (front + length > oldCapacity) {
        var moveItemsCount = (front + length) & (oldCapacity - 1);
        arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    }
};

module.exports = Queue;

},{}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/race.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
var apiRejection = require("./errors_api_rejection.js")(Promise);
var isArray = require("./util.js").isArray;

var raceLater = function (promise) {
    return promise.then(function(array) {
        return race(array, promise);
    });
};

function race(promises, parent) {
    var maybePromise = tryConvertToPromise(promises, undefined);

    if (maybePromise instanceof Promise) {
        return raceLater(maybePromise);
    } else if (!isArray(promises)) {
        return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
    }

    var ret = new Promise(INTERNAL);
    if (parent !== undefined) {
        ret._propagateFrom(parent, 4 | 1);
    }
    var fulfill = ret._fulfill;
    var reject = ret._reject;
    for (var i = 0, len = promises.length; i < len; ++i) {
        var val = promises[i];

        if (val === undefined && !(i in promises)) {
            continue;
        }

        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
    }
    return ret;
}

Promise.race = function (promises) {
    return race(promises, undefined);
};

Promise.prototype.race = function () {
    return race(this, undefined);
};

};

},{"./errors_api_rejection.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors_api_rejection.js","./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/reduce.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL) {
var util = require("./util.js");
var tryCatch4 = util.tryCatch4;
var tryCatch3 = util.tryCatch3;
var errorObj = util.errorObj;
function ReductionPromiseArray(promises, fn, accum, _each) {
    this.constructor$(promises);
    this._promise._captureStackTrace();
    this._preservedValues = _each === INTERNAL ? [] : null;
    this._zerothIsAccum = (accum === undefined);
    this._gotAccum = false;
    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
    this._valuesPhase = undefined;

    var maybePromise = tryConvertToPromise(accum, undefined);
    var rejected = false;
    var isPromise = maybePromise instanceof Promise;
    if (isPromise) {
        maybePromise = maybePromise._target();
        if (maybePromise._isPending()) {
            maybePromise._proxyPromiseArray(this, -1);
        } else if (maybePromise._isFulfilled()) {
            accum = maybePromise._value();
            this._gotAccum = true;
        } else {
            maybePromise._unsetRejectionIsUnhandled();
            this._reject(maybePromise._reason());
            rejected = true;
        }
    }
    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
    this._callback = fn;
    this._accum = accum;
    if (!rejected) this._init$(undefined, -5);
}
util.inherits(ReductionPromiseArray, PromiseArray);

ReductionPromiseArray.prototype._init = function () {};

ReductionPromiseArray.prototype._resolveEmptyArray = function () {
    if (this._gotAccum || this._zerothIsAccum) {
        this._resolve(this._preservedValues !== null
                        ? [] : this._accum);
    }
};

ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var values = this._values;
    values[index] = value;
    var length = this.length();
    var preservedValues = this._preservedValues;
    var isEach = preservedValues !== null;
    var gotAccum = this._gotAccum;
    var valuesPhase = this._valuesPhase;
    var valuesPhaseIndex;
    if (!valuesPhase) {
        valuesPhase = this._valuesPhase = Array(length);
        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
            valuesPhase[valuesPhaseIndex] = 0;
        }
    }
    valuesPhaseIndex = valuesPhase[index];

    if (index === 0 && this._zerothIsAccum) {
        if (!gotAccum) {
            this._accum = value;
            this._gotAccum = gotAccum = true;
        }
        valuesPhase[index] = ((valuesPhaseIndex === 0)
            ? 1 : 2);
    } else if (index === -1) {
        if (!gotAccum) {
            this._accum = value;
            this._gotAccum = gotAccum = true;
        }
    } else {
        if (valuesPhaseIndex === 0) {
            valuesPhase[index] = 1;
        }
        else {
            valuesPhase[index] = 2;
            if (gotAccum) {
                this._accum = value;
            }
        }
    }
    if (!gotAccum) return;

    var callback = this._callback;
    var receiver = this._promise._boundTo;
    var ret;

    for (var i = this._reducingIndex; i < length; ++i) {
        valuesPhaseIndex = valuesPhase[i];
        if (valuesPhaseIndex === 2) {
            this._reducingIndex = i + 1;
            continue;
        }
        if (valuesPhaseIndex !== 1) return;
        value = values[i];
        if (value instanceof Promise) {
            value = value._target();
            if (value._isFulfilled()) {
                value = value._value();
            } else if (value._isPending()) {
                return;
            } else {
                value._unsetRejectionIsUnhandled();
                return this._reject(value._reason());
            }
        }

        this._promise._pushContext();
        if (isEach) {
            preservedValues.push(value);
            ret = tryCatch3(callback, receiver, value, i, length);
        }
        else {
            ret = tryCatch4(callback, receiver, this._accum, value, i, length);
        }
        this._promise._popContext();

        if (ret === errorObj) return this._reject(ret.e);

        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            if (maybePromise._isPending()) {
                valuesPhase[i] = 4;
                return maybePromise._proxyPromiseArray(this, i);
            } else if (maybePromise._isFulfilled()) {
                ret = maybePromise._value();
            } else {
                maybePromise._unsetRejectionIsUnhandled();
                return this._reject(maybePromise._reason());
            }
        }

        this._reducingIndex = i + 1;
        this._accum = ret;
    }

    if (this._reducingIndex < length) return;
    this._resolve(isEach ? preservedValues : this._accum);
};

function reduce(promises, fn, initialValue, _each) {
    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
    return array.promise();
}

Promise.prototype.reduce = function (fn, initialValue) {
    return reduce(this, fn, initialValue, null);
};

Promise.reduce = function (promises, fn, initialValue, _each) {
    return reduce(promises, fn, initialValue, _each);
};
};

},{"./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/schedule.js":[function(require,module,exports){
(function (process){
"use strict";
var schedule;
if (typeof process === "object" && typeof process.version === "string") {
    schedule = parseInt(process.version.split(".")[1], 10) > 10
        ? setImmediate : process.nextTick;
}
else if (typeof MutationObserver !== "undefined") {
    schedule = function(fn) {
        var div = document.createElement("div");
        var observer = new MutationObserver(fn);
        observer.observe(div, {attributes: true});
        return function() { div.classList.toggle("foo"); };
    };
    schedule.isStatic = true;
}
else if (typeof setTimeout !== "undefined") {
    schedule = function (fn) {
        setTimeout(fn, 0);
    };
}
else {
    schedule = function() {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
    };
}
module.exports = schedule;

}).call(this,require('_process'))
},{"_process":"/Users/sash/development/js/imglykit-rewrite/node_modules/browserify/node_modules/process/browser.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/settle.js":[function(require,module,exports){
"use strict";
module.exports =
    function(Promise, PromiseArray) {
var PromiseInspection = Promise.PromiseInspection;
var util = require("./util.js");

function SettledPromiseArray(values) {
    this.constructor$(values);
    this._promise._setIsSpreadable();
}
util.inherits(SettledPromiseArray, PromiseArray);

SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
    this._values[index] = inspection;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
    }
};

SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var ret = new PromiseInspection();
    ret._bitField = 268435456;
    ret._settledValue = value;
    this._promiseResolved(index, ret);
};
SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
    var ret = new PromiseInspection();
    ret._bitField = 134217728;
    ret._settledValue = reason;
    this._promiseResolved(index, ret);
};

Promise.settle = function (promises) {
    return new SettledPromiseArray(promises).promise();
};

Promise.prototype.settle = function () {
    return new SettledPromiseArray(this).promise();
};
};

},{"./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/some.js":[function(require,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, apiRejection) {
var util = require("./util.js");
var RangeError = require("./errors.js").RangeError;
var AggregateError = require("./errors.js").AggregateError;
var isArray = util.isArray;


function SomePromiseArray(values) {
    this.constructor$(values);
    this._howMany = 0;
    this._unwrap = false;
    this._initialized = false;
}
util.inherits(SomePromiseArray, PromiseArray);

SomePromiseArray.prototype._init = function () {
    if (!this._initialized) {
        return;
    }
    this._promise._setIsSpreadable();
    if (this._howMany === 0) {
        this._resolve([]);
        return;
    }
    this._init$(undefined, -5);
    var isArrayResolved = isArray(this._values);
    if (!this._isResolved() &&
        isArrayResolved &&
        this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
    }
};

SomePromiseArray.prototype.init = function () {
    this._initialized = true;
    this._init();
};

SomePromiseArray.prototype.setUnwrap = function () {
    this._unwrap = true;
};

SomePromiseArray.prototype.howMany = function () {
    return this._howMany;
};

SomePromiseArray.prototype.setHowMany = function (count) {
    if (this._isResolved()) return;
    this._howMany = count;
};

SomePromiseArray.prototype._promiseFulfilled = function (value) {
    this._addFulfilled(value);
    if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
            this._resolve(this._values[0]);
        } else {
            this._resolve(this._values);
        }
    }

};
SomePromiseArray.prototype._promiseRejected = function (reason) {
    this._addRejected(reason);
    if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError();
        for (var i = this.length(); i < this._values.length; ++i) {
            e.push(this._values[i]);
        }
        this._reject(e);
    }
};

SomePromiseArray.prototype._fulfilled = function () {
    return this._totalResolved;
};

SomePromiseArray.prototype._rejected = function () {
    return this._values.length - this.length();
};

SomePromiseArray.prototype._addRejected = function (reason) {
    this._values.push(reason);
};

SomePromiseArray.prototype._addFulfilled = function (value) {
    this._values[this._totalResolved++] = value;
};

SomePromiseArray.prototype._canPossiblyFulfill = function () {
    return this.length() - this._rejected();
};

SomePromiseArray.prototype._getRangeError = function (count) {
    var message = "Input array must contain at least " +
            this._howMany + " items but contains only " + count + " items";
    return new RangeError(message);
};

SomePromiseArray.prototype._resolveEmptyArray = function () {
    this._reject(this._getRangeError(0));
};

function some(promises, howMany) {
    if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
    }
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    if (promise.isRejected()) {
        return promise;
    }
    ret.setHowMany(howMany);
    ret.init();
    return promise;
}

Promise.some = function (promises, howMany) {
    return some(promises, howMany);
};

Promise.prototype.some = function (howMany) {
    return some(this, howMany);
};

Promise._SomePromiseArray = SomePromiseArray;
};

},{"./errors.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors.js","./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/synchronous_inspection.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise) {
function PromiseInspection(promise) {
    if (promise !== undefined) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValue = promise._isResolved()
            ? promise._settledValue
            : undefined;
    }
    else {
        this._bitField = 0;
        this._settledValue = undefined;
    }
}

PromiseInspection.prototype.value = function () {
    if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
    }
    return this._settledValue;
};

PromiseInspection.prototype.error =
PromiseInspection.prototype.reason = function () {
    if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
    }
    return this._settledValue;
};

PromiseInspection.prototype.isFulfilled =
Promise.prototype._isFulfilled = function () {
    return (this._bitField & 268435456) > 0;
};

PromiseInspection.prototype.isRejected =
Promise.prototype._isRejected = function () {
    return (this._bitField & 134217728) > 0;
};

PromiseInspection.prototype.isPending =
Promise.prototype._isPending = function () {
    return (this._bitField & 402653184) === 0;
};

PromiseInspection.prototype.isResolved =
Promise.prototype._isResolved = function () {
    return (this._bitField & 402653184) > 0;
};

Promise.prototype.isPending = function() {
    return this._target()._isPending();
};

Promise.prototype.isRejected = function() {
    return this._target()._isRejected();
};

Promise.prototype.isFulfilled = function() {
    return this._target()._isFulfilled();
};

Promise.prototype.isResolved = function() {
    return this._target()._isResolved();
};

Promise.prototype._value = function() {
    return this._settledValue;
};

Promise.prototype._reason = function() {
    return this._settledValue;
};

Promise.prototype.value = function() {
    var target = this._target();
    if (!target.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
    }
    return target._settledValue;
};

Promise.prototype.reason = function() {
    var target = this._target();
    if (!target.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
    }
    return target._settledValue;
};


Promise.PromiseInspection = PromiseInspection;
};

},{}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/thenables.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var util = require("./util.js");
var canAttachTrace = require("./errors.js").canAttachTrace;
var errorObj = util.errorObj;
var isObject = util.isObject;

function getThen(obj) {
    try {
        return obj.then;
    }
    catch(e) {
        errorObj.e = e;
        return errorObj;
    }
}

function tryConvertToPromise(obj, traceParent) {
    if (isObject(obj)) {
        if (obj instanceof Promise) {
            return obj;
        }
        else if (isAnyBluebirdPromise(obj)) {
            var ret = new Promise(INTERNAL);
            obj._then(
                ret._fulfillUnchecked,
                ret._rejectUncheckedCheckError,
                ret._progressUnchecked,
                ret,
                null
            );
            return ret;
        }
        var then = getThen(obj);
        if (then === errorObj) {
            if (traceParent !== undefined && canAttachTrace(then.e)) {
                traceParent._attachExtraTrace(then.e);
            }
            return Promise.reject(then.e);
        } else if (typeof then === "function") {
            return doThenable(obj, then, traceParent);
        }
    }
    return obj;
}

var hasProp = {}.hasOwnProperty;
function isAnyBluebirdPromise(obj) {
    return hasProp.call(obj, "_promise0");
}

function doThenable(x, then, traceParent) {
    var resolver = Promise.defer();
    var called = false;
    try {
        then.call(
            x,
            resolveFromThenable,
            rejectFromThenable,
            progressFromThenable
        );
    } catch(e) {
        if (!called) {
            called = true;
            var trace = canAttachTrace(e) ? e : new Error(util.toString(e));
            if (traceParent !== undefined) {
                traceParent._attachExtraTrace(trace);
            }
            resolver.promise._reject(e, trace);
        }
    }
    return resolver.promise;

    function resolveFromThenable(y) {
        if (called) return;
        called = true;

        if (x === y) {
            var e = Promise._makeSelfResolutionError();
            if (traceParent !== undefined) {
                traceParent._attachExtraTrace(e);
            }
            resolver.promise._reject(e, undefined);
            return;
        }
        resolver.resolve(y);
    }

    function rejectFromThenable(r) {
        if (called) return;
        called = true;
        var trace = canAttachTrace(r) ? r : new Error(util.toString(r));
        if (traceParent !== undefined) {
            traceParent._attachExtraTrace(trace);
        }
        resolver.promise._reject(r, trace);
    }

    function progressFromThenable(v) {
        if (called) return;
        var promise = resolver.promise;
        if (typeof promise._progress === "function") {
            promise._progress(v);
        }
    }
}

return tryConvertToPromise;
};

},{"./errors.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors.js","./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/timers.js":[function(require,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
var errors = require("./errors.js");
var TimeoutError = Promise.TimeoutError;

var afterTimeout = function (promise, message) {
    if (!promise.isPending()) return;
    if (typeof message !== "string") {
        message = "operation timed out";
    }
    var err = new TimeoutError(message);
    errors.markAsOriginatingFromRejection(err);
    promise._attachExtraTrace(err);
    promise._cancel(err);
};

var afterDelay = function (value, promise) {
    promise._fulfill(value);
};

var delay = Promise.delay = function (value, ms) {
    if (ms === undefined) {
        ms = value;
        value = undefined;
    }
    ms = +ms;
    var maybePromise = tryConvertToPromise(value, undefined);
    var promise = new Promise(INTERNAL);

    if (maybePromise instanceof Promise) {
        promise._propagateFrom(maybePromise, 4 | 1);
        promise._follow(maybePromise._target());
        return promise.then(function(value) {
            return Promise.delay(value, ms);
        });
    } else {
        setTimeout(function delayTimeout() {
            afterDelay(value, promise);
        }, ms);
    }
    return promise;
};

Promise.prototype.delay = function (ms) {
    return delay(this, ms);
};

function successClear(value) {
    var handle = this;
    if (handle instanceof Number) handle = +handle;
    clearTimeout(handle);
    return value;
}

function failureClear(reason) {
    var handle = this;
    if (handle instanceof Number) handle = +handle;
    clearTimeout(handle);
    throw reason;
}

Promise.prototype.timeout = function (ms, message) {
    var target = this._target();
    ms = +ms;
    var ret = new Promise(INTERNAL).cancellable();
    ret._propagateFrom(this, 4 | 1);
    ret._follow(target);
    var handle = setTimeout(function timeoutTimeout() {
        afterTimeout(ret, message);
    }, ms);
    return ret._then(successClear, failureClear, undefined, handle, undefined);
};

};

},{"./errors.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/using.js":[function(require,module,exports){
"use strict";
module.exports = function (Promise, apiRejection, tryConvertToPromise,
    createContext) {
    var TypeError = require("./errors.js").TypeError;
    var inherits = require("./util.js").inherits;
    var PromiseInspection = Promise.PromiseInspection;

    function inspectionMapper(inspections) {
        var len = inspections.length;
        for (var i = 0; i < len; ++i) {
            var inspection = inspections[i];
            if (inspection.isRejected()) {
                return Promise.reject(inspection.error());
            }
            inspections[i] = inspection._settledValue;
        }
        return inspections;
    }

    function thrower(e) {
        setTimeout(function(){throw e;}, 0);
    }

    function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable, undefined);
        if (maybePromise !== thenable &&
            typeof thenable._isDisposable === "function" &&
            typeof thenable._getDisposer === "function" &&
            thenable._isDisposable()) {
            maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
    }
    function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret = Promise.defer();
        function iterator() {
            if (i >= len) return ret.resolve();
            var maybePromise = castPreservingDisposable(resources[i++]);
            if (maybePromise instanceof Promise &&
                maybePromise._isDisposable()) {
                try {
                    maybePromise = tryConvertToPromise(
                        maybePromise._getDisposer().tryDispose(inspection),
                        undefined);
                } catch (e) {
                    return thrower(e);
                }
                if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower,
                                              null, null, null);
                }
            }
            iterator();
        }
        iterator();
        return ret.promise;
    }

    function disposerSuccess(value) {
        var inspection = new PromiseInspection();
        inspection._settledValue = value;
        inspection._bitField = 268435456;
        return dispose(this, inspection).thenReturn(value);
    }

    function disposerFail(reason) {
        var inspection = new PromiseInspection();
        inspection._settledValue = reason;
        inspection._bitField = 134217728;
        return dispose(this, inspection).thenThrow(reason);
    }

    function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
    }

    Disposer.prototype.data = function () {
        return this._data;
    };

    Disposer.prototype.promise = function () {
        return this._promise;
    };

    Disposer.prototype.resource = function () {
        if (this.promise().isFulfilled()) {
            return this.promise().value();
        }
        return null;
    };

    Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== undefined) context._pushContext();
        var ret = resource !== null
            ? this.doDispose(resource, inspection) : null;
        if (context !== undefined) context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret;
    };

    Disposer.isDisposer = function (d) {
        return (d != null &&
                typeof d.resource === "function" &&
                typeof d.tryDispose === "function");
    };

    function FunctionDisposer(fn, promise) {
        this.constructor$(fn, promise);
    }
    inherits(FunctionDisposer, Disposer);

    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
    };

    function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
            this.resources[this.index]._setDisposable(value);
            return value.promise();
        }
        return value;
    }

    Promise.using = function () {
        var len = arguments.length;
        if (len < 2) return apiRejection(
                        "you must pass at least 2 arguments to Promise.using");
        var fn = arguments[len - 1];
        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        len--;
        var resources = new Array(len);
        for (var i = 0; i < len; ++i) {
            var resource = arguments[i];
            if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
            } else {
                var maybePromise = tryConvertToPromise(resource, undefined);
                if (maybePromise instanceof Promise) {
                    resource =
                        maybePromise._then(maybeUnwrapDisposer, null, null, {
                            resources: resources,
                            index: i
                    }, undefined);
                }
            }
            resources[i] = resource;
        }

        var promise = Promise.settle(resources)
            .then(inspectionMapper)
            .then(function(vals) {
                promise._pushContext();
                var ret;
                try {
                    ret = fn.apply(undefined, vals);
                } finally {
                    promise._popContext();
                }
                return ret;
            })
            ._then(
                disposerSuccess, disposerFail, undefined, resources, undefined);
        return promise;
    };

    Promise.prototype._setDisposable = function (disposer) {
        this._bitField = this._bitField | 262144;
        this._disposer = disposer;
    };

    Promise.prototype._isDisposable = function () {
        return (this._bitField & 262144) > 0;
    };

    Promise.prototype._getDisposer = function () {
        return this._disposer;
    };

    Promise.prototype._unsetDisposable = function () {
        this._bitField = this._bitField & (~262144);
        this._disposer = undefined;
    };

    Promise.prototype.disposer = function (fn) {
        if (typeof fn === "function") {
            return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError();
    };

};

},{"./errors.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/errors.js","./util.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/util.js":[function(require,module,exports){
"use strict";
var es5 = require("./es5.js");
var haveGetters = (function(){
    try {
        var o = {};
        es5.defineProperty(o, "f", {
            get: function () {
                return 3;
            }
        });
        return o.f === 3;
    }
    catch (e) {
        return false;
    }

})();
var canEvaluate = typeof navigator == "undefined";
var errorObj = {e: {}};
function tryCatch0(fn, receiver) {
    try { return fn.call(receiver); }
    catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

function tryCatch1(fn, receiver, arg) {
    try { return fn.call(receiver, arg); }
    catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

function tryCatch2(fn, receiver, arg, arg2) {
    try { return fn.call(receiver, arg, arg2); }
    catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

function tryCatch3(fn, receiver, arg, arg2, arg3) {
    try { return fn.call(receiver, arg, arg2, arg3); }
    catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

function tryCatch4(fn, receiver, arg, arg2, arg3, arg4) {
    try { return fn.call(receiver, arg, arg2, arg3, arg4); }
    catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

function tryCatchApply(fn, args, receiver) {
    try { return fn.apply(receiver, args); }
    catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;

    function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) &&
                propertyName.charAt(propertyName.length-1) !== "$"
           ) {
                this[propertyName + "$"] = Parent.prototype[propertyName];
            }
        }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};

function asString(val) {
    return typeof val === "string" ? val : ("" + val);
}

function isPrimitive(val) {
    return val == null || val === true || val === false ||
        typeof val === "string" || typeof val === "number";

}

function isObject(value) {
    return !isPrimitive(value);
}

function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(asString(maybeError));
}

function withAppended(target, appendee) {
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
        ret[i] = target[i];
    }
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc != null) {
            return desc.get == null && desc.set == null
                    ? desc.value
                    : defaultValue;
        }
    } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
    }
}

function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
}


var wrapsPrimitiveReceiver = (function() {
    return this !== "string";
}).call("string");

function thrower(r) {
    throw r;
}

var inheritedDataKeys = (function() {
    if (es5.isES5) {
        return function(obj, opts) {
            var ret = [];
            var visitedKeys = Object.create(null);
            var getKeys = Object(opts).includeHidden
                ? Object.getOwnPropertyNames
                : Object.keys;
            while (obj != null) {
                var keys;
                try {
                    keys = getKeys(obj);
                } catch (e) {
                    return ret;
                }
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                        ret.push(key);
                    }
                }
                obj = es5.getPrototypeOf(obj);
            }
            return ret;
        };
    } else {
        return function(obj) {
            var ret = [];
            /*jshint forin:false */
            for (var key in obj) {
                ret.push(key);
            }
            return ret;
        };
    }

})();

function isClass(fn) {
    try {
        if (typeof fn === "function") {
            var keys = es5.keys(fn.prototype);
            return keys.length > 0 &&
                   !(keys.length === 1 && keys[0] === "constructor");
        }
        return false;
    } catch (e) {
        return false;
    }
}

function toFastProperties(obj) {
    /*jshint -W027*/
    function f() {}
    f.prototype = obj;
    return f;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}

function filledRange(count, prefix, suffix) {
    var ret = new Array(count);
    for(var i = 0; i < count; ++i) {
        ret[i] = prefix + i + suffix;
    }
    return ret;
}

function safeToString(obj) {
    try {
        return obj + "";
    } catch (e) {
        return "[no string representation]";
    }
}

var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    haveGetters: haveGetters,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch0: tryCatch0,
    tryCatch1: tryCatch1,
    tryCatch2: tryCatch2,
    tryCatch3: tryCatch3,
    tryCatch4: tryCatch4,
    tryCatchApply: tryCatchApply,
    inherits: inherits,
    withAppended: withAppended,
    asString: asString,
    maybeWrapAsError: maybeWrapAsError,
    wrapsPrimitiveReceiver: wrapsPrimitiveReceiver,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString
};
try {throw new Error(); } catch (e) {ret.lastLineError = e;}
module.exports = ret;

},{"./es5.js":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/es5.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/browserify/lib/_empty.js":[function(require,module,exports){

},{}],"/Users/sash/development/js/imglykit-rewrite/node_modules/browserify/node_modules/path-browserify/index.js":[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":"/Users/sash/development/js/imglykit-rewrite/node_modules/browserify/node_modules/process/browser.js"}],"/Users/sash/development/js/imglykit-rewrite/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canMutationObserver = typeof window !== 'undefined'
    && window.MutationObserver;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    var queue = [];

    if (canMutationObserver) {
        var hiddenDiv = document.createElement("div");
        var observer = new MutationObserver(function () {
            var queueList = queue.slice();
            queue.length = 0;
            queueList.forEach(function (fn) {
                fn();
            });
        });

        observer.observe(hiddenDiv, { attributes: true });

        return function nextTick(fn) {
            if (!queue.length) {
                hiddenDiv.setAttribute('yes', 'no');
            }
            queue.push(fn);
        };
    }

    if (canPost) {
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],"/Users/sash/development/js/imglykit-rewrite/node_modules/dot/doT.js":[function(require,module,exports){
// doT.js
// 2011-2014, Laura Doktorova, https://github.com/olado/doT
// Licensed under the MIT license.

(function() {
	"use strict";

	var doT = {
		version: "1.0.3",
		templateSettings: {
			evaluate:    /\{\{([\s\S]+?(\}?)+)\}\}/g,
			interpolate: /\{\{=([\s\S]+?)\}\}/g,
			encode:      /\{\{!([\s\S]+?)\}\}/g,
			use:         /\{\{#([\s\S]+?)\}\}/g,
			useParams:   /(^|[^\w$])def(?:\.|\[[\'\"])([\w$\.]+)(?:[\'\"]\])?\s*\:\s*([\w$\.]+|\"[^\"]+\"|\'[^\']+\'|\{[^\}]+\})/g,
			define:      /\{\{##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\}\}/g,
			defineParams:/^\s*([\w$]+):([\s\S]+)/,
			conditional: /\{\{\?(\?)?\s*([\s\S]*?)\s*\}\}/g,
			iterate:     /\{\{~\s*(?:\}\}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g,
			varname:	"it",
			strip:		true,
			append:		true,
			selfcontained: false,
			doNotSkipEncoded: false
		},
		template: undefined, //fn, compile template
		compile:  undefined  //fn, for express
	}, _globals;

	doT.encodeHTMLSource = function(doNotSkipEncoded) {
		var encodeHTMLRules = { "&": "&#38;", "<": "&#60;", ">": "&#62;", '"': "&#34;", "'": "&#39;", "/": "&#47;" },
			matchHTML = doNotSkipEncoded ? /[&<>"'\/]/g : /&(?!#?\w+;)|<|>|"|'|\//g;
		return function(code) {
			return code ? code.toString().replace(matchHTML, function(m) {return encodeHTMLRules[m] || m;}) : "";
		};
	};

	_globals = (function(){ return this || (0,eval)("this"); }());

	if (typeof module !== "undefined" && module.exports) {
		module.exports = doT;
	} else if (typeof define === "function" && define.amd) {
		define(function(){return doT;});
	} else {
		_globals.doT = doT;
	}

	var startend = {
		append: { start: "'+(",      end: ")+'",      startencode: "'+encodeHTML(" },
		split:  { start: "';out+=(", end: ");out+='", startencode: "';out+=encodeHTML(" }
	}, skip = /$^/;

	function resolveDefs(c, block, def) {
		return ((typeof block === "string") ? block : block.toString())
		.replace(c.define || skip, function(m, code, assign, value) {
			if (code.indexOf("def.") === 0) {
				code = code.substring(4);
			}
			if (!(code in def)) {
				if (assign === ":") {
					if (c.defineParams) value.replace(c.defineParams, function(m, param, v) {
						def[code] = {arg: param, text: v};
					});
					if (!(code in def)) def[code]= value;
				} else {
					new Function("def", "def['"+code+"']=" + value)(def);
				}
			}
			return "";
		})
		.replace(c.use || skip, function(m, code) {
			if (c.useParams) code = code.replace(c.useParams, function(m, s, d, param) {
				if (def[d] && def[d].arg && param) {
					var rw = (d+":"+param).replace(/'|\\/g, "_");
					def.__exp = def.__exp || {};
					def.__exp[rw] = def[d].text.replace(new RegExp("(^|[^\\w$])" + def[d].arg + "([^\\w$])", "g"), "$1" + param + "$2");
					return s + "def.__exp['"+rw+"']";
				}
			});
			var v = new Function("def", "return " + code)(def);
			return v ? resolveDefs(c, v, def) : v;
		});
	}

	function unescape(code) {
		return code.replace(/\\('|\\)/g, "$1").replace(/[\r\t\n]/g, " ");
	}

	doT.template = function(tmpl, c, def) {
		c = c || doT.templateSettings;
		var cse = c.append ? startend.append : startend.split, needhtmlencode, sid = 0, indv,
			str  = (c.use || c.define) ? resolveDefs(c, tmpl, def || {}) : tmpl;

		str = ("var out='" + (c.strip ? str.replace(/(^|\r|\n)\t* +| +\t*(\r|\n|$)/g," ")
					.replace(/\r|\n|\t|\/\*[\s\S]*?\*\//g,""): str)
			.replace(/'|\\/g, "\\$&")
			.replace(c.interpolate || skip, function(m, code) {
				return cse.start + unescape(code) + cse.end;
			})
			.replace(c.encode || skip, function(m, code) {
				needhtmlencode = true;
				return cse.startencode + unescape(code) + cse.end;
			})
			.replace(c.conditional || skip, function(m, elsecase, code) {
				return elsecase ?
					(code ? "';}else if(" + unescape(code) + "){out+='" : "';}else{out+='") :
					(code ? "';if(" + unescape(code) + "){out+='" : "';}out+='");
			})
			.replace(c.iterate || skip, function(m, iterate, vname, iname) {
				if (!iterate) return "';} } out+='";
				sid+=1; indv=iname || "i"+sid; iterate=unescape(iterate);
				return "';var arr"+sid+"="+iterate+";if(arr"+sid+"){var "+vname+","+indv+"=-1,l"+sid+"=arr"+sid+".length-1;while("+indv+"<l"+sid+"){"
					+vname+"=arr"+sid+"["+indv+"+=1];out+='";
			})
			.replace(c.evaluate || skip, function(m, code) {
				return "';" + unescape(code) + "out+='";
			})
			+ "';return out;")
			.replace(/\n/g, "\\n").replace(/\t/g, '\\t').replace(/\r/g, "\\r")
			.replace(/(\s|;|\}|^|\{)out\+='';/g, '$1').replace(/\+''/g, "");
			//.replace(/(\s|;|\}|^|\{)out\+=''\+/g,'$1out+=');

		if (needhtmlencode) {
			if (!c.selfcontained && _globals && !_globals._encodeHTML) _globals._encodeHTML = doT.encodeHTMLSource(c.doNotSkipEncoded);
			str = "var encodeHTML = typeof _encodeHTML !== 'undefined' ? _encodeHTML : ("
				+ doT.encodeHTMLSource.toString() + "(" + (c.doNotSkipEncoded || '') + "));"
				+ str;
		}
		try {
			return new Function(c.varname, str);
		} catch (e) {
			if (typeof console !== "undefined") console.log("Could not create a template function: " + str);
			throw e;
		}
	};

	doT.compile = function(tmpl, def) {
		return doT.template(tmpl, null, def);
	};
}());

},{}],"/Users/sash/development/js/imglykit-rewrite/node_modules/dot/index.js":[function(require,module,exports){
/* doT + auto-compilation of doT templates
 *
 * 2012, Laura Doktorova, https://github.com/olado/doT
 * Licensed under the MIT license
 *
 * Compiles .def, .dot, .jst files found under the specified path.
 * It ignores sub-directories.
 * Template files can have multiple extensions at the same time.
 * Files with .def extension can be included in other files via {{#def.name}}
 * Files with .dot extension are compiled into functions with the same name and
 * can be accessed as renderer.filename
 * Files with .jst extension are compiled into .js files. Produced .js file can be
 * loaded as a commonJS, AMD module, or just installed into a global variable
 * (default is set to window.render).
 * All inline defines defined in the .jst file are
 * compiled into separate functions and are available via _render.filename.definename
 *
 * Basic usage:
 * var dots = require("dot").process({path: "./views"});
 * dots.mytemplate({foo:"hello world"});
 *
 * The above snippet will:
 * 1. Compile all templates in views folder (.dot, .def, .jst)
 * 2. Place .js files compiled from .jst templates into the same folder.
 *    These files can be used with require, i.e. require("./views/mytemplate").
 * 3. Return an object with functions compiled from .dot templates as its properties.
 * 4. Render mytemplate template.
 */

var fs = require("fs"),
	doT = module.exports = require("./doT");

doT.process = function(options) {
	//path, destination, global, rendermodule, templateSettings
	return new InstallDots(options).compileAll();
};

function InstallDots(o) {
	this.__path 		= o.path || "./";
	if (this.__path[this.__path.length-1] !== '/') this.__path += '/';
	this.__destination	= o.destination || this.__path;
	if (this.__destination[this.__destination.length-1] !== '/') this.__destination += '/';
	this.__global		= o.global || "window.render";
	this.__rendermodule	= o.rendermodule || {};
	this.__settings 	= o.templateSettings ? copy(o.templateSettings, copy(doT.templateSettings)) : undefined;
	this.__includes		= {};
}

InstallDots.prototype.compileToFile = function(path, template, def) {
	def = def || {};
	var modulename = path.substring(path.lastIndexOf("/")+1, path.lastIndexOf("."))
		, defs = copy(this.__includes, copy(def))
		, settings = this.__settings || doT.templateSettings
		, compileoptions = copy(settings)
		, defaultcompiled = doT.template(template, settings, defs)
		, exports = []
		, compiled = ""
		, fn;

	for (var property in defs) {
		if (defs[property] !== def[property] && defs[property] !== this.__includes[property]) {
			fn = undefined;
			if (typeof defs[property] === 'string') {
				fn = doT.template(defs[property], settings, defs);
			} else if (typeof defs[property] === 'function') {
				fn = defs[property];
			} else if (defs[property].arg) {
				compileoptions.varname = defs[property].arg;
				fn = doT.template(defs[property].text, compileoptions, defs);
			}
			if (fn) {
				compiled += fn.toString().replace('anonymous', property);
				exports.push(property);
			}
		}
	}
	compiled += defaultcompiled.toString().replace('anonymous', modulename);
	fs.writeFileSync(path, "(function(){" + compiled
		+ "var itself=" + modulename + ", _encodeHTML=(" + doT.encodeHTMLSource.toString() + "(" + (settings.doNotSkipEncoded || '') + "));"
		+ addexports(exports)
		+ "if(typeof module!=='undefined' && module.exports) module.exports=itself;else if(typeof define==='function')define(function(){return itself;});else {"
		+ this.__global + "=" + this.__global + "||{};" + this.__global + "['" + modulename + "']=itself;}}());");
};

function addexports(exports) {
	for (var ret ='', i=0; i< exports.length; i++) {
		ret += "itself." + exports[i]+ "=" + exports[i]+";";
	}
	return ret;
}

function copy(o, to) {
	to = to || {};
	for (var property in o) {
		to[property] = o[property];
	}
	return to;
}

function readdata(path) {
	var data = fs.readFileSync(path);
	if (data) return data.toString();
	console.log("problems with " + path);
}

InstallDots.prototype.compilePath = function(path) {
	var data = readdata(path);
	if (data) {
		return doT.template(data,
					this.__settings || doT.templateSettings,
					copy(this.__includes));
	}
};

InstallDots.prototype.compileAll = function() {
	console.log("Compiling all doT templates...");

	var defFolder = this.__path,
		sources = fs.readdirSync(defFolder),
		k, l, name;

	for( k = 0, l = sources.length; k < l; k++) {
		name = sources[k];
		if (/\.def(\.dot|\.jst)?$/.test(name)) {
			console.log("Loaded def " + name);
			this.__includes[name.substring(0, name.indexOf('.'))] = readdata(defFolder + name);
		}
	}

	for( k = 0, l = sources.length; k < l; k++) {
		name = sources[k];
		if (/\.dot(\.def|\.jst)?$/.test(name)) {
			console.log("Compiling " + name + " to function");
			this.__rendermodule[name.substring(0, name.indexOf('.'))] = this.compilePath(defFolder + name);
		}
		if (/\.jst(\.dot|\.def)?$/.test(name)) {
			console.log("Compiling " + name + " to file");
			this.compileToFile(this.__destination + name.substring(0, name.indexOf('.')) + '.js',
					readdata(defFolder + name));
		}
	}
	return this.__rendermodule;
};

},{"./doT":"/Users/sash/development/js/imglykit-rewrite/node_modules/dot/doT.js","fs":"/Users/sash/development/js/imglykit-rewrite/node_modules/browserify/lib/_empty.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/constants.js":[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

/**
 * The available render types
 * @enum {string}
 * @alias ImglyKit.RenderType
 */
var RenderType = exports.RenderType = {
  IMAGE: "image",
  DATAURL: "data-url"
};

/**
 * The available output image formats
 * @enum {string}
 * @alias ImglyKit.ImageFormat
 */
var ImageFormat = exports.ImageFormat = {
  PNG: "image/png",
  JPEG: "image/jpeg"
};

},{}],"/Users/sash/development/js/imglykit-rewrite/src/js/imglykit.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var _ = _interopRequire(require("lodash"));

var bluebird = _interopRequire(require("bluebird"));

var RenderImage = _interopRequire(require("./lib/render-image"));

var ImageExporter = _interopRequire(require("./lib/image-exporter"));

var RenderType = require("./constants").RenderType;
var ImageFormat = require("./constants").ImageFormat;
var Utils = _interopRequire(require("./lib/utils"));

// Default UIs
var NightUI = _interopRequire(require("./ui/night/ui"));

// Don't catch errors
bluebird.onPossiblyUnhandledRejection(function (error) {
  throw error;
});

/**
 * @class
 * @param {Object} options
 * @param {HTMLElement} [options.container] - Specifies where the UI should be
 *                                          added to. If none is given, the UI
 *                                          will automatically be disabled.
 * @param {Image} options.image - The source image
 */
var ImglyKit = (function () {
  function ImglyKit(options) {
    // `options` is required
    if (typeof options === "undefined") throw new Error("No options given.");
    // `options.image` is required
    if (typeof options.image === "undefined") throw new Error("`options.image` is undefined.");

    // Set default options
    options = _.defaults(options, {
      assetsUrl: "assets",
      container: null,
      ui: true
    });

    /**
     * @type {Object}
     * @private
     */
    this._options = options;

    /**
     * The stack of {@link Operation} instances that will be used
     * to render the final Image
     * @type {Array.<ImglyKit.Operation>}
     */
    this.operationsStack = [];

    /**
     * The registered UI types that can be selected via the `ui` option
     * @type {Object.<String, UI>}
     * @private
     */
    this._registeredUIs = {};

    // Register the default UIs
    this._registerUIs();

    /**
     * The registered operations
     * @type {Object.<String, ImglyKit.Operation>}
     */
    this._registeredOperations = {};

    // Register the default operations
    this._registerOperations();

    if (this._options.ui) {
      this._initUI();
    }
  }

  _prototypeProperties(ImglyKit, null, {
    render: {

      /**
       * Renders the image
       * @param  {ImglyKit.RenderType} [renderType=ImglyKit.RenderType.DATA_URL] - The output type
       * @param  {ImglyKit.ImageFormat} [imageFormat=ImglyKit.ImageFormat.PNG] - The output image format
       * @param  {string} [dimensions] - The final dimensions of the image
       * @return {Promise}
       */
      value: function render(renderType, imageFormat, dimensions) {
        var settings = ImageExporter.validateSettings(renderType, imageFormat);

        renderType = settings.renderType;
        imageFormat = settings.imageFormat;

        // Create a RenderImage
        var renderImage = new RenderImage(this._options.image, this.operationsStack, dimensions, this._options.renderer);

        // Initiate image rendering
        return renderImage.render().then(function () {
          var canvas = renderImage.getRenderer().getCanvas();
          return ImageExporter["export"](canvas, renderType, imageFormat);
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    reset: {

      /**
       * Resets all custom and selected operations
       */
      value: function reset() {},
      writable: true,
      enumerable: true,
      configurable: true
    },
    getAssetPath: {

      /**
       * Returns the asset path for the given filename
       * @param  {String} asset
       * @return {String}
       */
      value: function getAssetPath(asset) {
        var isBrowser = typeof window !== "undefined";
        if (isBrowser) {
          /* istanbul ignore next */
          return this._options.assetsUrl + "/" + asset;
        } else {
          var path = require("path");
          return path.resolve(this._options.assetsUrl, asset);
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _registerUIs: {

      /**
       * Registers all default UIs
       * @private
       */
      value: function RegisterUIs() {
        this.registerUI(NightUI);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _registerOperations: {

      /**
       * Registers all default operations
       * @private
       */
      value: function RegisterOperations() {
        for (var operationName in ImglyKit.Operations) {
          this.registerOperation(ImglyKit.Operations[operationName]);
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    registerOperation: {

      /**
       * Registers the given operation
       * @param {ImglyKit.Operation} operation - The operation class
       */
      value: function registerOperation(operation) {
        this._registeredOperations[operation.prototype.identifier] = operation;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    registerUI: {

      /**
       * Registers the given UI
       * @param {UI} ui
       */
      value: function registerUI(ui) {
        this._registeredUIs[ui.prototype.identifier] = ui;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _initUI: {

      /**
       * Initializes the UI
       * @private
       */
      /* istanbul ignore next */
      value: function InitUI() {
        var UI;

        if (this._options.ui === true) {
          // Select the first UI by default
          UI = Utils.values(this._registeredUIs)[0];
        } else {
          // Select the UI with the given identifier
          UI = this._registeredUIs[this._options.ui];
        }

        // Check if UI exists
        if (typeof UI === "undefined") {
          throw new Error("ImglyKit: Unknown UI: " + this._options.ui);
        }

        /**
         * @type {ImglyKit.UI}
         */
        var container = this._options.container;
        var assetsUrl = this._options.assetsUrl;
        this.ui = new UI(this, { container: container, assetsUrl: assetsUrl });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    registeredOperations: {
      get: function () {
        return this._registeredOperations;
      },
      enumerable: true,
      configurable: true
    },
    run: {
      value: function run() {
        this.ui.run();
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return ImglyKit;
})();

/**
 * The current version of the SDK
 * @name ImglyKit.version
 * @internal Keep in sync with package.json
 */
ImglyKit.version = "0.0.1";

// Exposed classes
ImglyKit.RenderImage = RenderImage;
ImglyKit.Color = require("./lib/color");
ImglyKit.Operation = require("./operations/operation");
ImglyKit.Operations = {};
ImglyKit.Operations.FiltersOperation = require("./operations/filters-operation");
ImglyKit.Operations.RotationOperation = require("./operations/rotation-operation");
ImglyKit.Operations.CropOperation = require("./operations/crop-operation");
ImglyKit.Operations.SaturationOperation = require("./operations/saturation-operation");
ImglyKit.Operations.ContrastOperation = require("./operations/contrast-operation");
ImglyKit.Operations.BrightnessOperation = require("./operations/brightness-operation");
ImglyKit.Operations.FlipOperation = require("./operations/flip-operation");
ImglyKit.Operations.TiltShiftOperation = require("./operations/tilt-shift-operation");
ImglyKit.Operations.RadialBlurOperation = require("./operations/radial-blur-operation");
ImglyKit.Operations.TextOperation = require("./operations/text-operation");
ImglyKit.Operations.StickersOperation = require("./operations/stickers-operation");
ImglyKit.Operations.FramesOperation = require("./operations/frames-operation");

// Exposed constants
ImglyKit.RenderType = RenderType;
ImglyKit.ImageFormat = ImageFormat;
ImglyKit.Vector2 = require("./lib/math/vector2");

module.exports = ImglyKit;

},{"./constants":"/Users/sash/development/js/imglykit-rewrite/src/js/constants.js","./lib/color":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/color.js","./lib/image-exporter":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/image-exporter.js","./lib/math/vector2":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/math/vector2.js","./lib/render-image":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/render-image.js","./lib/utils":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/utils.js","./operations/brightness-operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/brightness-operation.js","./operations/contrast-operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/contrast-operation.js","./operations/crop-operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/crop-operation.js","./operations/filters-operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters-operation.js","./operations/flip-operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/flip-operation.js","./operations/frames-operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/frames-operation.js","./operations/operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/operation.js","./operations/radial-blur-operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/radial-blur-operation.js","./operations/rotation-operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/rotation-operation.js","./operations/saturation-operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/saturation-operation.js","./operations/stickers-operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/stickers-operation.js","./operations/text-operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/text-operation.js","./operations/tilt-shift-operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/tilt-shift-operation.js","./ui/night/ui":"/Users/sash/development/js/imglykit-rewrite/src/js/ui/night/ui.js","bluebird":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/bluebird.js","lodash":"lodash","path":"/Users/sash/development/js/imglykit-rewrite/node_modules/browserify/node_modules/path-browserify/index.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/lib/color.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

/**
 * Represents a color
 * @class
 * @alias ImglyKit.Color
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 * @param {Number} [a]
 * @private
 */
var Color = (function () {
  function Color(r, g, b, a) {
    if (typeof a === "undefined") a = 1;

    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }

  _prototypeProperties(Color, null, {
    toRGBA: {

      /**
       * Returns an rgba() representation of this color
       * @return {String}
       */
      value: function toRGBA() {
        var colors = [this.r * 255, this.g * 255, this.b * 255, this.a];
        return "rgba(" + colors.join(",") + ")";
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    toHex: {

      /**
       * Returns a hex representation of this color
       * @return {String}
       */
      value: function toHex() {
        var components = [this._componentToHex(this.r * 255), this._componentToHex(this.g * 255), this._componentToHex(this.b * 255)];
        return "#" + components.join("");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    toGLColor: {

      /**
       * Returns an array with 4 values (0...1)
       * @return {Array.<Number>}
       */
      value: function toGLColor() {
        return [this.r, this.g, this.b, this.a];
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    toRGBGLColor: {

      /**
       * Returns an array with 3 values (0...1)
       * @return {Array.<Number>}
       */
      value: function toRGBGLColor() {
        return [this.r, this.g, this.b];
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _componentToHex: {

      /**
       * Returns the given number as hex
       * @param  {Number} component
       * @return {String}
       * @private
       */
      value: function ComponentToHex(component) {
        var hex = component.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Color;
})();

module.exports = Color;

},{}],"/Users/sash/development/js/imglykit-rewrite/src/js/lib/event-emitter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

/**
 * EventEmitter (ES6) from:
 * https://gist.github.com/bloodyowl/41b1de3388c626796eca
 */

var DEFAULT_MAX_LISTENERS = 12;

function error(message) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  console.error.apply(console, [message].concat(args));
  console.trace();
}

var EventEmitter = (function () {
  function EventEmitter() {
    this._maxListeners = DEFAULT_MAX_LISTENERS;
    this._events = {};
  }

  _prototypeProperties(EventEmitter, null, {
    on: {
      value: function on(type, listener) {
        if (typeof listener != "function") {
          throw new TypeError();
        }

        var listeners = this._events[type] || (this._events[type] = []);
        if (listeners.indexOf(listener) != -1) {
          return this;
        }
        listeners.push(listener);

        if (listeners.length > this._maxListeners) {
          error("possible memory leak, added %i %s listeners, " + "use EventEmitter#setMaxListeners(number) if you " + "want to increase the limit (%i now)", listeners.length, type, this._maxListeners);
        }
        return this;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    once: {
      value: function once(type, listener) {
        var onceCallback = function () {
          eventsInstance.off(type, onceCallback);
          listener.apply(null, arguments);
        };

        var eventsInstance = this;
        return this.on(type, onceCallback);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    off: {
      value: function off(type) {
        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        if (args.length === 0) {
          this._events[type] = null;
        }

        var listener = args[0];
        if (typeof listener != "function") {
          throw new TypeError();
        }

        var listeners = this._events[type];
        if (!listeners || !listeners.length) {
          return this;
        }

        var indexOfListener = listeners.indexOf(listener);
        if (indexOfListener == -1) {
          return this;
        }

        listeners.splice(indexOfListener, 1);
        return this;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    emit: {
      value: function emit(type) {
        for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }

        var listeners = this._events[type];
        if (!listeners || !listeners.length) {
          return false;
        }

        listeners.forEach(function (fn) {
          return fn.apply(null, args);
        });

        return true;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    setMaxListeners: {
      value: function setMaxListeners(newMaxListeners) {
        if (parseInt(newMaxListeners) !== newMaxListeners) {
          throw new TypeError();
        }

        this._maxListeners = newMaxListeners;
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return EventEmitter;
})();

module.exports = EventEmitter;

},{}],"/Users/sash/development/js/imglykit-rewrite/src/js/lib/extend.js":[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

/**
 * Helper function to correctly set up the prototype chain
 * Based on the backbone.js extend function:
 * https://github.com/jashkenas/backbone/blob/master/backbone.js
 * @param  {Object} prototypeProperties
 * @param  {Object} classProperties
 * @return {Object}
 */
module.exports = function (prototypeProperties, classProperties) {
  /*jshint validthis:true*/
  var parent = this;
  var child;

  // The constructor function for the new subclass is either defined by you
  // (the "constructor" property in your `extend` definition), or defaulted
  // by us to simply call the parent's constructor.
  if (prototypeProperties && prototypeProperties.hasOwnProperty("constructor")) {
    child = prototypeProperties.constructor;
  } else {
    child = function () {
      return parent.apply(this, arguments);
    };
  }

  // Add static properties to the constructor function, if supplied.
  var key;
  for (key in parent) {
    child[key] = parent[key];
  }
  if (typeof classProperties !== "undefined") {
    for (key in classProperties) {
      child[key] = classProperties[key];
    }
  }

  // Set the prototype chain to inherit from `parent`, without calling
  // `parent`'s constructor function.
  var Surrogate = function () {
    this.constructor = child;
  };
  Surrogate.prototype = parent.prototype;
  child.prototype = new Surrogate();

  // Add prototype properties (instance properties) to the subclass,
  // if supplied.
  if (prototypeProperties) {
    for (key in prototypeProperties) {
      child.prototype[key] = prototypeProperties[key];
    }
  }

  // Set a convenience property in case the parent's prototype is needed
  // later.
  child.__super__ = parent.prototype;

  return child;
};

},{}],"/Users/sash/development/js/imglykit-rewrite/src/js/lib/image-dimensions.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

/**
 * Parses the dimensions string and provides calculation functions
 * @class
 * @alias ImglyKit.ImageDimensions
 * @param {string} dimensions
 * @private
 */
var ImageDimensions = (function () {
  function ImageDimensions(dimensions) {
    /**
     * The available dimension modifiers
     * @type {Object}
     * @private
     */
    this._modifiers = {
      FIXED: "!"
    };

    /**
     * @type {string}
     * @private
     */
    this._dimensionsString = dimensions;

    /**
     * An object that represents the parsed dimensions string
     * @type {Object}
     */
    this._rules = this._parse();

    this._validateRules();
  }

  _prototypeProperties(ImageDimensions, null, {
    _parse: {

      /**
       * Parses the dimensions string
       * @private
       */
      value: function Parse() {
        if (typeof this._dimensionsString === "undefined") {
          return null;
        }

        var match = this._dimensionsString.match(/^([0-9]+)?x([0-9]+)?([\!])?$/i);
        if (!match) {
          throw new Error("Invalid size option: " + this._dimensionsString);
        }

        return {
          x: isNaN(match[1]) ? null : parseInt(match[1]),
          y: isNaN(match[2]) ? null : parseInt(match[2]),
          modifier: match[3]
        };
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _validateRules: {

      /**
       * Validates the rules
       * @private
       */
      value: function ValidateRules() {
        if (this._rules === null) return;

        var xAvailable = this._rules.x !== null;
        var yAvailable = this._rules.y !== null;

        if (this._rules.modifier === this._modifiers.FIXED && !(xAvailable && yAvailable)) {
          throw new Error("Both `x` and `y` have to be set when using the fixed (!) modifier.");
        }

        if (!xAvailable && !yAvailable) {
          throw new Error("Neither `x` nor `y` are given.");
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    calculateFinalDimensions: {

      /**
       * Calculates the final dimensions using the dimensions string and the
       * given initial dimensions
       * @param  {Vector2} initialDimensions
       * @return {Vector2}
       */
      value: function calculateFinalDimensions(initialDimensions) {
        var dimensions = initialDimensions.clone(), ratio;

        if (this._rules === null) return dimensions;

        /* istanbul ignore else */
        if (this._rules.modifier === this._modifiers.FIXED) {
          // Fixed dimensions
          dimensions.set(this._rules.x, this._rules.y);
        } else if (this._rules.x !== null && this._rules.y !== null) {
          // Both x and y given, resize to fit
          ratio = Math.min(this._rules.x / dimensions.x, this._rules.y / dimensions.y);
          dimensions.multiply(ratio);
        } else if (this._rules.x !== null) {
          // Fixed x, y by ratio
          ratio = initialDimensions.y / initialDimensions.x;
          dimensions.x = this._rules.x;
          dimensions.y = dimensions.x * ratio;
        } else if (this._rules.y !== null) {
          // Fixed y, x by ratio
          ratio = initialDimensions.x / initialDimensions.y;
          dimensions.y = this._rules.y;
          dimensions.x = dimensions.y * ratio;
        }

        return dimensions;
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return ImageDimensions;
})();

module.exports = ImageDimensions;

},{}],"/Users/sash/development/js/imglykit-rewrite/src/js/lib/image-exporter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */
var RenderType = require("../constants").RenderType;
var ImageFormat = require("../constants").ImageFormat;
var Utils = _interopRequire(require("./utils"));

/**
 * @class
 * @alias ImglyKit.ImageExporter
 * @private
 */
var ImageExporter = (function () {
  function ImageExporter() {}

  _prototypeProperties(ImageExporter, {
    validateSettings: {
      value: function validateSettings(renderType, imageFormat) {
        var settings = {
          renderType: renderType,
          imageFormat: imageFormat
        };

        // Validate RenderType
        if (typeof settings.renderType !== "undefined" && settings.renderType !== null && Utils.values(RenderType).indexOf(settings.renderType) === -1) {
          throw new Error("Invalid render type: " + settings.renderType);
        } else if (typeof renderType === "undefined") {
          settings.renderType = RenderType.DATA_URL;
        }

        // Validate ImageFormat
        if (typeof settings.imageFormat !== "undefined" && settings.imageFormat !== null && Utils.values(ImageFormat).indexOf(settings.imageFormat) === -1) {
          throw new Error("Invalid image format: " + settings.imageFormat);
        } else if (typeof imageFormat === "undefined") {
          settings.imageFormat = ImageFormat.PNG;
        }

        return settings;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    "export": {

      /**
       * Exports the image from the given canvas with the given options
       * @param  {Canvas} canvas
       * @param  {ImglyKit.RenderType} renderType
       * @param  {ImglyKit.ImageFormat} imageFormat
       * @return {string|image}
       */
      value: function _export(canvas, renderType, imageFormat) {
        var result = canvas.toDataURL(imageFormat);
        if (renderType == RenderType.IMAGE) {
          var image;

          /* istanbul ignore else  */
          if (typeof window === "undefined") {
            // Not a browser environment
            var CanvasImage = require("canvas").Image;
            image = new CanvasImage();
          } else {
            image = new Image();
          }

          image.src = result;
          result = image;
        }
        return result;
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return ImageExporter;
})();

module.exports = ImageExporter;

},{"../constants":"/Users/sash/development/js/imglykit-rewrite/src/js/constants.js","./utils":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/utils.js","canvas":"canvas"}],"/Users/sash/development/js/imglykit-rewrite/src/js/lib/math/vector2.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

/**
 * Represents a 2-dimensional vector while providing math functions to
 * modify / clone the vector. Fully chainable.
 * @class
 * @alias ImglyKit.Vector2
 * @param {number} x
 * @param {number} y
 * @private
 */
var Vector2 = (function () {
  function Vector2(x, y) {
    this.x = x;
    this.y = y;
    if (typeof this.x === "undefined") {
      this.x = 0;
    }
    if (typeof this.y === "undefined") {
      this.y = 0;
    }
  }

  _prototypeProperties(Vector2, null, {
    set: {

      /**
       * Sets the given values
       * @param {number} x
       * @param {number} y
       * @return {Vector2}
       */
      value: function set(x, y) {
        this.x = x;
        this.y = y;
        return this;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    clone: {

      /**
       * Creates a clone of this vector
       * @return {Vector2}
       */
      value: function clone() {
        return new Vector2(this.x, this.y);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    copy: {

      /**
       * Copies the values of the given vector
       * @param  {Vector2} other
       * @return {Vector2}
       */
      value: function copy(other) {
        this.x = other.x;
        this.y = other.y;
        return this;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    clamp: {

      /**
       * Clamps this vector with the given Vector2 / number
       * @param  {(number|Vector2)} minimum
       * @param  {(number|Vector2)} maximum
       * @return {Vector2}
       */
      value: function clamp(minimum, maximum) {
        /* istanbul ignore else  */
        if (!(minimum instanceof Vector2)) {
          minimum = new Vector2(minimum, minimum);
        }
        /* istanbul ignore else  */
        if (!(maximum instanceof Vector2)) {
          maximum = new Vector2(maximum, maximum);
        }
        this.x = Math.max(minimum.x, Math.min(maximum.x, this.x));
        this.y = Math.max(minimum.y, Math.min(maximum.y, this.y));
        return this;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    divide: {

      /**
       * Divides this vector by the given Vector2 / number
       * @param  {(number|Vector2)} divisor
       * @param  {number} [y]
       * @return {Vector2}
       */
      value: function divide(divisor, y) {
        if (divisor instanceof Vector2) {
          this.x /= divisor.x;
          this.y /= divisor.y;
        } else {
          this.x /= divisor;
          this.y /= typeof y === "undefined" ? divisor : y;
        }
        return this;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    subtract: {

      /**
       * Subtracts the given Vector2 / number from this vector
       * @param  {(number|Vector2)} subtrahend
       * @param  {number} [y]
       * @return {Vector2}
       */
      value: function subtract(subtrahend, y) {
        if (subtrahend instanceof Vector2) {
          this.x -= subtrahend.x;
          this.y -= subtrahend.y;
        } else {
          this.x -= subtrahend;
          this.y -= typeof y === "undefined" ? subtrahend : y;
        }
        return this;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    multiply: {

      /**
       * Multiplies the given Vector2 / number with this vector
       * @param  {(number|Vector2)} subtrahend
       * @param  {number} [y]
       * @return {Vector2}
       */
      value: function multiply(factor, y) {
        if (factor instanceof Vector2) {
          this.x *= factor.x;
          this.y *= factor.y;
        } else {
          this.x *= factor;
          this.y *= typeof y === "undefined" ? factor : y;
        }
        return this;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    add: {

      /**
       * Adds the given Vector2 / numbers to this vector
       * @param {(number|Vector2)} addend
       * @param {number} [y]
       */
      value: function add(addend, y) {
        if (addend instanceof Vector2) {
          this.x += addend.x;
          this.y += addend.y;
        } else {
          this.x += addend;
          this.y += typeof y === "undefined" ? addend : y;
        }
        return this;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    equals: {

      /**
       * Checks whether the x and y value are the same as the given ones
       * @param  {(number|Vector2)} vec
       * @param  {number} y
       * @return {boolean}
       */
      value: function equals(vec, y) {
        if (vec instanceof Vector2) {
          return vec.x === this.x && vec.y === this.y;
        } else {
          return vec === this.x && y === this.y;
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    toString: {

      /**
       * Returns a string representation of this vector
       * @return {String}
       */
      value: function toString() {
        return "Vector2({ x: " + this.x + ", y: " + this.y + " })";
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Vector2;
})();

module.exports = Vector2;

},{}],"/Users/sash/development/js/imglykit-rewrite/src/js/lib/render-image.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */
var bluebird = _interopRequire(require("bluebird"));

var ImageDimensions = _interopRequire(require("./image-dimensions"));

var Vector2 = _interopRequire(require("./math/vector2"));

var CanvasRenderer = _interopRequire(require("../renderers/canvas-renderer"));

var WebGLRenderer = _interopRequire(require("../renderers/webgl-renderer"));

/**
 * Handles the image rendering process
 * @class
 * @alias ImglyKit.RenderImage
 * @param {Image} image
 * @param {Array.<ImglyKit.Operation>} operationsStack
 * @param {string} dimensions
 * @param {string} preferredRenderer
 * @private
 */
var RenderImage = (function () {
  function RenderImage(image, operationsStack, dimensions, preferredRenderer) {
    /**
     * @type {Object}
     * @private
     */
    this._options = {
      preferredRenderer: preferredRenderer
    };

    /**
     * @type {Boolean}
     * @private
     * @default false
     */
    this._webglEnabled = false;

    /**
     * @type {Renderer}
     * @private
     */
    this._renderer = null;

    /**
     * @type {Image}
     * @private
     */
    this._image = image;

    /**
     * @type {Array.<ImglyKit.Operation>}
     * @private
     */
    this._stack = operationsStack;

    /**
     * @type {ImglyKit.ImageDimensions}
     * @private
     */
    this._dimensions = new ImageDimensions(dimensions);

    /**
     * @type {Vector2}
     * @private
     */
    this._initialDimensions = new Vector2(this._image.width, this._image.height);

    this._initRenderer();
  }

  _prototypeProperties(RenderImage, null, {
    _initRenderer: {

      /**
       * Creates a renderer (canvas or webgl, depending on support)
       * @return {Promise}
       * @private
       */
      value: function InitRenderer() {
        /* istanbul ignore if */
        if (WebGLRenderer.isSupported() && this._options.preferredRenderer !== "canvas") {
          this._renderer = new WebGLRenderer(this._initialDimensions);
          this._webglEnabled = true;
        } else if (CanvasRenderer.isSupported()) {
          this._renderer = new CanvasRenderer(this._initialDimensions);
          this._webglEnabled = false;
        }

        /* istanbul ignore if */
        if (this._renderer === null) {
          throw new Error("Neither Canvas nor WebGL renderer are supported.");
        }

        this._renderer.drawImage(this._image);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    render: {

      /**
       * Renders the image
       * @return {Promise}
       */
      value: function render() {
        var self = this;
        return bluebird.map(this._stack, function (operation) {
          return operation.validateSettings();
        }).then(function () {
          return bluebird.map(self._stack, function (operation) {
            return operation.render(self._renderer);
          }, { concurrency: 1 }).then(function () {
            return self._renderer.renderFinal();
          });
        }).then(function () {
          var initialSize = self._renderer.getSize();
          var finalDimensions = self._dimensions.calculateFinalDimensions(initialSize);

          if (finalDimensions.equals(initialSize)) {
            // No need to resize
            return;
          }

          return self._renderer.resizeTo(finalDimensions);
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    getRenderer: {

      /**
       * Returns the renderer
       * @return {Renderer}
       */
      value: function getRenderer() {
        return this._renderer;
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return RenderImage;
})();

module.exports = RenderImage;

},{"../renderers/canvas-renderer":"/Users/sash/development/js/imglykit-rewrite/src/js/renderers/canvas-renderer.js","../renderers/webgl-renderer":"/Users/sash/development/js/imglykit-rewrite/src/js/renderers/webgl-renderer.js","./image-dimensions":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/image-dimensions.js","./math/vector2":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/math/vector2.js","bluebird":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/bluebird.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/lib/utils.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

/**
 * Provides utility functions for internal use
 * @class
 * @alias ImglyKit.Utils
 * @private
 */
var Utils = (function () {
  function Utils() {}

  _prototypeProperties(Utils, {
    isArray: {

      /**
       * Checks if the given object is an Array
       * @param  {Object}  object
       * @return {Boolean}
       */
      value: function isArray(object) {
        return Object.prototype.toString.call(object) === "[object Array]";
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    select: {

      /**
       * Returns the items selected by the given selector
       * @param  {Array} items
       * @param  {ImglyKit~Selector} selector - The selector
       * @return {Array} The selected items
       */
      value: function select(items, selector) {
        if (selector === null) {
          return items;
        }

        // Turn string parameter into an array
        if (typeof selector === "string") {
          selector = selector.split(",").map(function (identifier) {
            return identifier.trim();
          });
        }

        // Turn array parameter into an object with `only`
        if (Utils.isArray(selector)) {
          selector = { only: selector };
        }

        if (typeof selector.only !== "undefined") {
          // Select only the given identifiers
          return items.filter(function (item) {
            return selector.only.indexOf(item) !== -1;
          });
        } else if (typeof selector.except !== "undefined") {
          // Select all but the given identifiers
          return items.filter(function (item) {
            return selector.except.indexOf(item) === -1;
          });
        }

        throw new Error("Utils#select failed to filter items.");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    values: {

      /**
       * Returns the given object's values as an array
       * @param {Object} object
       * @returns {Array<*>}
       */
      value: function values(object) {
        var values = [];
        for (var key in object) {
          values.push(object[key]);
        }
        return values;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    isDOMElement: {

      /**
       * Checks if the given object is a DOM element
       * @param  {Object}  o
       * @return {Boolean}
       */
      /* istanbul ignore next */
      value: function isDOMElement(o) {
        return typeof HTMLElement === "object" ? o instanceof HTMLElement : o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Utils;
})();

module.exports = Utils;

},{}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/brightness-operation.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Operation = _interopRequire(require("./operation"));

var PrimitivesStack = _interopRequire(require("./filters/primitives-stack"));

var BrightnessPrimitive = _interopRequire(require("./filters/primitives/brightness"));

/**
 * @class
 * @alias ImglyKit.Operations.BrightnessOperation
 * @extends ImglyKit.Operation
 */
var BrightnessOperation = (function (Operation) {
  function BrightnessOperation() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.availableOptions = {
      brightness: { type: "number", "default": 0 }
    };

    _get(Object.getPrototypeOf(BrightnessOperation.prototype), "constructor", this).apply(this, args);
  }

  _inherits(BrightnessOperation, Operation);

  _prototypeProperties(BrightnessOperation, null, {
    identifier: {

      /**
       * A unique string that identifies this operation. Can be used to select
       * operations.
       * @type {String}
       */
      get: function () {
        return "brightness";
      },
      enumerable: true,
      configurable: true
    },
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new PrimitivesStack();

        stack.add(new BrightnessPrimitive({
          brightness: this._options.brightness
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return BrightnessOperation;
})(Operation);

module.exports = BrightnessOperation;

},{"./filters/primitives-stack":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives-stack.js","./filters/primitives/brightness":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/brightness.js","./operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/operation.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/contrast-operation.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Operation = _interopRequire(require("./operation"));

var PrimitivesStack = _interopRequire(require("./filters/primitives-stack"));

var ContrastPrimitive = _interopRequire(require("./filters/primitives/contrast"));

/**
 * @class
 * @alias ImglyKit.Operations.ContrastOperation
 * @extends ImglyKit.Operation
 */
var ContrastOperation = (function (Operation) {
  function ContrastOperation() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.availableOptions = {
      contrast: { type: "number", "default": 1 }
    };

    _get(Object.getPrototypeOf(ContrastOperation.prototype), "constructor", this).apply(this, args);
  }

  _inherits(ContrastOperation, Operation);

  _prototypeProperties(ContrastOperation, null, {
    identifier: {

      /**
       * A unique string that identifies this operation. Can be used to select
       * operations.
       * @type {String}
       */
      get: function () {
        return "contrast";
      },
      enumerable: true,
      configurable: true
    },
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new PrimitivesStack();

        stack.add(new ContrastPrimitive({
          contrast: this._options.contrast
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return ContrastOperation;
})(Operation);

module.exports = ContrastOperation;

},{"./filters/primitives-stack":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives-stack.js","./filters/primitives/contrast":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/contrast.js","./operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/operation.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/crop-operation.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Operation = _interopRequire(require("./operation"));

var Vector2 = _interopRequire(require("../lib/math/vector2"));

/**
 * An operation that can crop out a part of the image
 *
 * @class
 * @alias ImglyKit.Operations.CropOperation
 * @extends ImglyKit.Operation
 */
var CropOperation = (function (Operation) {
  function CropOperation() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.availableOptions = {
      start: { type: "vector2", required: true },
      end: { type: "vector2", required: true }
    };

    /**
     * The fragment shader used for this operation
     */
    this.fragmentShader = "\n      precision mediump float;\n      uniform sampler2D u_image;\n      varying vec2 v_texCoord;\n      uniform vec2 u_cropStart;\n      uniform vec2 u_cropEnd;\n\n      void main() {\n        vec2 size = u_cropEnd - u_cropStart;\n        gl_FragColor = texture2D(u_image, v_texCoord * size + u_cropStart);\n      }\n    ";

    _get(Object.getPrototypeOf(CropOperation.prototype), "constructor", this).apply(this, args);
  }

  _inherits(CropOperation, Operation);

  _prototypeProperties(CropOperation, null, {
    identifier: {

      /**
       * A unique string that identifies this operation. Can be used to select
       * operations.
       * @type {String}
       */
      get: function () {
        return "crop";
      },
      enumerable: true,
      configurable: true
    },
    _renderWebGL: {

      /**
       * Crops this image using WebGL
       * @param  {WebGLRenderer} renderer
       */
      /* istanbul ignore next */
      value: function RenderWebGL(renderer) {
        var canvas = renderer.getCanvas();
        var gl = renderer.getContext();
        var canvasSize = new Vector2(canvas.width, canvas.height);

        var start = this._options.start.clone();
        var end = this._options.end.clone();

        if (this._options.numberFormat === "absolute") {
          start.divide(canvasSize);
          end.divide(canvasSize);
        }

        // 0..1 > 1..0 on y-axis
        var originalStartY = start.y;
        start.y = 1 - end.y;
        end.y = 1 - originalStartY;

        // The new size
        var newDimensions = this._getNewDimensions(renderer);

        // Make sure we don't resize the input texture
        var lastTexture = renderer.getLastTexture();

        // Resize all textures except the one we use as input
        var textures = renderer.getTextures();
        var texture;
        for (var i = 0; i < textures.length; i++) {
          texture = textures[i];
          if (texture === lastTexture) continue;

          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, newDimensions.x, newDimensions.y, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }

        // Resize the canvas
        canvas.width = newDimensions.x;
        canvas.height = newDimensions.y;

        // Run the cropping shader
        renderer.runShader(null, this.fragmentShader, {
          uniforms: {
            u_cropStart: { type: "2f", value: [start.x, start.y] },
            u_cropEnd: { type: "2f", value: [end.x, end.y] }
          }
        });

        // Resize the input texture
        gl.bindTexture(gl.TEXTURE_2D, lastTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, newDimensions.x, newDimensions.y, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _renderCanvas: {

      /**
       * Crops the image using Canvas2D
       * @param  {CanvasRenderer} renderer
       */
      value: function RenderCanvas(renderer) {
        var canvas = renderer.getCanvas();
        var dimensions = new Vector2(canvas.width, canvas.height);

        var newDimensions = this._getNewDimensions(renderer);

        // Create a temporary canvas to draw to
        var newCanvas = renderer.createCanvas();
        newCanvas.width = newDimensions.x;
        newCanvas.height = newDimensions.y;
        var newContext = newCanvas.getContext("2d");

        // The upper left corner of the cropped area on the original image
        var startPosition = this._options.start.clone();

        if (this._options.numberFormat === "relative") {
          startPosition.multiply(dimensions);
        }

        // Draw the source canvas onto the new one
        newContext.drawImage(canvas, startPosition.x, startPosition.y, // source x, y
        newDimensions.x, newDimensions.y, // source dimensions
        0, 0, // destination x, y
        newDimensions.x, newDimensions.y // destination dimensions
        );

        // Set the new canvas
        renderer.setCanvas(newCanvas);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _getNewDimensions: {

      /**
       * Gets the new dimensions
       * @return {Vector2}
       * @private
       */
      value: function GetNewDimensions(renderer) {
        var canvas = renderer.getCanvas();
        var dimensions = new Vector2(canvas.width, canvas.height);

        var newDimensions = this._options.end.clone().subtract(this._options.start);

        if (this._options.numberFormat === "relative") {
          newDimensions.multiply(dimensions);
        }

        return newDimensions;
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return CropOperation;
})(Operation);

module.exports = CropOperation;

},{"../lib/math/vector2":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/math/vector2.js","./operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/operation.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters-operation.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Operation = _interopRequire(require("./operation"));

/**
 * An operation that can apply a selected filter
 *
 * @class
 * @alias ImglyKit.Operations.FiltersOperation
 * @extends ImglyKit.Operation
 */
var FiltersOperation = (function (Operation) {
  function FiltersOperation() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.availableOptions = {
      filter: { type: "string", "default": "identity",
        setter: function (value) {
          var Filter = this._filters[value];
          if (typeof Filter === "undefined") {
            throw new Error("FiltersOperation: Unknown filter \"" + value + "\".");
          }
          this._selectedFilter = new Filter();
          return value;
        }
      }
    };

    /**
     * The registered filters
     * @type {Object.<string, class>}
     */
    this._filters = {};
    this._registerFilters();

    _get(Object.getPrototypeOf(FiltersOperation.prototype), "constructor", this).apply(this, args);
  }

  _inherits(FiltersOperation, Operation);

  _prototypeProperties(FiltersOperation, null, {
    identifier: {

      /**
       * A unique string that identifies this operation. Can be used to select
       * operations.
       * @type {String}
       */
      get: function () {
        return "filters";
      },
      enumerable: true,
      configurable: true
    },
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        this._selectedFilter.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _registerFilters: {

      /**
       * Registers all the known filters
       * @private
       */
      value: function RegisterFilters() {
        this._registerFilter(require("./filters/identity-filter"));
        this._registerFilter(require("./filters/k1-filter"));
        this._registerFilter(require("./filters/k2-filter"));
        this._registerFilter(require("./filters/k6-filter"));
        this._registerFilter(require("./filters/kdynamic-filter"));
        this._registerFilter(require("./filters/fridge-filter"));
        this._registerFilter(require("./filters/breeze-filter"));
        this._registerFilter(require("./filters/orchid-filter"));
        this._registerFilter(require("./filters/chest-filter"));
        this._registerFilter(require("./filters/front-filter"));
        this._registerFilter(require("./filters/fixie-filter"));
        this._registerFilter(require("./filters/x400-filter"));
        this._registerFilter(require("./filters/bw-filter"));
        this._registerFilter(require("./filters/bwhard-filter"));
        this._registerFilter(require("./filters/lenin-filter"));
        this._registerFilter(require("./filters/quozi-filter"));
        this._registerFilter(require("./filters/pola669-filter"));
        this._registerFilter(require("./filters/pola-filter"));
        this._registerFilter(require("./filters/food-filter"));
        this._registerFilter(require("./filters/glam-filter"));
        this._registerFilter(require("./filters/celsius-filter"));
        this._registerFilter(require("./filters/texas-filter"));
        this._registerFilter(require("./filters/morning-filter"));
        this._registerFilter(require("./filters/lomo-filter"));
        this._registerFilter(require("./filters/gobblin-filter"));
        this._registerFilter(require("./filters/mellow-filter"));
        this._registerFilter(require("./filters/sunny-filter"));
        this._registerFilter(require("./filters/a15-filter"));
        this._registerFilter(require("./filters/semired-filter"));
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _registerFilter: {

      /**
       * Registers the given filter
       * @param  {class} filter
       * @private
       */
      value: function RegisterFilter(filter) {
        this._filters[filter.identifier] = filter;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    filters: {

      /**
       * The registered filters
       * @type {Object.<String, Filter>}
       */
      get: function () {
        return this._filters;
      },
      enumerable: true,
      configurable: true
    }
  });

  return FiltersOperation;
})(Operation);

module.exports = FiltersOperation;

},{"./filters/a15-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/a15-filter.js","./filters/breeze-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/breeze-filter.js","./filters/bw-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/bw-filter.js","./filters/bwhard-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/bwhard-filter.js","./filters/celsius-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/celsius-filter.js","./filters/chest-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/chest-filter.js","./filters/fixie-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/fixie-filter.js","./filters/food-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/food-filter.js","./filters/fridge-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/fridge-filter.js","./filters/front-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/front-filter.js","./filters/glam-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/glam-filter.js","./filters/gobblin-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/gobblin-filter.js","./filters/identity-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/identity-filter.js","./filters/k1-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/k1-filter.js","./filters/k2-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/k2-filter.js","./filters/k6-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/k6-filter.js","./filters/kdynamic-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/kdynamic-filter.js","./filters/lenin-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/lenin-filter.js","./filters/lomo-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/lomo-filter.js","./filters/mellow-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/mellow-filter.js","./filters/morning-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/morning-filter.js","./filters/orchid-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/orchid-filter.js","./filters/pola-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/pola-filter.js","./filters/pola669-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/pola669-filter.js","./filters/quozi-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/quozi-filter.js","./filters/semired-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/semired-filter.js","./filters/sunny-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/sunny-filter.js","./filters/texas-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/texas-filter.js","./filters/x400-filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/x400-filter.js","./operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/operation.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/a15-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * A15 Filter
 * @class
 * @alias ImglyKit.Filters.A15Filter
 * @extends {ImglyKit.Filter}
 */
var A15Filter = (function (Filter) {
  function A15Filter() {
    if (Object.getPrototypeOf(A15Filter) !== null) {
      Object.getPrototypeOf(A15Filter).apply(this, arguments);
    }
  }

  _inherits(A15Filter, Filter);

  _prototypeProperties(A15Filter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "a15";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {


      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        stack.add(new Filter.Primitives.Contrast({
          contrast: 0.63
        }));

        stack.add(new Filter.Primitives.Brightness({
          brightness: 0.12
        }));

        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 38], [94, 94], [148, 142], [175, 187], [255, 255]],
            green: [[0, 0], [77, 53], [171, 190], [255, 255]],
            blue: [[0, 10], [48, 85], [174, 228], [255, 255]]
          }
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return A15Filter;
})(Filter);

module.exports = A15Filter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/breeze-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Breeze Filter
 * @class
 * @alias ImglyKit.Filters.BreezeFilter
 * @extends {ImglyKit.Filter}
 */
var BreezeFilter = (function (Filter) {
  function BreezeFilter() {
    if (Object.getPrototypeOf(BreezeFilter) !== null) {
      Object.getPrototypeOf(BreezeFilter).apply(this, arguments);
    }
  }

  _inherits(BreezeFilter, Filter);

  _prototypeProperties(BreezeFilter, {
    identifier: {

      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "breeze";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        // Desaturation
        stack.add(new Filter.Primitives.Desaturation({
          desaturation: 0.5
        }));

        // Tone curve
        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 0], [170, 170], [212, 219], [234, 242], [255, 255]],
            green: [[0, 0], [170, 168], [234, 231], [255, 255]],
            blue: [[0, 0], [170, 170], [212, 208], [255, 255]]
          }
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return BreezeFilter;
})(Filter);

module.exports = BreezeFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/bw-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * BW Filter
 * @class
 * @alias ImglyKit.Filters.BWFilter
 * @extends {ImglyKit.Filter}
 */
var BWFilter = (function (Filter) {
  function BWFilter() {
    if (Object.getPrototypeOf(BWFilter) !== null) {
      Object.getPrototypeOf(BWFilter).apply(this, arguments);
    }
  }

  _inherits(BWFilter, Filter);

  _prototypeProperties(BWFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "bw";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        stack.add(new Filter.Primitives.Grayscale());

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return BWFilter;
})(Filter);

module.exports = BWFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/bwhard-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * BWHard Filter
 * @class
 * @alias ImglyKit.Filters.BWHardFilter
 * @extends {ImglyKit.Filter}
 */
var BWHardFilter = (function (Filter) {
  function BWHardFilter() {
    if (Object.getPrototypeOf(BWHardFilter) !== null) {
      Object.getPrototypeOf(BWHardFilter).apply(this, arguments);
    }
  }

  _inherits(BWHardFilter, Filter);

  _prototypeProperties(BWHardFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "bwhard";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        stack.add(new Filter.Primitives.Grayscale());
        stack.add(new Filter.Primitives.Contrast({
          contrast: 1.5
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return BWHardFilter;
})(Filter);

module.exports = BWHardFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/celsius-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Celsius Filter
 * @class
 * @alias ImglyKit.Filters.CelsiusFilter
 * @extends {ImglyKit.Filter}
 */
var CelsiusFilter = (function (Filter) {
  function CelsiusFilter() {
    if (Object.getPrototypeOf(CelsiusFilter) !== null) {
      Object.getPrototypeOf(CelsiusFilter).apply(this, arguments);
    }
  }

  _inherits(CelsiusFilter, Filter);

  _prototypeProperties(CelsiusFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "celsius";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 69], [55, 110], [202, 230], [255, 255]],
            green: [[0, 44], [89, 93], [185, 141], [255, 189]],
            blue: [[0, 76], [39, 82], [218, 138], [255, 171]]
          }
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return CelsiusFilter;
})(Filter);

module.exports = CelsiusFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/chest-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Chest Filter
 * @class
 * @alias ImglyKit.Filters.ChestFilter
 * @extends {ImglyKit.Filter}
 */
var ChestFilter = (function (Filter) {
  function ChestFilter() {
    if (Object.getPrototypeOf(ChestFilter) !== null) {
      Object.getPrototypeOf(ChestFilter).apply(this, arguments);
    }
  }

  _inherits(ChestFilter, Filter);

  _prototypeProperties(ChestFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "chest";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        // Tone curve
        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 0], [44, 44], [124, 143], [221, 204], [255, 255]],
            green: [[0, 0], [130, 127], [213, 199], [255, 255]],
            blue: [[0, 0], [51, 52], [219, 204], [255, 255]]
          }
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return ChestFilter;
})(Filter);

module.exports = ChestFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js":[function(require,module,exports){
/* jshint unused: false */
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

/**
 * Base class for filters. Extendable via {@link ImglyKit.Filter#extend}
 * @class
 * @alias ImglyKit.Filter
 */
var Filter = (function () {
  function Filter() {}

  _prototypeProperties(Filter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return null;
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        /* istanbul ignore next */
        throw new Error("Filter#render is abstract and not implemented in inherited class.");
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Filter;
})();

/**
 * To create an {@link ImglyKit.Filter} class of your own, call this
 * method and provide instance properties and functions.
 * @function
 */
Filter.extend = require("../../lib/extend");

// Exposed classes
Filter.PrimitivesStack = require("./primitives-stack");
Filter.Primitives = {};
Filter.Primitives.Saturation = require("./primitives/saturation");
Filter.Primitives.LookupTable = require("./primitives/lookup-table");
Filter.Primitives.ToneCurve = require("./primitives/tone-curve");
Filter.Primitives.SoftColorOverlay = require("./primitives/soft-color-overlay");
Filter.Primitives.Desaturation = require("./primitives/desaturation");
Filter.Primitives.X400 = require("./primitives/x400");
Filter.Primitives.Grayscale = require("./primitives/grayscale");
Filter.Primitives.Contrast = require("./primitives/contrast");
Filter.Primitives.Glow = require("./primitives/glow");
Filter.Primitives.Gobblin = require("./primitives/gobblin");
Filter.Primitives.Brightness = require("./primitives/brightness");

module.exports = Filter;

},{"../../lib/extend":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/extend.js","./primitives-stack":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives-stack.js","./primitives/brightness":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/brightness.js","./primitives/contrast":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/contrast.js","./primitives/desaturation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/desaturation.js","./primitives/glow":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/glow.js","./primitives/gobblin":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/gobblin.js","./primitives/grayscale":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/grayscale.js","./primitives/lookup-table":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/lookup-table.js","./primitives/saturation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/saturation.js","./primitives/soft-color-overlay":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/soft-color-overlay.js","./primitives/tone-curve":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/tone-curve.js","./primitives/x400":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/x400.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/fixie-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Fixie Filter
 * @class
 * @alias ImglyKit.Filters.FixieFilter
 * @extends {ImglyKit.Filter}
 */
var FixieFilter = (function (Filter) {
  function FixieFilter() {
    if (Object.getPrototypeOf(FixieFilter) !== null) {
      Object.getPrototypeOf(FixieFilter).apply(this, arguments);
    }
  }

  _inherits(FixieFilter, Filter);

  _prototypeProperties(FixieFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "fixie";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        // Tone curve
        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 0], [44, 28], [63, 48], [128, 132], [235, 248], [255, 255]],
            green: [[0, 0], [20, 10], [60, 45], [190, 209], [211, 231], [255, 255]],
            blue: [[0, 31], [41, 62], [150, 142], [234, 212], [255, 224]]
          }
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return FixieFilter;
})(Filter);

module.exports = FixieFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/food-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Food Filter
 * @class
 * @alias ImglyKit.Filters.FoodFilter
 * @extends {ImglyKit.Filter}
 */
var FoodFilter = (function (Filter) {
  function FoodFilter() {
    if (Object.getPrototypeOf(FoodFilter) !== null) {
      Object.getPrototypeOf(FoodFilter).apply(this, arguments);
    }
  }

  _inherits(FoodFilter, Filter);

  _prototypeProperties(FoodFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "food";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        stack.add(new Filter.Primitives.Saturation({
          saturation: 1.35
        }));

        stack.add(new Filter.Primitives.Contrast({
          contrast: 1.1
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return FoodFilter;
})(Filter);

module.exports = FoodFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/fridge-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Fridge Filter
 * @class
 * @alias ImglyKit.Filters.FridgeFilter
 * @extends {ImglyKit.Filter}
 */
var FridgeFilter = (function (Filter) {
  function FridgeFilter() {
    if (Object.getPrototypeOf(FridgeFilter) !== null) {
      Object.getPrototypeOf(FridgeFilter).apply(this, arguments);
    }
  }

  _inherits(FridgeFilter, Filter);

  _prototypeProperties(FridgeFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "fridge";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        // Tone curve
        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 9], [21, 11], [45, 24], [255, 220]],
            green: [[0, 12], [21, 21], [42, 42], [150, 150], [170, 173], [255, 210]],
            blue: [[0, 28], [43, 72], [128, 185], [255, 220]]
          }
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return FridgeFilter;
})(Filter);

module.exports = FridgeFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/front-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Front Filter
 * @class
 * @alias ImglyKit.Filters.FrontFilter
 * @extends {ImglyKit.Filter}
 */
var FrontFilter = (function (Filter) {
  function FrontFilter() {
    if (Object.getPrototypeOf(FrontFilter) !== null) {
      Object.getPrototypeOf(FrontFilter).apply(this, arguments);
    }
  }

  _inherits(FrontFilter, Filter);

  _prototypeProperties(FrontFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "front";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        // Tone curve
        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 65], [28, 67], [67, 113], [125, 183], [187, 217], [255, 229]],
            green: [[0, 52], [42, 59], [104, 134], [169, 209], [255, 240]],
            blue: [[0, 52], [65, 68], [93, 104], [150, 153], [255, 198]]
          }
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return FrontFilter;
})(Filter);

module.exports = FrontFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/glam-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Glam Filter
 * @class
 * @alias ImglyKit.Filters.GlamFilter
 * @extends {ImglyKit.Filter}
 */
var GlamFilter = (function (Filter) {
  function GlamFilter() {
    if (Object.getPrototypeOf(GlamFilter) !== null) {
      Object.getPrototypeOf(GlamFilter).apply(this, arguments);
    }
  }

  _inherits(GlamFilter, Filter);

  _prototypeProperties(GlamFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "glam";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        stack.add(new Filter.Primitives.Contrast({
          contrast: 1.1
        }));

        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 0], [94, 74], [181, 205], [255, 255]],
            green: [[0, 0], [127, 127], [255, 255]],
            blue: [[0, 0], [102, 73], [227, 213], [255, 255]]
          }
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return GlamFilter;
})(Filter);

module.exports = GlamFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/gobblin-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Gobblin Filter
 * @class
 * @alias ImglyKit.Filters.GobblinFilter
 * @extends {ImglyKit.Filter}
 */
var GobblinFilter = (function (Filter) {
  function GobblinFilter() {
    if (Object.getPrototypeOf(GobblinFilter) !== null) {
      Object.getPrototypeOf(GobblinFilter).apply(this, arguments);
    }
  }

  _inherits(GobblinFilter, Filter);

  _prototypeProperties(GobblinFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "gobblin";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        stack.add(new Filter.Primitives.Gobblin());

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return GobblinFilter;
})(Filter);

module.exports = GobblinFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/identity-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Identity Filter
 * @class
 * @alias ImglyKit.Filters.IdentityFilter
 * @extends {ImglyKit.Filter}
 */
var IdentityFilter = (function (Filter) {
  function IdentityFilter() {
    if (Object.getPrototypeOf(IdentityFilter) !== null) {
      Object.getPrototypeOf(IdentityFilter).apply(this, arguments);
    }
  }

  _inherits(IdentityFilter, Filter);

  _prototypeProperties(IdentityFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "identity";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {},
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return IdentityFilter;
})(Filter);

module.exports = IdentityFilter;
// This is the identity filter, it doesn't have any effect.

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/k1-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * K1 Filter
 * @class
 * @alias ImglyKit.Filters.K1Filter
 * @extends {ImglyKit.Filter}
 */
var K1Filter = (function (Filter) {
  function K1Filter() {
    if (Object.getPrototypeOf(K1Filter) !== null) {
      Object.getPrototypeOf(K1Filter).apply(this, arguments);
    }
  }

  _inherits(K1Filter, Filter);

  _prototypeProperties(K1Filter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "k1";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        // Tone curve
        stack.add(new Filter.Primitives.ToneCurve({
          controlPoints: [[0, 0], [53, 32], [91, 80], [176, 205], [255, 255]]
        }));

        // Saturation
        stack.add(new Filter.Primitives.Saturation({
          saturation: 0.9
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return K1Filter;
})(Filter);

module.exports = K1Filter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/k2-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

var Color = _interopRequire(require("../../lib/color"));

/**
 * K2 Filter
 * @class
 * @alias ImglyKit.Filters.K2Filter
 * @extends {ImglyKit.Filter}
 */
var K2Filter = (function (Filter) {
  function K2Filter() {
    if (Object.getPrototypeOf(K2Filter) !== null) {
      Object.getPrototypeOf(K2Filter).apply(this, arguments);
    }
  }

  _inherits(K2Filter, Filter);

  _prototypeProperties(K2Filter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "k2";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        // Tone curve
        stack.add(new Filter.Primitives.ToneCurve({
          controlPoints: [[0, 0], [54, 33], [77, 82], [94, 103], [122, 126], [177, 193], [229, 232], [255, 255]]
        }));

        // Soft color overlay
        stack.add(new Filter.Primitives.SoftColorOverlay({
          color: new Color(40 / 255, 40 / 255, 40 / 255)
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return K2Filter;
})(Filter);

module.exports = K2Filter;

},{"../../lib/color":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/color.js","./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/k6-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * K6 Filter
 * @class
 * @alias ImglyKit.Filters.K6Filter
 * @extends {ImglyKit.Filter}
 */
var K6Filter = (function (Filter) {
  function K6Filter() {
    if (Object.getPrototypeOf(K6Filter) !== null) {
      Object.getPrototypeOf(K6Filter).apply(this, arguments);
    }
  }

  _inherits(K6Filter, Filter);

  _prototypeProperties(K6Filter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "k6";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        // Saturation
        stack.add(new Filter.Primitives.Saturation({
          saturation: 0.5
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return K6Filter;
})(Filter);

module.exports = K6Filter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/kdynamic-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * KDynamic Filter
 * @class
 * @alias ImglyKit.Filters.KDynamicFilter
 * @extends {ImglyKit.Filter}
 */
var KDynamicFilter = (function (Filter) {
  function KDynamicFilter() {
    if (Object.getPrototypeOf(KDynamicFilter) !== null) {
      Object.getPrototypeOf(KDynamicFilter).apply(this, arguments);
    }
  }

  _inherits(KDynamicFilter, Filter);

  _prototypeProperties(KDynamicFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "kdynamic";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        // Tone curve
        stack.add(new Filter.Primitives.ToneCurve({
          controlPoints: [[0, 0], [17, 27], [46, 69], [90, 112], [156, 200], [203, 243], [255, 255]]
        }));

        // Saturation
        stack.add(new Filter.Primitives.Saturation({
          saturation: 0.7
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return KDynamicFilter;
})(Filter);

module.exports = KDynamicFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/lenin-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Lenin Filter
 * @class
 * @alias ImglyKit.Filters.LeninFilter
 * @extends {ImglyKit.Filter}
 */
var LeninFilter = (function (Filter) {
  function LeninFilter() {
    if (Object.getPrototypeOf(LeninFilter) !== null) {
      Object.getPrototypeOf(LeninFilter).apply(this, arguments);
    }
  }

  _inherits(LeninFilter, Filter);

  _prototypeProperties(LeninFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "lenin";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        // Desaturation
        stack.add(new Filter.Primitives.Desaturation({
          desaturation: 0.4
        }));

        // Tone curve
        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 20], [40, 20], [106, 111], [129, 153], [190, 223], [255, 255]],
            green: [[0, 20], [40, 20], [62, 41], [106, 108], [132, 159], [203, 237], [255, 255]],
            blue: [[0, 40], [40, 40], [73, 60], [133, 160], [191, 297], [203, 237], [237, 239], [255, 255]]
          }
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return LeninFilter;
})(Filter);

module.exports = LeninFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/lomo-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Lomo Filter
 * @class
 * @alias ImglyKit.Filters.LomoFilter
 * @extends {ImglyKit.Filter}
 */
var LomoFilter = (function (Filter) {
  function LomoFilter() {
    if (Object.getPrototypeOf(LomoFilter) !== null) {
      Object.getPrototypeOf(LomoFilter).apply(this, arguments);
    }
  }

  _inherits(LomoFilter, Filter);

  _prototypeProperties(LomoFilter, {
    identifier: {

      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "lomo";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        stack.add(new Filter.Primitives.ToneCurve({
          controlPoints: [[0, 0], [87, 20], [131, 156], [183, 205], [255, 200]]
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return LomoFilter;
})(Filter);

module.exports = LomoFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/mellow-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Mellow Filter
 * @class
 * @alias ImglyKit.Filters.MellowFilter
 * @extends {ImglyKit.Filter}
 */
var MellowFilter = (function (Filter) {
  function MellowFilter() {
    if (Object.getPrototypeOf(MellowFilter) !== null) {
      Object.getPrototypeOf(MellowFilter).apply(this, arguments);
    }
  }

  _inherits(MellowFilter, Filter);

  _prototypeProperties(MellowFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "mellow";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 0], [41, 84], [87, 134], [255, 255]],
            green: [[0, 0], [255, 216]],
            blue: [[0, 0], [255, 131]]
          }
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return MellowFilter;
})(Filter);

module.exports = MellowFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/morning-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Morning Filter
 * @class
 * @alias ImglyKit.Filters.MorningFilter
 * @extends {ImglyKit.Filter}
 */
var MorningFilter = (function (Filter) {
  function MorningFilter() {
    if (Object.getPrototypeOf(MorningFilter) !== null) {
      Object.getPrototypeOf(MorningFilter).apply(this, arguments);
    }
  }

  _inherits(MorningFilter, Filter);

  _prototypeProperties(MorningFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "morning";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 40], [255, 230]],
            green: [[0, 10], [255, 225]],
            blue: [[0, 20], [255, 181]]
          }
        }));

        stack.add(new Filter.Primitives.Glow());

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return MorningFilter;
})(Filter);

module.exports = MorningFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/orchid-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Orchid Filter
 * @class
 * @alias ImglyKit.Filters.OrchidFilter
 * @extends {ImglyKit.Filter}
 */
var OrchidFilter = (function (Filter) {
  function OrchidFilter() {
    if (Object.getPrototypeOf(OrchidFilter) !== null) {
      Object.getPrototypeOf(OrchidFilter).apply(this, arguments);
    }
  }

  _inherits(OrchidFilter, Filter);

  _prototypeProperties(OrchidFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "orchid";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        // Tone curve
        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 0], [115, 130], [195, 215], [255, 255]],
            green: [[0, 0], [148, 153], [172, 215], [255, 255]],
            blue: [[0, 46], [58, 75], [178, 205], [255, 255]]
          }
        }));

        // Tone curve
        stack.add(new Filter.Primitives.ToneCurve({
          controlPoints: [[0, 0], [117, 151], [189, 217], [255, 255]]
        }));

        // Desaturation
        stack.add(new Filter.Primitives.Desaturation({
          desaturation: 0.65
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return OrchidFilter;
})(Filter);

module.exports = OrchidFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/pola-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Pola Filter
 * @class
 * @alias ImglyKit.Filters.PolaFilter
 * @extends {ImglyKit.Filter}
 */
var PolaFilter = (function (Filter) {
  function PolaFilter() {
    if (Object.getPrototypeOf(PolaFilter) !== null) {
      Object.getPrototypeOf(PolaFilter).apply(this, arguments);
    }
  }

  _inherits(PolaFilter, Filter);

  _prototypeProperties(PolaFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "pola";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 0], [94, 74], [181, 205], [255, 255]],
            green: [[0, 0], [34, 34], [99, 76], [176, 190], [255, 255]],
            blue: [[0, 0], [102, 73], [227, 213], [255, 255]]
          }
        }));

        stack.add(new Filter.Primitives.Saturation({
          saturation: 0.8
        }));

        stack.add(new Filter.Primitives.Contrast({
          contrast: 1.5
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return PolaFilter;
})(Filter);

module.exports = PolaFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/pola669-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Pola669 Filter
 * @class
 * @alias ImglyKit.Filters.Pola669Filter
 * @extends {ImglyKit.Filter}
 */
var Pola669Filter = (function (Filter) {
  function Pola669Filter() {
    if (Object.getPrototypeOf(Pola669Filter) !== null) {
      Object.getPrototypeOf(Pola669Filter).apply(this, arguments);
    }
  }

  _inherits(Pola669Filter, Filter);

  _prototypeProperties(Pola669Filter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "pola669";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 0], [56, 18], [196, 209], [255, 255]],
            green: [[0, 38], [71, 84], [255, 255]],
            blue: [[0, 0], [131, 133], [204, 211], [255, 255]]
          }
        }));

        stack.add(new Filter.Primitives.Saturation({
          saturation: 0.8
        }));

        stack.add(new Filter.Primitives.Contrast({
          contrast: 1.5
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Pola669Filter;
})(Filter);

module.exports = Pola669Filter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives-stack.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

/**
 * A helper class that can collect {@link Primitive} instances and render
 * the stack
 * @class
 * @alias ImglyKit.Filter.PrimitivesStack
 */
var PrimitivesStack = (function () {
  function PrimitivesStack() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _get(Object.getPrototypeOf(PrimitivesStack.prototype), "constructor", this).apply(this, args);

    /**
     * The stack of {@link ImglyKit.Filter.Primitive} instances
     * @type {Array}
     * @private
     */
    this._stack = [];
  }

  _prototypeProperties(PrimitivesStack, null, {
    add: {

      /**
       * Adds the given primitive to the stack
       * @param {ImglyKit.Filter.Primitive} primitive
       */
      value: function add(primitive) {
        this._stack.push(primitive);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    render: {

      /**
       * Renders the stack of primitives on the renderer
       * @param  {Renderer} renderer
       */
      value: function render(renderer) {
        for (var i = 0; i < this._stack.length; i++) {
          var primitive = this._stack[i];
          primitive.render(renderer);
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return PrimitivesStack;
})();

module.exports = PrimitivesStack;

},{}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/brightness.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var _ = _interopRequire(require("lodash"));

var Primitive = _interopRequire(require("./primitive"));

/**
 * Brightness primitive
 * @class
 * @alias ImglyKit.Filter.Primitives.Brightness
 * @extends {ImglyKit.Filter.Primitive}
 */
var Brightness = (function (Primitive) {
  function Brightness() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _get(Object.getPrototypeOf(Brightness.prototype), "constructor", this).apply(this, args);

    this._options = _.defaults(this._options, {
      brightness: 1
    });

    /**
     * The fragment shader for this primitive
     * @return {String}
     * @private
     */
    this._fragmentShader = "\n\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform float u_brightness;\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n        gl_FragColor = vec4((texColor.rgb + vec3(u_brightness)), texColor.a);\n      }\n\n    ";
  }

  _inherits(Brightness, Primitive);

  _prototypeProperties(Brightness, null, {
    renderWebGL: {

      /**
       * Renders the primitive (WebGL)
       * @param  {WebGLRenderer} renderer
       */
      /* istanbul ignore next */
      value: function renderWebGL(renderer) {
        renderer.runShader(null, this._fragmentShader, {
          uniforms: {
            u_brightness: { type: "f", value: this._options.brightness }
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    renderCanvas: {

      /**
       * Renders the primitive (Canvas)
       * @param  {CanvasRenderer} renderer
       */
      value: function renderCanvas(renderer) {
        var canvas = renderer.getCanvas();
        var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);
        var brightness = this._options.brightness;

        for (var x = 0; x < canvas.width; x++) {
          for (var y = 0; y < canvas.height; y++) {
            var index = (canvas.width * y + x) * 4;

            imageData.data[index] = imageData.data[index] + brightness * 255;
            imageData.data[index + 1] = imageData.data[index + 1] + brightness * 255;
            imageData.data[index + 2] = imageData.data[index + 2] + brightness * 255;
          }
        }

        renderer.getContext().putImageData(imageData, 0, 0);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Brightness;
})(Primitive);

module.exports = Brightness;

},{"./primitive":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/primitive.js","lodash":"lodash"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/contrast.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var _ = _interopRequire(require("lodash"));

var Primitive = _interopRequire(require("./primitive"));

/**
 * Contrast primitive
 * @class
 * @alias ImglyKit.Filter.Primitives.Contrast
 * @extends {ImglyKit.Filter.Primitive}
 */
var Contrast = (function (Primitive) {
  function Contrast() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _get(Object.getPrototypeOf(Contrast.prototype), "constructor", this).apply(this, args);

    this._options = _.defaults(this._options, {
      contrast: 1
    });

    /**
     * The fragment shader for this primitive
     * @return {String}
     * @private
     */
    this._fragmentShader = "\n\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform float u_contrast;\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n        gl_FragColor = vec4(((texColor.rgb - vec3(0.5)) * u_contrast + vec3(0.5)), texColor.a);\n      }\n\n    ";
  }

  _inherits(Contrast, Primitive);

  _prototypeProperties(Contrast, null, {
    renderWebGL: {

      /**
       * Renders the primitive (WebGL)
       * @param  {WebGLRenderer} renderer
       */
      /* istanbul ignore next */
      value: function renderWebGL(renderer) {
        renderer.runShader(null, this._fragmentShader, {
          uniforms: {
            u_contrast: { type: "f", value: this._options.contrast }
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    renderCanvas: {

      /**
       * Renders the primitive (Canvas)
       * @param  {CanvasRenderer} renderer
       */
      value: function renderCanvas(renderer) {
        var canvas = renderer.getCanvas();
        var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);
        var contrast = this._options.contrast;

        for (var x = 0; x < canvas.width; x++) {
          for (var y = 0; y < canvas.height; y++) {
            var index = (canvas.width * y + x) * 4;

            imageData.data[index] = (imageData.data[index] - 127) * contrast + 127;
            imageData.data[index + 1] = (imageData.data[index + 1] - 127) * contrast + 127;
            imageData.data[index + 2] = (imageData.data[index + 2] - 127) * contrast + 127;
          }
        }

        renderer.getContext().putImageData(imageData, 0, 0);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Contrast;
})(Primitive);

module.exports = Contrast;

},{"./primitive":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/primitive.js","lodash":"lodash"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/desaturation.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var _ = _interopRequire(require("lodash"));

var Primitive = _interopRequire(require("./primitive"));

/**
 * Desaturation primitive
 * @class
 * @alias ImglyKit.Filter.Primitives.Desaturation
 * @extends {ImglyKit.Filter.Primitive}
 */
var Desaturation = (function (Primitive) {
  function Desaturation() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _get(Object.getPrototypeOf(Desaturation.prototype), "constructor", this).apply(this, args);

    this._options = _.defaults(this._options, {
      desaturation: 1
    });

    /**
     * The fragment shader for this primitive
     * @return {String}
     * @private
     */
    this._fragmentShader = "\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform float u_desaturation;\n\n      const vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\n      void main() {\n        vec3 texColor = texture2D(u_image, v_texCoord).xyz;\n        vec3 grayXfer = vec3(0.3, 0.59, 0.11);\n        vec3 gray = vec3(dot(grayXfer, texColor));\n        gl_FragColor = vec4(mix(texColor, gray, u_desaturation), 1.0);\n      }\n    ";
  }

  _inherits(Desaturation, Primitive);

  _prototypeProperties(Desaturation, null, {
    renderWebGL: {

      /**
       * Renders the primitive (WebGL)
       * @param  {WebGLRenderer} renderer
       * @return {Promise}
       */
      /* istanbul ignore next */
      value: function renderWebGL(renderer) {
        renderer.runShader(null, this._fragmentShader, {
          uniforms: {
            u_desaturation: { type: "f", value: this._options.desaturation }
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    renderCanvas: {

      /**
       * Renders the primitive (Canvas)
       * @param  {CanvasRenderer} renderer
       */
      value: function renderCanvas(renderer) {
        var canvas = renderer.getCanvas();
        var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);
        var desaturation = this._options.desaturation;

        for (var x = 0; x < canvas.width; x++) {
          for (var y = 0; y < canvas.height; y++) {
            var index = (canvas.width * y + x) * 4;

            var luminance = imageData.data[index] * 0.3 + imageData.data[index + 1] * 0.59 + imageData.data[index + 2] * 0.11;
            imageData.data[index] = luminance * (1 - desaturation) + imageData.data[index] * desaturation;
            imageData.data[index + 1] = luminance * (1 - desaturation) + imageData.data[index + 1] * desaturation;
            imageData.data[index + 2] = luminance * (1 - desaturation) + imageData.data[index + 2] * desaturation;
          }
        }

        renderer.getContext().putImageData(imageData, 0, 0);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Desaturation;
})(Primitive);

module.exports = Desaturation;

},{"./primitive":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/primitive.js","lodash":"lodash"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/glow.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var _ = _interopRequire(require("lodash"));

var Primitive = _interopRequire(require("./primitive"));

var Color = _interopRequire(require("../../../lib/color"));

/**
 * Glow primitive
 * @class
 * @alias ImglyKit.Filter.Primitives.Glow
 * @extends {ImglyKit.Filter.Primitive}
 */
var Glow = (function (Primitive) {
  function Glow() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _get(Object.getPrototypeOf(Glow.prototype), "constructor", this).apply(this, args);

    this._options = _.defaults(this._options, {
      color: new Color(1, 1, 1)
    });

    /**
     * The fragment shader for this primitive
     * @return {String}
     * @private
     */
    this._fragmentShader = "\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n\n      uniform vec3 u_color;\n\n      void main() {\n        vec3 texColor = texture2D(u_image, v_texCoord).rgb;\n\n        vec2 textureCoord = v_texCoord - vec2(0.5, 0.5);\n        textureCoord /= 0.75;\n\n        float d = 1.0 - dot(textureCoord, textureCoord);\n        d = clamp(d, 0.2, 1.0);\n        vec3 newColor = texColor * d * u_color.rgb;\n        gl_FragColor = vec4(vec3(newColor),1.0);\n      }\n    ";
  }

  _inherits(Glow, Primitive);

  _prototypeProperties(Glow, null, {
    renderWebGL: {

      /**
       * Renders the primitive (WebGL)
       * @param  {WebGLRenderer} renderer
       * @return {Promise}
       */
      /* istanbul ignore next */
      value: function renderWebGL(renderer) {
        renderer.runShader(null, this._fragmentShader, {
          uniforms: {
            u_color: { type: "3f", value: this._options.color.toRGBGLColor() }
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    renderCanvas: {

      /**
       * Renders the primitive (Canvas)
       * @param  {CanvasRenderer} renderer
       * @return {Promise}
       */
      value: function renderCanvas(renderer) {
        var canvas = renderer.getCanvas();
        var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);
        var color = this._options.color;

        var d;
        for (var x = 0; x < canvas.width; x++) {
          for (var y = 0; y < canvas.height; y++) {
            var index = (canvas.width * y + x) * 4;

            var x01 = x / canvas.width;
            var y01 = y / canvas.height;

            var nx = (x01 - 0.5) / 0.75;
            var ny = (y01 - 0.5) / 0.75;

            var scalarX = nx * nx;
            var scalarY = ny * ny;
            d = 1 - (scalarX + scalarY);
            d = Math.min(Math.max(d, 0.1), 1);

            imageData.data[index] = imageData.data[index] * (d * color[0] / 255);
            imageData.data[index + 1] = imageData.data[index + 1] * (d * color[1] / 255);
            imageData.data[index + 2] = imageData.data[index + 2] * (d * color[2] / 255);
            imageData.data[index + 3] = 255;
          }
        }

        renderer.getContext().putImageData(imageData, 0, 0);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Glow;
})(Primitive);

module.exports = Glow;

},{"../../../lib/color":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/color.js","./primitive":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/primitive.js","lodash":"lodash"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/gobblin.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Primitive = _interopRequire(require("./primitive"));

/**
 * Gobblin primitive
 * @class
 * @alias ImglyKit.Filter.Primitives.Gobblin
 * @extends {ImglyKit.Filter.Primitive}
 */
var Gobblin = (function (Primitive) {
  function Gobblin() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _get(Object.getPrototypeOf(Gobblin.prototype), "constructor", this).apply(this, args);

    /**
     * The fragment shader for this primitive
     * @return {String}
     * @private
     */
    this._fragmentShader = "\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n        texColor.b = texColor.g * 0.33;\n        texColor.r = texColor.r * 0.6;\n        texColor.b += texColor.r * 0.33;\n        texColor.g = texColor.g * 0.7;\n        gl_FragColor = texColor;\n      }\n    ";
  }

  _inherits(Gobblin, Primitive);

  _prototypeProperties(Gobblin, null, {
    renderWebGL: {

      /**
       * Renders the primitive (WebGL)
       * @param  {WebGLRenderer} renderer
       * @return {Promise}
       */
      /* istanbul ignore next */
      value: function renderWebGL(renderer) {
        renderer.runShader(null, this._fragmentShader);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    renderCanvas: {

      /**
       * Renders the primitive (Canvas)
       * @param  {CanvasRenderer} renderer
       */
      value: function renderCanvas(renderer) {
        var canvas = renderer.getCanvas();
        var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);

        for (var x = 0; x < canvas.width; x++) {
          for (var y = 0; y < canvas.height; y++) {
            var index = (canvas.width * y + x) * 4;

            imageData.data[index + 2] = imageData.data[index + 1] * 0.33;
            imageData.data[index] = imageData.data[index] * 0.6;
            imageData.data[index + 2] += imageData.data[index] * 0.33;
            imageData.data[index + 1] = imageData.data[index + 1] * 0.7;
            imageData.data[index + 3] = 255;
          }
        }

        renderer.getContext().putImageData(imageData, 0, 0);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Gobblin;
})(Primitive);

module.exports = Gobblin;

},{"./primitive":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/primitive.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/grayscale.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Primitive = _interopRequire(require("./primitive"));

/**
 * Grayscale primitive
 * @class
 * @alias ImglyKit.Filter.Primitives.Grayscale
 * @extends {ImglyKit.Filter.Primitive}
 */
var Grayscale = (function (Primitive) {
  function Grayscale() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _get(Object.getPrototypeOf(Grayscale.prototype), "constructor", this).apply(this, args);

    /**
     * The fragment shader for this primitive
     * @return {String}
     * @private
     */
    this._fragmentShader = "\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\n      void main() {\n        vec3 texColor = texture2D(u_image, v_texCoord).rgb;\n        float luminance = dot(texColor, W);\n        gl_FragColor = vec4(vec3(luminance), 1.0);\n      }\n    ";
  }

  _inherits(Grayscale, Primitive);

  _prototypeProperties(Grayscale, null, {
    renderWebGL: {

      /**
       * Renders the primitive (WebGL)
       * @param  {WebGLRenderer} renderer
       * @return {Promise}
       */
      /* istanbul ignore next */
      value: function renderWebGL(renderer) {
        renderer.runShader(null, this._fragmentShader);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    renderCanvas: {

      /**
       * Renders the primitive (Canvas)
       * @param  {CanvasRenderer} renderer
       */
      value: function renderCanvas(renderer) {
        var canvas = renderer.getCanvas();
        var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);

        for (var x = 0; x < canvas.width; x++) {
          for (var y = 0; y < canvas.height; y++) {
            var index = (canvas.width * y + x) * 4;

            var luminance = imageData.data[index] * 0.2125 + imageData.data[index + 1] * 0.7154 + imageData.data[index + 2] * 0.0721;

            imageData.data[index] = luminance;
            imageData.data[index + 1] = luminance;
            imageData.data[index + 2] = luminance;
          }
        }

        renderer.getContext().putImageData(imageData, 0, 0);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Grayscale;
})(Primitive);

module.exports = Grayscale;

},{"./primitive":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/primitive.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/lookup-table.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Primitive = _interopRequire(require("./primitive"));

/**
 * Stores a 256 byte long lookup table in a 2d texture which will be
 * used to look up the corresponding value for each channel.
 * @class
 * @alias ImglyKit.Filter.Primitives.LookupTable
 * @extends {ImglyKit.Filter.Primitive}
 */
var LookupTable = (function (Primitive) {
  function LookupTable() {
    Primitive.apply(this, arguments);

    this._textureIndex = 3;

    /**
     * The fragment shader for this primitive
     * @return {String}
     * @private
     */
    this._fragmentShader = "\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform sampler2D u_lookupTable;\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n        float r = texture2D(u_lookupTable, vec2(texColor.r, 0.0)).r;\n        float g = texture2D(u_lookupTable, vec2(texColor.g, 0.0)).g;\n        float b = texture2D(u_lookupTable, vec2(texColor.b, 0.0)).b;\n\n        gl_FragColor = vec4(r, g, b, texColor.a);\n      }\n    ";
  }

  _inherits(LookupTable, Primitive);

  _prototypeProperties(LookupTable, null, {
    renderWebGL: {

      /**
       * Renders the primitive (WebGL)
       * @param  {WebGLRenderer} renderer
       */
      /* istanbul ignore next */
      value: function renderWebGL(renderer) {
        this._updateTexture(renderer);

        renderer.runShader(null, this._fragmentShader, {
          uniforms: {
            u_lookupTable: { type: "i", value: 3 }
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    renderCanvas: {

      /**
       * Renders the primitive (Canvas)
       * @param  {CanvasRenderer} renderer
       */
      value: function renderCanvas(renderer) {
        var canvas = renderer.getCanvas();
        var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);
        var table = this._options.data;

        for (var x = 0; x < canvas.width; x++) {
          for (var y = 0; y < canvas.height; y++) {
            var index = (canvas.width * y + x) * 4;

            var r = imageData.data[index];
            imageData.data[index] = table[r * 4];
            var g = imageData.data[index + 1];
            imageData.data[index + 1] = table[1 + g * 4];
            var b = imageData.data[index + 2];
            imageData.data[index + 2] = table[2 + b * 4];
          }
        }

        renderer.getContext().putImageData(imageData, 0, 0);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _updateTexture: {

      /**
       * Updates the lookup table texture (WebGL only)
       * @private
       */
      /* istanbul ignore next */
      value: function UpdateTexture(renderer) {
        var gl = renderer.getContext();

        if (typeof this._options.data === "undefined") {
          throw new Error("LookupTable: No data specified.");
        }

        var dataTypedArray = new Uint8Array(this._options.data);

        gl.activeTexture(gl.TEXTURE0 + this._textureIndex);
        if (!this._texture) {
          this._texture = gl.createTexture();
        }
        gl.bindTexture(gl.TEXTURE_2D, this._texture);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, dataTypedArray);
        gl.activeTexture(gl.TEXTURE0);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return LookupTable;
})(Primitive);

module.exports = LookupTable;

},{"./primitive":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/primitive.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/primitive.js":[function(require,module,exports){
/* jshint unused: false */
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

/**
 * Base class for primitives. Extendable via {@link ImglyKit.Filter.Primitive#extend}
 * @class
 * @alias ImglyKit.Filter.Primitive
 */
var Primitive = (function () {
  function Primitive(options) {
    options = options || {};

    this._options = options;
  }

  _prototypeProperties(Primitive, null, {
    render: {

      /**
       * Renders the primitive
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        if (renderer.identifier === "webgl") {
          this.renderWebGL(renderer);
        } else {
          this.renderCanvas(renderer);
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    renderWebGL: {

      /**
       * Renders the primitive (WebGL)
       * @param  {CanvasRenderer} renderer
       */
      /* istanbul ignore next */
      value: function renderWebGL(renderer) {
        /* istanbul ignore next */
        throw new Error("Primitive#renderWebGL is abstract and not implemented in inherited class.");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    renderCanvas: {

      /**
       * Renders the primitive (Canvas2D)
       * @param  {CanvasRenderer} renderer
       */
      value: function renderCanvas(renderer) {
        /* istanbul ignore next */
        throw new Error("Primitive#renderCanvas is abstract and not implemented in inherited class.");
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Primitive;
})();

module.exports = Primitive;

},{}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/saturation.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var _ = _interopRequire(require("lodash"));

var Primitive = _interopRequire(require("./primitive"));

/**
 * Saturation primitive
 * @class
 * @alias ImglyKit.Filter.Primitives.Saturation
 * @extends {ImglyKit.Filter.Primitive}
 */
var Saturation = (function (Primitive) {
  function Saturation() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _get(Object.getPrototypeOf(Saturation.prototype), "constructor", this).apply(this, args);

    this._options = _.defaults(this._options, {
      saturation: 0
    });

    /**
     * The fragment shader for this primitive
     * @return {String}
     * @private
     */
    this._fragmentShader = "\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform float u_saturation;\n\n      const vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n        float luminance = dot(texColor.rgb, luminanceWeighting);\n\n        vec3 greyScaleColor = vec3(luminance);\n\n        gl_FragColor = vec4(mix(greyScaleColor, texColor.rgb, u_saturation), texColor.a);\n      }\n    ";
  }

  _inherits(Saturation, Primitive);

  _prototypeProperties(Saturation, null, {
    renderWebGL: {

      /**
       * Renders the primitive (WebGL)
       * @param  {WebGLRenderer} renderer
       */
      /* istanbul ignore next */
      value: function renderWebGL(renderer) {
        renderer.runShader(null, this._fragmentShader, {
          uniforms: {
            u_saturation: { type: "f", value: this._options.saturation }
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    renderCanvas: {

      /**
       * Renders the primitive (Canvas)
       * @param  {CanvasRenderer} renderer
       * @return {Promise}
       */
      value: function renderCanvas(renderer) {
        var canvas = renderer.getCanvas();
        var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);
        var saturation = this._options.saturation;

        var d;
        for (var x = 0; x < canvas.width; x++) {
          for (var y = 0; y < canvas.height; y++) {
            var index = (canvas.width * y + x) * 4;

            var luminance = imageData.data[index] * 0.2125 + imageData.data[index + 1] * 0.7154 + imageData.data[index + 2] * 0.0721;
            imageData.data[index] = luminance * (1 - saturation) + imageData.data[index] * saturation;
            imageData.data[index + 1] = luminance * (1 - saturation) + imageData.data[index + 1] * saturation;
            imageData.data[index + 2] = luminance * (1 - saturation) + imageData.data[index + 2] * saturation;
          }
        }

        renderer.getContext().putImageData(imageData, 0, 0);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Saturation;
})(Primitive);

module.exports = Saturation;

},{"./primitive":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/primitive.js","lodash":"lodash"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/soft-color-overlay.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var _ = _interopRequire(require("lodash"));

var Primitive = _interopRequire(require("./primitive"));

var Color = _interopRequire(require("../../../lib/color"));

/**
 * SoftColorOverlay primitive
 * @class
 * @alias ImglyKit.Filter.Primitives.SoftColorOverlay
 * @extends {ImglyKit.Filter.Primitive}
 */
var SoftColorOverlay = (function (Primitive) {
  function SoftColorOverlay() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _get(Object.getPrototypeOf(SoftColorOverlay.prototype), "constructor", this).apply(this, args);

    this._options = _.defaults(this._options, {
      color: new Color(1, 1, 1)
    });

    /**
     * The fragment shader for this primitive
     * @return {String}
     * @private
     */
    this._fragmentShader = "\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform vec3 u_overlay;\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n        vec4 overlayVec4 = vec4(u_overlay, texColor.a);\n        gl_FragColor = max(overlayVec4, texColor);\n      }\n    ";
  }

  _inherits(SoftColorOverlay, Primitive);

  _prototypeProperties(SoftColorOverlay, null, {
    renderWebGL: {

      /**
       * Renders the primitive (WebGL)
       * @param  {WebGLRenderer} renderer
       */
      /* istanbul ignore next */
      value: function renderWebGL(renderer) {
        renderer.runShader(null, this._fragmentShader, {
          uniforms: {
            u_overlay: { type: "3f", value: this._options.color.toRGBGLColor() }
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    renderCanvas: {

      /**
       * Renders the primitive (Canvas)
       * @param  {CanvasRenderer} renderer
       */
      value: function renderCanvas(renderer) {
        var canvas = renderer.getCanvas();
        var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);

        for (var x = 0; x < canvas.width; x++) {
          for (var y = 0; y < canvas.height; y++) {
            var index = (canvas.width * y + x) * 4;

            imageData.data[index] = Math.max(this._options.color.r, imageData.data[index]);
            imageData.data[index + 1] = Math.max(this._options.color.g, imageData.data[index + 1]);
            imageData.data[index + 2] = Math.max(this._options.color.b, imageData.data[index + 2]);
          }
        }

        renderer.getContext().putImageData(imageData, 0, 0);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return SoftColorOverlay;
})(Primitive);

module.exports = SoftColorOverlay;

},{"../../../lib/color":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/color.js","./primitive":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/primitive.js","lodash":"lodash"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/tone-curve.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var _ = _interopRequire(require("lodash"));

var LookupTable = _interopRequire(require("./lookup-table"));

/**
 * Tone curve primitive
 * @class
 * @alias ImglyKit.Filter.Primitives.ToneCurve
 * @extends {ImglyKit.Filter.Primitives.LookupTable}
 */
var ToneCurve = (function (LookupTable) {
  function ToneCurve() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _get(Object.getPrototypeOf(ToneCurve.prototype), "constructor", this).apply(this, args);

    this._options = _.defaults(this._options, {
      rgbControlPoints: {
        red: this._options.controlPoints,
        green: this._options.controlPoints,
        blue: this._options.controlPoints
      }
    });

    if (typeof this._options.rgbControlPoints !== "undefined") {
      this._updateLookupTable();
    }
  }

  _inherits(ToneCurve, LookupTable);

  _prototypeProperties(ToneCurve, null, {
    _updateLookupTable: {

      /**
       * Calculates the lookup table
       * @private
       */
      value: function UpdateLookupTable() {
        var r = this._calculateSplineCurve(this._options.rgbControlPoints.red);
        var g = this._calculateSplineCurve(this._options.rgbControlPoints.green);
        var b = this._calculateSplineCurve(this._options.rgbControlPoints.blue);

        this._options.data = this._buildLookupTable(r, g, b);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _buildLookupTable: {

      /**
       * Builds the lookup table
       * @param  {Array} r
       * @param  {Array} g
       * @param  {Array} b
       * @return {Array}
       * @private
       */
      value: function BuildLookupTable(r, g, b) {
        var data = [];

        for (var i = 0; i < 256; i++) {
          data.push(Math.min(Math.max(i + r[i], 0), 255));
          data.push(Math.min(Math.max(i + g[i], 0), 255));
          data.push(Math.min(Math.max(i + b[i], 0), 255));
          data.push(255);
        }

        return data;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _calculateSplineCurve: {

      /**
       * Calculates the spline curve data for the given points
       * @param  {Array.<Array.<Number>>} points
       * @return {Array.<Number>}
       */
      value: function CalculateSplineCurve(points) {
        points = points.sort(function (a, b) {
          return a[0] > b[0];
        });

        var splinePoints = this._getSplineCurve(points);
        var firstSplinePoint = splinePoints[0];
        var i;

        if (firstSplinePoint[0] > 0) {
          for (i = 0; i < firstSplinePoint[0]; i++) {
            splinePoints.unshift([0, 0]);
          }
        }

        var preparedPoints = [];
        for (i = 0; i < splinePoints.length; i++) {
          var newPoint = splinePoints[i];
          var origPoint = [newPoint[0], newPoint[0]];

          var distance = Math.sqrt(Math.pow(origPoint[0] - newPoint[0], 2) + Math.pow(origPoint[1] - newPoint[1], 2));

          if (origPoint[1] > newPoint[1]) {
            distance = -distance;
          }

          preparedPoints.push(distance);
        }

        return preparedPoints;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _getSplineCurve: {
      value: function GetSplineCurve(points) {
        var sdA = this._secondDerivative(points);

        var n = sdA.length;
        var sd = [];
        var i;

        for (i = 0; i < n; i++) {
          sd[i] = sdA[i];
        }

        var output = [];

        for (i = 0; i < n - 1; i++) {
          var cur = points[i];
          var next = points[i + 1];

          for (var x = cur[0]; x < next[0]; x++) {
            var t = (x - cur[0]) / (next[0] - cur[0]);

            var a = 1 - t;
            var b = t;
            var h = next[0] - cur[0];

            var y = a * cur[1] + b * next[1] + h * h / 6 * ((a * a * a - a) * sd[i] + (b * b * b - b) * sd[i + 1]);

            if (y > 255) {
              y = 255;
            } else if (y < 0) {
              y = 0;
            }

            output.push([x, y]);
          }
        }

        if (output.length === 255) {
          output.push(points[points.length - 1]);
        }

        return output;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _secondDerivative: {
      value: function SecondDerivative(points) {
        var n = points.length;
        if (n <= 0 || n === 1) {
          return null;
        }

        var matrix = [];
        var result = [];
        var i, k;

        matrix[0] = [0, 1, 0];

        for (i = 1; i < n - 1; i++) {
          var P1 = points[i - 1];
          var P2 = points[i];
          var P3 = points[i + 1];

          matrix[i] = matrix[i] || [];
          matrix[i][0] = (P2[0] - P1[0]) / 6;
          matrix[i][1] = (P3[0] - P1[0]) / 3;
          matrix[i][2] = (P3[0] - P2[0]) / 6;
          result[i] = (P3[1] - P2[1]) / (P3[0] - P2[0]) - (P2[1] - P1[1]) / (P2[0] - P1[0]);
        }

        result[0] = 0;
        result[n - 1] = 0;

        matrix[n - 1] = [0, 1, 0];

        // Pass 1
        for (i = 1; i < n; i++) {
          k = matrix[1][0] / matrix[i - 1][1];
          matrix[i][1] -= k * matrix[i - 1][2];
          matrix[i][0] = 0;
          result[i] -= k * result[i - 1];
        }

        // Pass 2
        for (i = n - 2; i > 0; i--) {
          k = matrix[i][2] / matrix[i + 1][1];
          matrix[i][1] -= k * matrix[i + 1][0];
          matrix[i][2] = 0;
          result[i] -= k * result[i + 1];
        }

        var y2 = [];
        for (i = 0; i < n; i++) {
          y2[i] = result[i] / matrix[i][1];
        }

        return y2;
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return ToneCurve;
})(LookupTable);

module.exports = ToneCurve;

},{"./lookup-table":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/lookup-table.js","lodash":"lodash"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/x400.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Primitive = _interopRequire(require("./primitive"));

/**
 * X400 primitive
 * @class
 * @alias ImglyKit.Filter.Primitives.X400
 * @extends {ImglyKit.Filter.Primitive}
 */
var X400 = (function (Primitive) {
  function X400() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _get(Object.getPrototypeOf(X400.prototype), "constructor", this).apply(this, args);

    /**
     * The fragment shader for this primitive
     * @return {String}
     * @private
     */
    this._fragmentShader = "\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n        float gray = texColor.r * 0.3 + texColor.g * 0.3 + texColor.b * 0.3;\n        gray -= 0.2;\n        gray = clamp(gray, 0.0, 1.0);\n        gray += 0.15;\n        gray *= 1.4;\n        gl_FragColor = vec4(vec3(gray), 1.0);\n      }\n    ";
  }

  _inherits(X400, Primitive);

  _prototypeProperties(X400, null, {
    renderWebGL: {

      /**
       * Renders the primitive (WebGL)
       * @param  {WebGLRenderer} renderer
       */
      /* istanbul ignore next */
      value: function renderWebGL(renderer) {
        renderer.runShader(null, this._fragmentShader);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    renderCanvas: {

      /**
       * Renders the primitive (Canvas)
       * @param  {CanvasRenderer} renderer
       */
      value: function renderCanvas(renderer) {
        var canvas = renderer.getCanvas();
        var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);

        for (var x = 0; x < canvas.width; x++) {
          for (var y = 0; y < canvas.height; y++) {
            var index = (canvas.width * y + x) * 4;

            var gray = imageData.data[index] / 255 * 0.3 + imageData.data[index + 1] / 255 * 0.3 + imageData.data[index + 2] / 255 * 0.3;
            gray -= 0.2;
            gray = Math.max(0, Math.min(1, gray));
            gray += 0.15;
            gray *= 1.4;

            gray *= 255;
            imageData.data[index] = gray;
            imageData.data[index + 1] = gray;
            imageData.data[index + 2] = gray;
          }
        }

        renderer.getContext().putImageData(imageData, 0, 0);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return X400;
})(Primitive);

module.exports = X400;

},{"./primitive":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/primitive.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/quozi-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Quozi Filter
 * @class
 * @alias ImglyKit.Filters.QuoziFilter
 * @extends {ImglyKit.Filter}
 */
var QuoziFilter = (function (Filter) {
  function QuoziFilter() {
    if (Object.getPrototypeOf(QuoziFilter) !== null) {
      Object.getPrototypeOf(QuoziFilter).apply(this, arguments);
    }
  }

  _inherits(QuoziFilter, Filter);

  _prototypeProperties(QuoziFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "quozi";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        // Desaturation
        stack.add(new Filter.Primitives.Desaturation({
          desaturation: 0.65
        }));

        // Tone curve
        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 50], [40, 78], [118, 170], [181, 211], [255, 255]],
            green: [[0, 27], [28, 45], [109, 157], [157, 195], [179, 208], [206, 212], [255, 240]],
            blue: [[0, 50], [12, 55], [46, 103], [103, 162], [194, 182], [241, 201], [255, 219]]
          }
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return QuoziFilter;
})(Filter);

module.exports = QuoziFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/semired-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Semired Filter
 * @class
 * @alias ImglyKit.Filters.SemiredFilter
 * @extends {ImglyKit.Filter}
 */
var SemiredFilter = (function (Filter) {
  function SemiredFilter() {
    if (Object.getPrototypeOf(SemiredFilter) !== null) {
      Object.getPrototypeOf(SemiredFilter).apply(this, arguments);
    }
  }

  _inherits(SemiredFilter, Filter);

  _prototypeProperties(SemiredFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "semired";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 129], [75, 153], [181, 227], [255, 255]],
            green: [[0, 8], [111, 85], [212, 158], [255, 226]],
            blue: [[0, 5], [75, 22], [193, 90], [255, 229]]
          }
        }));

        stack.add(new Filter.Primitives.Glow());

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return SemiredFilter;
})(Filter);

module.exports = SemiredFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/sunny-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Sunny Filter
 * @class
 * @alias ImglyKit.Filters.SunnyFilter
 * @extends {ImglyKit.Filter}
 */
var SunnyFilter = (function (Filter) {
  function SunnyFilter() {
    if (Object.getPrototypeOf(SunnyFilter) !== null) {
      Object.getPrototypeOf(SunnyFilter).apply(this, arguments);
    }
  }

  _inherits(SunnyFilter, Filter);

  _prototypeProperties(SunnyFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "sunny";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 0], [62, 82], [141, 154], [255, 255]],
            green: [[0, 39], [56, 96], [192, 176], [255, 255]],
            blue: [[0, 0], [174, 99], [255, 235]]
          }
        }));

        stack.add(new Filter.Primitives.ToneCurve({
          controlPoints: [[0, 0], [55, 20], [158, 191], [255, 255]]
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return SunnyFilter;
})(Filter);

module.exports = SunnyFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/texas-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * Texas Filter
 * @class
 * @alias ImglyKit.Filters.TexasFilter
 * @extends {ImglyKit.Filter}
 */
var TexasFilter = (function (Filter) {
  function TexasFilter() {
    if (Object.getPrototypeOf(TexasFilter) !== null) {
      Object.getPrototypeOf(TexasFilter).apply(this, arguments);
    }
  }

  _inherits(TexasFilter, Filter);

  _prototypeProperties(TexasFilter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "texas";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        stack.add(new Filter.Primitives.ToneCurve({
          rgbControlPoints: {
            red: [[0, 72], [89, 99], [176, 212], [255, 237]],
            green: [[0, 49], [255, 192]],
            blue: [[0, 72], [255, 151]]
          }
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return TexasFilter;
})(Filter);

module.exports = TexasFilter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/x400-filter.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Filter = _interopRequire(require("./filter"));

/**
 * X400 Filter
 * @class
 * @alias ImglyKit.Filters.X400Filter
 * @extends {ImglyKit.Filter}
 */
var X400Filter = (function (Filter) {
  function X400Filter() {
    if (Object.getPrototypeOf(X400Filter) !== null) {
      Object.getPrototypeOf(X400Filter).apply(this, arguments);
    }
  }

  _inherits(X400Filter, Filter);

  _prototypeProperties(X400Filter, {
    identifier: {
      /**
       * A unique string that identifies this operation. Can be used to select
       * the active filter.
       * @type {String}
       */
      get: function () {
        return "x400";
      },
      enumerable: true,
      configurable: true
    }
  }, {
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new Filter.PrimitivesStack();

        stack.add(new Filter.Primitives.X400());

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return X400Filter;
})(Filter);

module.exports = X400Filter;

},{"./filter":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/filter.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/flip-operation.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Operation = _interopRequire(require("./operation"));

var Utils = _interopRequire(require("../lib/utils"));

/**
 * An operation that can flip the canvas
 *
 * @class
 * @alias ImglyKit.Operations.FlipOperation
 * @extends ImglyKit.Operation
 */
var FlipOperation = (function (Operation) {
  function FlipOperation() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.availableOptions = {
      horizontal: { type: "boolean", "default": false },
      vertical: { type: "boolean", "default": false }
    };

    /**
     * The fragment shader used for this operation
     */
    this.fragmentShader = "\n      precision mediump float;\n      uniform sampler2D u_image;\n      varying vec2 v_texCoord;\n      uniform bool u_flipVertical;\n      uniform bool u_flipHorizontal;\n\n      void main() {\n        vec2 texCoord = vec2(v_texCoord);\n        if (u_flipVertical) {\n          texCoord.y = 1.0 - texCoord.y;\n        }\n        if (u_flipHorizontal) {\n          texCoord.x = 1.0 - texCoord.x;\n        }\n        gl_FragColor = texture2D(u_image, texCoord);\n      }\n    ";

    _get(Object.getPrototypeOf(FlipOperation.prototype), "constructor", this).apply(this, args);
  }

  _inherits(FlipOperation, Operation);

  _prototypeProperties(FlipOperation, null, {
    identifier: {

      /**
       * A unique string that identifies this operation. Can be used to select
       * operations.
       * @type {String}
       */
      get: function () {
        return "flip";
      },
      enumerable: true,
      configurable: true
    },
    _renderWebGL: {

      /**
       * Crops this image using WebGL
       * @param  {WebGLRenderer} renderer
       */
      /* istanbul ignore next */
      value: function RenderWebGL(renderer) {
        renderer.runShader(null, FlipOperation.fragmentShader, {
          uniforms: {
            u_flipVertical: { type: "f", value: this._options.vertical },
            u_flipHorizontal: { type: "f", value: this._options.horizontal }
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _renderCanvas: {

      /**
       * Crops the image using Canvas2D
       * @param  {CanvasRenderer} renderer
       */
      value: function RenderCanvas(renderer) {
        var canvas = renderer.getCanvas();
        var context = renderer.getContext();

        var scaleX = 1,
            scaleY = 1;
        var translateX = 0,
            translateY = 0;

        if (this._options.horizontal) {
          scaleX = -1;
          translateX = canvas.width;
        }

        if (this._options.vertical) {
          scaleY = -1;
          translateY = canvas.height;
        }

        // Save the current state
        context.save();

        // Apply the transformation
        context.translate(translateX, translateY);
        context.scale(scaleX, scaleY);

        // Create a temporary canvas so that we can draw the image
        // with the applied transformation
        var tempCanvas = renderer.cloneCanvas();
        context.drawImage(tempCanvas, 0, 0);

        // Restore old transformation
        context.restore();
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return FlipOperation;
})(Operation);

module.exports = FlipOperation;

},{"../lib/utils":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/utils.js","./operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/operation.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/frames-operation.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Operation = _interopRequire(require("./operation"));

var Color = _interopRequire(require("../lib/color"));

/**
 * An operation that can frames on the canvas
 *
 * @class
 * @alias ImglyKit.Operations.FramesOperation
 * @extends ImglyKit.Operation
 */
var FramesOperation = (function (Operation) {
  function FramesOperation() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.availableOptions = {
      color: { type: "color", "default": new Color(0, 0, 0, 1) },
      thickness: { type: "number", "default": 0.02 }
    };

    /**
     * The texture index used for the frame
     * @type {Number}
     * @private
     */
    this._textureIndex = 1;

    /**
     * The fragment shader used for this operation
     */
    this._fragmentShader = "\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform sampler2D u_frameImage;\n      uniform vec4 u_color;\n      uniform vec2 u_thickness;\n\n      void main() {\n        vec4 fragColor = texture2D(u_image, v_texCoord);\n        if (v_texCoord.x < u_thickness.x || v_texCoord.x > 1.0 - u_thickness.x ||\n          v_texCoord.y < u_thickness.y || v_texCoord.y > 1.0 - u_thickness.y) {\n            fragColor = u_color;\n          }\n\n        gl_FragColor = fragColor;\n      }\n    ";

    _get(Object.getPrototypeOf(FramesOperation.prototype), "constructor", this).apply(this, args);
  }

  _inherits(FramesOperation, Operation);

  _prototypeProperties(FramesOperation, null, {
    identifier: {

      /**
       * A unique string that identifies this operation. Can be used to select
       * operations.
       * @type {String}
       */
      get: function () {
        return "frames";
      },
      enumerable: true,
      configurable: true
    },
    _renderWebGL: {

      /**
       * Crops this image using WebGL
       * @param  {WebGLRenderer} renderer
       * @private
       */
      /* istanbul ignore next */
      value: function RenderWebGL(renderer) {
        var canvas = renderer.getCanvas();

        var color = this._options.color;
        var thickness = this._options.thickness * canvas.height;
        var thicknessVec2 = [thickness / canvas.width, thickness / canvas.height];

        renderer.runShader(null, this._fragmentShader, {
          uniforms: {
            u_color: { type: "4f", value: color.toGLColor() },
            u_thickness: { type: "2f", value: thicknessVec2 }
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _renderCanvas: {

      /**
       * Crops the image using Canvas2D
       * @param  {CanvasRenderer} renderer
       * @private
       */
      value: function RenderCanvas(renderer) {
        var canvas = renderer.getCanvas();
        var context = renderer.getContext();

        var color = this._options.color;
        var thickness = this._options.thickness * canvas.height;

        context.save();
        context.beginPath();
        context.lineWidth = thickness * 2;
        context.strokeStyle = color.toRGBA();
        context.rect(0, 0, canvas.width, canvas.height);
        context.stroke();
        context.restore();
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return FramesOperation;
})(Operation);

module.exports = FramesOperation;

},{"../lib/color":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/color.js","./operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/operation.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/operation.js":[function(require,module,exports){
/* jshint unused:false */
/* jshint -W083 */
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var _ = _interopRequire(require("lodash"));

var Vector2 = _interopRequire(require("../lib/math/vector2"));

var Color = _interopRequire(require("../lib/color"));

/**
 * Base class for Operations. Extendable via {@link ImglyKit.Operation#extend}.
 * @class
 * @alias ImglyKit.Operation
 */
var Operation = (function () {
  function Operation(kit, options) {
    if (kit.constructor.name !== "ImglyKit") {
      throw new Error("Operation: First parameter for constructor has to be an ImglyKit instance.");
    }

    this._kit = kit;
    this.availableOptions = _.extend(this.availableOptions || {}, {
      numberFormat: { type: "string", "default": "relative", available: ["absolute", "relative"] }
    });

    this._initOptions(options || {});
  }

  _prototypeProperties(Operation, null, {
    identifier: {

      /**
       * A unique string that identifies this operation. Can be used to select
       * operations.
       * @type {String}
       */
      get: function () {
        return null;
      },
      enumerable: true,
      configurable: true
    },
    validateSettings: {

      /**
       * Checks whether this Operation can be applied the way it is configured
       */
      value: function validateSettings() {
        var identifier = this.identifier;

        // Check for required options
        for (var optionName in this.availableOptions) {
          var optionConfig = this.availableOptions[optionName];
          if (optionConfig.required && typeof this._options[optionName] === "undefined") {
            throw new Error("Operation `" + identifier + "`: Option `" + optionName + "` is required.");
          }
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    render: {

      /**
       * Applies this operation
       * @param  {Renderer} renderer
       * @return {Promise}
       * @abstract
       */
      value: function render(renderer) {
        if (renderer.identifier === "webgl") {
          /* istanbul ignore next */
          this._renderWebGL(renderer);
        } else {
          this._renderCanvas(renderer);
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _renderWebGL: {

      /**
       * Applies this operation using WebGL
       * @return {WebGLRenderer} renderer
       * @private
       */
      value: function RenderWebGL() {
        throw new Error("Operation#_renderWebGL is abstract and not implemented in inherited class.");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _renderCanvas: {

      /**
       * Applies this operation using Canvas2D
       * @return {CanvasRenderer} renderer
       * @private
       */
      value: function RenderCanvas() {
        throw new Error("Operation#_renderCanvas is abstract and not implemented in inherited class.");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _initOptions: {

      /**
       * Goes through the available options, sets _options defaults
       * @param {Object} userOptions
       * @private
       */
      value: function InitOptions(userOptions) {
        this._options = {};

        // Set defaults, create getters and setters
        var optionName, option, capitalized;
        var self = this;
        for (optionName in this.availableOptions) {
          option = this.availableOptions[optionName];

          // Set default if available
          if (typeof option["default"] !== "undefined") {
            this._options[optionName] = option["default"];
          }

          // Create setter and getter
          (function (optionName, option) {
            capitalized = optionName.charAt(0).toUpperCase() + optionName.slice(1);

            self["set" + capitalized] = function (value) {
              if (typeof option.setter !== "undefined") {
                value = option.setter.call(this, value);
              }
              self._setOption(optionName, value);
            };

            // Default getter
            self["get" + capitalized] = function () {
              return self._getOption(optionName);
            };
          })(optionName, option);
        }

        // Overwrite options with the ones given by user
        for (optionName in userOptions) {
          // Check if option is available
          if (typeof this.availableOptions[optionName] === "undefined") {
            throw new Error("Invalid option: " + optionName);
          }

          // Call setter
          capitalized = optionName.charAt(0).toUpperCase() + optionName.slice(1);
          this["set" + capitalized](userOptions[optionName]);
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _getOption: {

      /**
       * Returns the value for the given option
       * @param {String} optionName
       * @return {*}
       * @private
       */
      value: function GetOption(optionName) {
        return this._options[optionName];
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _setOption: {

      /**
       * Sets the value for the given option, validates it
       * @param {String} optionName
       * @param {*} value
       * @private
       */
      value: function SetOption(optionName, value) {
        var optionConfig = this.availableOptions[optionName];
        var identifier = this.identifier;

        if (typeof optionConfig.validation !== "undefined") {
          optionConfig.validation(value);
        }

        switch (optionConfig.type) {
          // String options
          case "string":
            if (typeof value !== "string") {
              throw new Error("Operation `" + identifier + "`: Option `" + optionName + "` has to be a string.");
            }

            // String value restrictions
            var available = optionConfig.available;
            if (typeof available !== "undefined" && available.indexOf(value) === -1) {
              throw new Error("Operation `" + identifier + "`: Invalid value for `" + optionName + "` (valid values are: " + optionConfig.available.join(", ") + ")");
            }

            this._options[optionName] = value;
            break;

          // Number options
          case "number":
            if (typeof value !== "number") {
              throw new Error("Operation `" + identifier + "`: Option `" + optionName + "` has to be a number.");
            }

            this._options[optionName] = value;
            break;

          // Boolean options
          case "boolean":
            if (typeof value !== "boolean") {
              throw new Error("Operation `" + identifier + "`: Option `" + optionName + "` has to be a boolean.");
            }

            this._options[optionName] = value;
            break;

          // Vector2 options
          case "vector2":
            if (!(value instanceof Vector2)) {
              throw new Error("Operation `" + identifier + "`: Option `" + optionName + "` has to be an instance of ImglyKit.Vector2.");
            }

            this._options[optionName] = value.clone();

            break;

          // Color options
          case "color":
            if (!(value instanceof Color)) {
              throw new Error("Operation `" + identifier + "`: Option `" + optionName + "` has to be an instance of ImglyKit.Color.");
            }

            this._options[optionName] = value;
            break;
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Operation;
})();

/**
 * To create an {@link ImglyKit.Operation} class of your own, call this
 * method and provide instance properties and functions.
 * @function
 */
var extend = _interopRequire(require("../lib/extend"));

Operation.extend = extend;

module.exports = Operation;

},{"../lib/color":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/color.js","../lib/extend":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/extend.js","../lib/math/vector2":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/math/vector2.js","lodash":"lodash"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/radial-blur-operation.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Operation = _interopRequire(require("./operation"));

var Vector2 = _interopRequire(require("../lib/math/vector2"));

var StackBlur = _interopRequire(require("../vendor/stack-blur"));

/**
 * An operation that can crop out a part of the image
 *
 * @class
 * @alias ImglyKit.Operations.RadialBlurOperation
 * @extends ImglyKit.Operation
 */
var RadialBlurOperation = (function (Operation) {
  function RadialBlurOperation() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.availableOptions = {
      position: { type: "vector2", "default": new Vector2(0.5, 0.5) },
      gradientRadius: { type: "number", "default": 50 },
      blurRadius: { type: "number", "default": 20 }
    };

    /**
     * The fragment shader used for this operation
     * @internal Based on evanw's glfx.js tilt shift shader:
     *           https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js
     */
    this.fragmentShader = "\n      precision mediump float;\n      uniform sampler2D u_image;\n      uniform float blurRadius;\n      uniform float gradientRadius;\n      uniform vec2 position;\n      uniform vec2 delta;\n      uniform vec2 texSize;\n      varying vec2 v_texCoord;\n\n      float random(vec3 scale, float seed) {\n        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n      }\n\n      void main() {\n          vec4 color = vec4(0.0);\n          float total = 0.0;\n\n          float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n          float radius = smoothstep(0.0, 1.0, abs(distance(v_texCoord * texSize, position)) / (gradientRadius * 2.0)) * blurRadius;\n          for (float t = -30.0; t <= 30.0; t++) {\n              float percent = (t + offset - 0.5) / 30.0;\n              float weight = 1.0 - abs(percent);\n              vec4 sample = texture2D(u_image, v_texCoord + delta * percent * radius / texSize);\n\n              sample.rgb *= sample.a;\n\n              color += sample * weight;\n              total += weight;\n          }\n\n          gl_FragColor = color / total;\n          gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n      }\n    ";

    _get(Object.getPrototypeOf(RadialBlurOperation.prototype), "constructor", this).apply(this, args);
  }

  _inherits(RadialBlurOperation, Operation);

  _prototypeProperties(RadialBlurOperation, null, {
    identifier: {

      /**
       * A unique string that identifies this operation. Can be used to select
       * operations.
       * @type {String}
       */
      get: function () {
        return "radial-blur";
      },
      enumerable: true,
      configurable: true
    },
    _renderWebGL: {

      /**
       * Crops this image using WebGL
       * @param  {WebGLRenderer} renderer
       */
      /* istanbul ignore next */
      value: function RenderWebGL(renderer) {
        var canvas = renderer.getCanvas();
        var canvasSize = new Vector2(canvas.width, canvas.height);

        var position = this._options.position.clone();
        position.y = canvasSize.y - position.y;

        if (this._options.numberFormat === "relative") {
          position.multiply(canvasSize);
        }

        var uniforms = {
          blurRadius: { type: "f", value: this._options.blurRadius },
          gradientRadius: { type: "f", value: this._options.gradientRadius },
          position: { type: "2f", value: [position.x, position.y] },
          texSize: { type: "2f", value: [canvas.width, canvas.height] },
          delta: { type: "2f", value: [1, 1] }
        };

        // First pass
        renderer.runShader(null, RadialBlurOperation.fragmentShader, {
          uniforms: uniforms
        });

        // Update delta for second pass
        uniforms.delta.value = [-1, 1];

        renderer.runShader(null, RadialBlurOperation.fragmentShader, {
          uniforms: uniforms
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _renderCanvas: {

      /**
       * Crops the image using Canvas2D
       * @param  {CanvasRenderer} renderer
       */
      value: function RenderCanvas(renderer) {
        var canvas = renderer.getCanvas();

        var blurryCanvas = this._blurCanvas(renderer);
        var maskCanvas = this._createMask(renderer);

        this._applyMask(canvas, blurryCanvas, maskCanvas);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _blurCanvas: {

      /**
       * Creates a blurred copy of the canvas
       * @param  {CanvasRenderer} renderer
       * @return {Canvas}
       * @private
       */
      value: function BlurCanvas(renderer) {
        var newCanvas = renderer.cloneCanvas();
        var blurryContext = newCanvas.getContext("2d");
        var blurryImageData = blurryContext.getImageData(0, 0, newCanvas.width, newCanvas.height);
        StackBlur.stackBlurCanvasRGBA(blurryImageData, 0, 0, newCanvas.width, newCanvas.height, this._options.blurRadius);
        blurryContext.putImageData(blurryImageData, 0, 0);

        return newCanvas;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _createMask: {

      /**
       * Creates the mask canvas
       * @param  {CanvasRenderer} renderer
       * @return {Canvas}
       * @private
       */
      value: function CreateMask(renderer) {
        var canvas = renderer.getCanvas();

        var canvasSize = new Vector2(canvas.width, canvas.height);
        var gradientRadius = this._options.gradientRadius;

        var maskCanvas = renderer.createCanvas(canvas.width, canvas.height);
        var maskContext = maskCanvas.getContext("2d");

        var position = this._options.position.clone();

        if (this._options.numberFormat === "relative") {
          position.multiply(canvasSize);
        }

        // Build gradient
        var gradient = maskContext.createRadialGradient(position.x, position.y, 0, position.x, position.y, gradientRadius);
        gradient.addColorStop(0, "#FFFFFF");
        gradient.addColorStop(0.5, "#000000");
        gradient.addColorStop(1, "#000000");

        // Draw gradient
        maskContext.fillStyle = gradient;
        maskContext.fillRect(0, 0, canvas.width, canvas.height);

        return maskCanvas;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _applyMask: {

      /**
       * Applies the blur and mask to the input canvas
       * @param  {Canvas} inputCanvas
       * @param  {Canvas} blurryCanvas
       * @param  {Canvas} maskCanvas
       * @private
       */
      value: function ApplyMask(inputCanvas, blurryCanvas, maskCanvas) {
        var inputContext = inputCanvas.getContext("2d");
        var blurryContext = blurryCanvas.getContext("2d");
        var maskContext = maskCanvas.getContext("2d");

        var inputImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
        var pixels = inputImageData.data;
        var blurryPixels = blurryContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
        var maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;

        var index, alpha;
        for (var y = 0; y < inputCanvas.height; y++) {
          for (var x = 0; x < inputCanvas.width; x++) {
            index = (y * inputCanvas.width + x) * 4;
            alpha = maskPixels[index] / 255;

            pixels[index] = alpha * pixels[index] + (1 - alpha) * blurryPixels[index];
            pixels[index + 1] = alpha * pixels[index + 1] + (1 - alpha) * blurryPixels[index + 1];
            pixels[index + 2] = alpha * pixels[index + 2] + (1 - alpha) * blurryPixels[index + 2];
          }
        }

        inputContext.putImageData(inputImageData, 0, 0);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return RadialBlurOperation;
})(Operation);

module.exports = RadialBlurOperation;

},{"../lib/math/vector2":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/math/vector2.js","../vendor/stack-blur":"/Users/sash/development/js/imglykit-rewrite/src/js/vendor/stack-blur.js","./operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/operation.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/rotation-operation.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Operation = _interopRequire(require("./operation"));

/**
 * An operation that can rotate the canvas
 *
 * @class
 * @alias ImglyKit.Operations.RotationOperation
 * @extends ImglyKit.Operation
 */
var RotationOperation = (function (Operation) {
  function RotationOperation() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.availableOptions = {
      degrees: { type: "number", "default": 0, validation: function (value) {
          if (value % 90 !== 0) {
            throw new Error("RotationOperation: `rotation` has to be a multiple of 90.");
          }
        } }
    };

    /**
     * The fragment shader used for this operation
     */
    this.vertexShader = "\n      attribute vec2 a_position;\n      attribute vec2 a_texCoord;\n      varying vec2 v_texCoord;\n      uniform mat3 u_matrix;\n\n      void main() {\n        gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);\n        v_texCoord = a_texCoord;\n      }\n    ";

    _get(Object.getPrototypeOf(RotationOperation.prototype), "constructor", this).apply(this, args);
  }

  _inherits(RotationOperation, Operation);

  _prototypeProperties(RotationOperation, null, {
    identifier: {

      /**
       * A unique string that identifies this operation. Can be used to select
       * operations.
       * @type {String}
       */
      get: function () {
        return "rotation";
      },
      enumerable: true,
      configurable: true
    },
    _renderWebGL: {

      /**
       * Crops this image using WebGL
       * @param  {WebGLRenderer} renderer
       */
      /* istanbul ignore next */
      value: function RenderWebGL(renderer) {
        var canvas = renderer.getCanvas();
        var gl = renderer.getContext();

        var actualDegrees = this._options.degrees % 360;
        var lastTexture = renderer.getLastTexture();

        // If we're not rotating by 180 degrees, we need to resize the canvas
        // and the texture
        if (actualDegrees % 180 !== 0) {
          // Resize the canvas
          var width = canvas.width;
          canvas.width = canvas.height;
          canvas.height = width;

          // Resize the current texture
          var currentTexture = renderer.getCurrentTexture();
          gl.bindTexture(gl.TEXTURE_2D, currentTexture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

          // Resize all other textures except the input texture
          var textures = renderer.getTextures();
          var texture;
          for (var i = 0; i < textures.length; i++) {
            texture = textures[i];

            // We resize the input texture at the end
            if (texture === lastTexture) continue;

            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          }
        }

        // Build the rotation matrix
        var radians = actualDegrees * (Math.PI / 180);
        var c = Math.cos(radians);
        var s = Math.sin(radians);
        var rotationMatrix = [c, -s, 0, s, c, 0, 0, 0, 1];

        // Run the shader
        renderer.runShader(this.vertexShader, null, {
          uniforms: {
            u_matrix: { type: "mat3fv", value: rotationMatrix }
          }
        });

        // Resize the input texture
        gl.bindTexture(gl.TEXTURE_2D, lastTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _renderCanvas: {

      /**
       * Crops the image using Canvas2D
       * @param  {CanvasRenderer} renderer
       */
      value: function RenderCanvas(renderer) {
        var canvas = renderer.getCanvas();

        var actualDegrees = this._options.degrees % 360;
        var width = canvas.width;
        var height = canvas.height;

        if (actualDegrees % 180 !== 0) {
          width = canvas.height;
          height = canvas.width;
        }

        // Create a rotated canvas
        var newCanvas = renderer.createCanvas();
        newCanvas.width = width;
        newCanvas.height = height;
        var newContext = newCanvas.getContext("2d");

        newContext.save();

        // Translate the canvas
        newContext.translate(newCanvas.width / 2, newCanvas.height / 2);

        // Rotate the canvas
        newContext.rotate(actualDegrees * (Math.PI / 180));

        // Create a temporary canvas so that we can draw the image
        // with the applied transformation
        var tempCanvas = renderer.cloneCanvas();
        newContext.drawImage(tempCanvas, -canvas.width / 2, -canvas.height / 2);

        // Restore old transformation
        newContext.restore();

        renderer.setCanvas(newCanvas);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return RotationOperation;
})(Operation);

module.exports = RotationOperation;

},{"./operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/operation.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/saturation-operation.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Operation = _interopRequire(require("./operation"));

var PrimitivesStack = _interopRequire(require("./filters/primitives-stack"));

var SaturationPrimitive = _interopRequire(require("./filters/primitives/saturation"));

/**
 * @class
 * @alias ImglyKit.Operations.SaturationOperation
 * @extends ImglyKit.Operation
 */
var SaturationOperation = (function (Operation) {
  function SaturationOperation() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.availableOptions = {
      saturation: { type: "number", "default": 1 }
    };

    _get(Object.getPrototypeOf(SaturationOperation.prototype), "constructor", this).apply(this, args);
  }

  _inherits(SaturationOperation, Operation);

  _prototypeProperties(SaturationOperation, null, {
    identifier: {

      /**
       * A unique string that identifies this operation. Can be used to select
       * operations.
       * @type {String}
       */
      get: function () {
        return "saturation";
      },
      enumerable: true,
      configurable: true
    },
    render: {

      /**
       * Renders the filter
       * @param  {Renderer} renderer
       * @return {Promise}
       */
      value: function render(renderer) {
        var stack = new PrimitivesStack();

        stack.add(new SaturationPrimitive({
          saturation: this._options.saturation
        }));

        stack.render(renderer);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return SaturationOperation;
})(Operation);

module.exports = SaturationOperation;

},{"./filters/primitives-stack":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives-stack.js","./filters/primitives/saturation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/filters/primitives/saturation.js","./operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/operation.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/stickers-operation.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Operation = _interopRequire(require("./operation"));

var Vector2 = _interopRequire(require("../lib/math/vector2"));

var Utils = _interopRequire(require("../lib/utils"));

var bluebird = _interopRequire(require("bluebird"));

/**
 * An operation that can draw text on the canvas
 *
 * @class
 * @alias ImglyKit.Operations.StickersOperation
 * @extends ImglyKit.Operation
 */
var StickersOperation = (function (Operation) {
  function StickersOperation() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.availableOptions = {
      sticker: { type: "string", required: true },
      position: { type: "vector2", "default": new Vector2(0, 0) },
      size: { type: "vector2" }
    };

    /**
     * The texture index used for the sticker
     * @type {Number}
     * @private
     */
    this._textureIndex = 1;

    /**
     * The fragment shader used for this operation
     */
    this._fragmentShader = "\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform sampler2D u_stickerImage;\n      uniform vec2 u_position;\n      uniform vec2 u_size;\n\n      void main() {\n        vec4 color0 = texture2D(u_image, v_texCoord);\n        vec2 relative = (v_texCoord - u_position) / u_size;\n\n        if (relative.x >= 0.0 && relative.x <= 1.0 &&\n          relative.y >= 0.0 && relative.y <= 1.0) {\n\n            vec4 color1 = texture2D(u_stickerImage, relative);\n            gl_FragColor = vec4(mix(color0.rgb, color1.rgb, color1.a), 1.0);\n\n        } else {\n\n          gl_FragColor = color0;\n\n        }\n      }\n    ";

    _get(Object.getPrototypeOf(StickersOperation.prototype), "constructor", this).apply(this, args);
  }

  _inherits(StickersOperation, Operation);

  _prototypeProperties(StickersOperation, null, {
    identifier: {

      /**
       * A unique string that identifies this operation. Can be used to select
       * operations.
       * @type {String}
       */
      get: function () {
        return "stickers";
      },
      enumerable: true,
      configurable: true
    },
    render: {

      /**
       * Applies this operation
       * @param  {Renderer} renderer
       * @return {Promise}
       * @abstract
       */
      value: function render(renderer) {
        var self = this;
        return this._loadSticker().then(function (image) {
          if (renderer.identifier === "webgl") {
            /* istanbul ignore next */
            return self._renderWebGL(renderer, image);
          } else {
            return self._renderCanvas(renderer, image);
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _renderWebGL: {

      /**
       * Crops this image using WebGL
       * @param  {WebGLRenderer} renderer
       * @param  {Image} image
       * @private
       */
      /* istanbul ignore next */
      value: function RenderWebGL(renderer, image) {
        var canvas = renderer.getCanvas();
        var gl = renderer.getContext();

        var position = this._options.position.clone();
        var canvasSize = new Vector2(canvas.width, canvas.height);

        if (this._options.numberFormat === "absolute") {
          position.divide(canvasSize);
        }

        var size = new Vector2(image.width, image.height);
        if (typeof this._options.size !== "undefined") {
          size.copy(this._options.size);

          if (this._options.numberFormat === "relative") {
            size.multiply(canvasSize);
          }
        }
        size.divide(canvasSize);

        position.y = 1 - position.y; // Invert y
        position.y -= size.y; // Fix y

        // Upload the texture
        gl.activeTexture(gl.TEXTURE0 + this._textureIndex);
        this._texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this._texture);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.activeTexture(gl.TEXTURE0);

        // Execute the shader
        renderer.runShader(null, this._fragmentShader, {
          uniforms: {
            u_stickerImage: { type: "i", value: this._textureIndex },
            u_position: { type: "2f", value: [position.x, position.y] },
            u_size: { type: "2f", value: [size.x, size.y] }
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _renderCanvas: {

      /**
       * Crops the image using Canvas2D
       * @param  {CanvasRenderer} renderer
       * @param  {Image} image
       * @private
       */
      value: function RenderCanvas(renderer, image) {
        var canvas = renderer.getCanvas();
        var context = renderer.getContext();

        var canvasSize = new Vector2(canvas.width, canvas.height);
        var scaledPosition = this._options.position.clone();

        if (this._options.numberFormat === "relative") {
          scaledPosition.multiply(canvasSize);
        }

        var size = new Vector2(image.width, image.height);
        if (typeof this._options.size !== "undefined") {
          size.copy(this._options.size);

          if (this._options.numberFormat === "relative") {
            size.multiply(canvasSize);
          }
        }

        context.drawImage(image, 0, 0, image.width, image.height, scaledPosition.x, scaledPosition.y, size.x, size.y);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _loadSticker: {

      /**
       * Loads the sticker
       * @return {Promise}
       * @private
       */
      value: function LoadSticker() {
        var isBrowser = typeof window !== "undefined";
        var stickerFileName = "stickers/sticker-" + this._options.sticker + ".png";
        if (isBrowser) {
          return this._loadImageBrowser(stickerFileName);
        } else {
          return this._loadImageNode(stickerFileName);
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _loadImageBrowser: {

      /**
       * Loads the given image using the browser's `Image` class
       * @param  {String} fileName
       * @return {Promise}
       * @private
       */
      value: function LoadImageBrowser(fileName) {
        var self = this;
        return new Promise(function (resolve, reject) {
          var image = new Image();

          image.addEventListener("load", function () {
            resolve(image);
          });
          image.addEventListener("error", function () {
            reject(new Error("Could not load sticker: " + fileName));
          });

          image.src = self._kit.getAssetPath(fileName);
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _loadImageNode: {

      /**
       * Loads the given image using node.js' `fs` and node-canvas `Image`
       * @param  {String} fileName
       * @return {Promise}
       * @private
       */
      value: function LoadImageNode(fileName) {
        var Canvas = require("canvas");
        

        var self = this;
        var image = new Canvas.Image();
        var path = self._kit.getAssetPath(fileName);

        return bluebird.promisify(fs.readFile)(path).then(function (buffer) {
          image.src = buffer;
          return image;
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return StickersOperation;
})(Operation);

module.exports = StickersOperation;

},{"../lib/math/vector2":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/math/vector2.js","../lib/utils":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/utils.js","./operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/operation.js","bluebird":"/Users/sash/development/js/imglykit-rewrite/node_modules/bluebird/js/main/bluebird.js","canvas":"canvas"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/text-operation.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Operation = _interopRequire(require("./operation"));

var Vector2 = _interopRequire(require("../lib/math/vector2"));

var Color = _interopRequire(require("../lib/color"));

/**
 * An operation that can draw text on the canvas
 *
 * @class
 * @alias ImglyKit.Operations.TextOperation
 * @extends ImglyKit.Operation
 */
var TextOperation = (function (Operation) {
  function TextOperation() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.availableOptions = {
      fontSize: { type: "number", "default": 30 },
      lineHeight: { type: "number", "default": 1.1 },
      fontFamily: { type: "string", "default": "Times New Roman" },
      fontWeight: { type: "string", "default": "normal" },
      alignment: { type: "string", "default": "left", available: ["left", "center", "right"] },
      verticalAlignment: { type: "string", "default": "top", available: ["top", "center", "bottom"] },
      color: { type: "color", "default": new Color(0, 0, 0, 1) },
      position: { type: "vector2", "default": new Vector2(0, 0) },
      text: { type: "string", required: true }
    };

    /**
     * The texture index used for the text
     * @type {Number}
     * @private
     */
    this._textureIndex = 1;

    /**
     * The fragment shader used for this operation
     */
    this._fragmentShader = "\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform sampler2D u_textImage;\n      uniform vec2 u_position;\n      uniform vec2 u_size;\n\n      void main() {\n        vec4 color0 = texture2D(u_image, v_texCoord);\n        vec2 relative = (v_texCoord - u_position) / u_size;\n\n        if (relative.x >= 0.0 && relative.x <= 1.0 &&\n          relative.y >= 0.0 && relative.y <= 1.0) {\n\n            vec4 color1 = texture2D(u_textImage, relative);\n            gl_FragColor = vec4(mix(color0.rgb, color1.rgb, color1.a), 1.0);\n\n        } else {\n\n          gl_FragColor = color0;\n\n        }\n      }\n    ";

    _get(Object.getPrototypeOf(TextOperation.prototype), "constructor", this).apply(this, args);
  }

  _inherits(TextOperation, Operation);

  _prototypeProperties(TextOperation, null, {
    identifier: {

      /**
       * A unique string that identifies this operation. Can be used to select
       * operations.
       * @type {String}
       */
      get: function () {
        return "text";
      },
      enumerable: true,
      configurable: true
    },
    _renderWebGL: {


      /**
       * Crops this image using WebGL
       * @param  {WebGLRenderer} renderer
       */
      /* istanbul ignore next */
      value: function RenderWebGL(renderer) {
        var textCanvas = this._renderTextCanvas(renderer);

        var canvas = renderer.getCanvas();
        var gl = renderer.getContext();

        var position = this._options.position.clone();
        var canvasSize = new Vector2(canvas.width, canvas.height);
        var size = new Vector2(textCanvas.width, textCanvas.height).divide(canvasSize);

        if (this._options.numberFormat === "absolute") {
          position.divide(canvasSize);
        }

        position.y = 1 - position.y; // Invert y
        position.y -= size.y; // Fix y

        // Adjust vertical alignment
        if (this._options.verticalAlignment === "center") {
          position.y += size.y / 2;
        } else if (this._options.verticalAlignment === "bottom") {
          position.y += size.y;
        }

        // Adjust horizontal alignment
        if (this._options.alignment === "center") {
          position.x -= size.x / 2;
        } else if (this._options.alignment === "right") {
          position.x -= size.x;
        }

        // Upload the texture
        gl.activeTexture(gl.TEXTURE0 + this._textureIndex);
        this._texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this._texture);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textCanvas);
        gl.activeTexture(gl.TEXTURE0);

        // Execute the shader
        renderer.runShader(null, this._fragmentShader, {
          uniforms: {
            u_textImage: { type: "i", value: this._textureIndex },
            u_position: { type: "2f", value: [position.x, position.y] },
            u_size: { type: "2f", value: [size.x, size.y] }
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _renderCanvas: {

      /**
       * Crops the image using Canvas2D
       * @param  {CanvasRenderer} renderer
       */
      value: function RenderCanvas(renderer) {
        var textCanvas = this._renderTextCanvas(renderer);

        var canvas = renderer.getCanvas();
        var context = renderer.getContext();

        var canvasSize = new Vector2(canvas.width, canvas.height);
        var scaledPosition = this._options.position.clone();

        if (this._options.numberFormat === "relative") {
          scaledPosition.multiply(canvasSize);
        }

        // Adjust vertical alignment
        if (this._options.verticalAlignment === "center") {
          scaledPosition.y -= textCanvas.height / 2;
        } else if (this._options.verticalAlignment === "bottom") {
          scaledPosition.y -= textCanvas.height;
        }

        // Adjust horizontal alignment
        if (this._options.alignment === "center") {
          scaledPosition.x -= textCanvas.width / 2;
        } else if (this._options.alignment === "right") {
          scaledPosition.x -= textCanvas.width;
        }

        context.drawImage(textCanvas, scaledPosition.x, scaledPosition.y);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _renderTextCanvas: {

      /**
       * Renders the text canvas that will be used as a texture in WebGL
       * and as an image in canvas
       * @return {Canvas}
       * @private
       */
      value: function RenderTextCanvas(renderer) {
        var line, lineNum;
        var canvas = renderer.createCanvas();
        var context = canvas.getContext("2d");
        var maxWidth = this._options.maxWidth;
        var actualLineHeight = this._options.lineHeight * this._options.fontSize;

        // Apply text options
        this._applyTextOptions(context);

        var boundingBox = new Vector2();

        var lines = this._options.text.split("\n");
        if (typeof maxWidth !== "undefined") {
          // Calculate the bounding box
          boundingBox.x = this._options.maxWidth;
          lines = this._buildOutputLines(context, maxWidth);
        } else {
          for (lineNum = 0; lineNum < lines.length; lineNum++) {
            line = lines[lineNum];
            boundingBox.x = Math.max(boundingBox.x, context.measureText(line).width);
          }
        }

        // Calculate boundingbox height
        boundingBox.y = actualLineHeight * lines.length;

        // Resize the canvas
        canvas.width = boundingBox.x;
        canvas.height = boundingBox.y;

        // Get the context again, apply text options
        context = canvas.getContext("2d");
        this._applyTextOptions(context);

        // Draw lines
        for (lineNum = 0; lineNum < lines.length; lineNum++) {
          line = lines[lineNum];
          this._drawText(context, line, actualLineHeight * lineNum);
        }

        return canvas;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _applyTextOptions: {

      /**
       * Applies the text options on the given context
       * @param  {RenderingContext2D} context
       * @private
       */
      value: function ApplyTextOptions(context) {
        context.font = this._options.fontWeight + " " + this._options.fontSize + "px " + this._options.fontFamily;
        context.textBaseline = "hanging";
        context.textAlign = this._options.alignment;
        context.fillStyle = this._options.color.toRGBA();
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _buildOutputLines: {

      /**
       * Iterate over all lines and split them into multiple lines, depending
       * on the width they need
       * @param {RenderingContext2d} context
       * @param {Number} maxWidth
       * @return {Array.<string>}
       * @private
       */
      value: function BuildOutputLines(context, maxWidth) {
        var inputLines = this._options.text.split("\n");
        var outputLines = [];
        var currentWords = [];

        for (var lineNum = 0; lineNum < inputLines.length; lineNum++) {
          var inputLine = inputLines[lineNum];
          var lineWords = inputLine.split(" ");

          for (var wordNum = 0; wordNum < lineWords.length; wordNum++) {
            var currentWord = lineWords[wordNum];
            currentWords.push(currentWord);
            var currentLine = currentWords.join(" ");
            var lineWidth = context.measureText(currentLine).width;

            if (lineWidth > maxWidth && currentWords.length === 1) {
              outputLines.push(currentWords[0]);
              currentWords = [];
            } else if (lineWidth > maxWidth) {
              // Remove the last word
              var lastWord = currentWords.pop();

              // Add the line, clear the words
              outputLines.push(currentWords.join(" "));
              currentWords = [];

              // Make sure to use the last word for the next line
              currentWords = [lastWord];
            } else if (wordNum === lineWords.length - 1) {
              // Add the line, clear the words
              outputLines.push(currentWords.join(" "));
              currentWords = [];
            }
          }

          // Line ended, but there's words left
          if (currentWords.length) {
            outputLines.push(currentWords.join(" "));
            currentWords = [];
          }
        }
        return outputLines;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _drawText: {

      /**
       * Draws the given line onto the given context at the given Y position
       * @param  {RenderingContext2D} context
       * @param  {String} text
       * @param  {Number} y
       * @private
       */
      value: function DrawText(context, text, y) {
        var canvas = context.canvas;
        if (this._options.alignment === "center") {
          context.fillText(text, canvas.width / 2, y);
        } else if (this._options.alignment === "left") {
          context.fillText(text, 0, y);
        } else if (this._options.alignment === "right") {
          context.fillText(text, canvas.width, y);
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return TextOperation;
})(Operation);

module.exports = TextOperation;

},{"../lib/color":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/color.js","../lib/math/vector2":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/math/vector2.js","./operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/operation.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/operations/tilt-shift-operation.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Operation = _interopRequire(require("./operation"));

var Vector2 = _interopRequire(require("../lib/math/vector2"));

var StackBlur = _interopRequire(require("../vendor/stack-blur"));

/**
 * An operation that can crop out a part of the image
 *
 * @class
 * @alias ImglyKit.Operations.TiltShiftOperation
 * @extends ImglyKit.Operation
 */
var TiltShiftOperation = (function (Operation) {
  function TiltShiftOperation() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.availableOptions = {
      start: { type: "vector2", "default": new Vector2(0, 0.5) },
      end: { type: "vector2", "default": new Vector2(1, 0.5) },
      blurRadius: { type: "number", "default": 30 },
      gradientRadius: { type: "number", "default": 50 }
    };

    /**
     * The fragment shader used for this operation
     * @internal Based on evanw's glfx.js tilt shift shader:
     *           https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js
     */
    this.fragmentShader = "\n      precision mediump float;\n      uniform sampler2D u_image;\n      uniform float blurRadius;\n      uniform float gradientRadius;\n      uniform vec2 start;\n      uniform vec2 end;\n      uniform vec2 delta;\n      uniform vec2 texSize;\n      varying vec2 v_texCoord;\n\n      float random(vec3 scale, float seed) {\n        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n      }\n\n      void main() {\n          vec4 color = vec4(0.0);\n          float total = 0.0;\n\n          float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n          vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n          float radius = smoothstep(0.0, 1.0, abs(dot(v_texCoord * texSize - start, normal)) / gradientRadius) * blurRadius;\n          for (float t = -30.0; t <= 30.0; t++) {\n              float percent = (t + offset - 0.5) / 30.0;\n              float weight = 1.0 - abs(percent);\n              vec4 sample = texture2D(u_image, v_texCoord + delta * percent * radius / texSize);\n\n              sample.rgb *= sample.a;\n\n              color += sample * weight;\n              total += weight;\n          }\n\n          gl_FragColor = color / total;\n          gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n      }\n    ";

    _get(Object.getPrototypeOf(TiltShiftOperation.prototype), "constructor", this).apply(this, args);
  }

  _inherits(TiltShiftOperation, Operation);

  _prototypeProperties(TiltShiftOperation, null, {
    identifier: {

      /**
       * A unique string that identifies this operation. Can be used to select
       * operations.
       * @type {String}
       */
      get: function () {
        return "tilt-shift";
      },
      enumerable: true,
      configurable: true
    },
    _renderWebGL: {

      /**
       * Crops this image using WebGL
       * @param  {WebGLRenderer} renderer
       */
      /* istanbul ignore next */
      value: function RenderWebGL(renderer) {
        var canvas = renderer.getCanvas();
        var canvasSize = new Vector2(canvas.width, canvas.height);

        var start = this._options.start.clone();
        var end = this._options.end.clone();

        if (this._options.numberFormat === "relative") {
          start.multiply(canvasSize);
          end.multiply(canvasSize);
        }

        start.y = canvasSize.y - start.y;
        end.y = canvasSize.y - end.y;

        var delta = end.clone().subtract(start);
        var d = Math.sqrt(delta.x * delta.x + delta.y * delta.y);

        var uniforms = {
          blurRadius: { type: "f", value: this._options.blurRadius },
          gradientRadius: { type: "f", value: this._options.gradientRadius },
          start: { type: "2f", value: [start.x, start.y] },
          end: { type: "2f", value: [end.x, end.y] },
          delta: { type: "2f", value: [delta.x / d, delta.y / d] },
          texSize: { type: "2f", value: [canvas.width, canvas.height] }
        };

        renderer.runShader(null, TiltShiftOperation.fragmentShader, {
          uniforms: uniforms
        });

        uniforms.delta.value = [-delta.y / d, delta.x / d];

        renderer.runShader(null, TiltShiftOperation.fragmentShader, {
          uniforms: uniforms
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _renderCanvas: {

      /**
       * Crops the image using Canvas2D
       * @param  {CanvasRenderer} renderer
       */
      value: function RenderCanvas(renderer) {
        var canvas = renderer.getCanvas();

        var blurryCanvas = this._blurCanvas(renderer);
        var maskCanvas = this._createMask(renderer);

        this._applyMask(canvas, blurryCanvas, maskCanvas);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _blurCanvas: {

      /**
       * Creates a blurred copy of the canvas
       * @param  {CanvasRenderer} renderer
       * @return {Canvas}
       * @private
       */
      value: function BlurCanvas(renderer) {
        var newCanvas = renderer.cloneCanvas();
        var blurryContext = newCanvas.getContext("2d");
        var blurryImageData = blurryContext.getImageData(0, 0, newCanvas.width, newCanvas.height);
        StackBlur.stackBlurCanvasRGBA(blurryImageData, 0, 0, newCanvas.width, newCanvas.height, this._options.blurRadius);
        blurryContext.putImageData(blurryImageData, 0, 0);

        return newCanvas;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _createMask: {

      /**
       * Creates the mask canvas
       * @param  {CanvasRenderer} renderer
       * @return {Canvas}
       * @private
       */
      value: function CreateMask(renderer) {
        var canvas = renderer.getCanvas();

        var canvasSize = new Vector2(canvas.width, canvas.height);
        var gradientRadius = this._options.gradientRadius;

        var maskCanvas = renderer.createCanvas(canvas.width, canvas.height);
        var maskContext = maskCanvas.getContext("2d");

        var start = this._options.start.clone();
        var end = this._options.end.clone();

        if (this._options.numberFormat === "relative") {
          start.multiply(canvasSize);
          end.multiply(canvasSize);
        }

        var rad = Math.atan((end.y - start.y) / (end.x - start.x));

        var gradientStart = start.clone();
        gradientStart.x += Math.sin(rad * Math.PI / 2) * gradientRadius;
        gradientStart.y -= Math.cos(rad * Math.PI / 2) * gradientRadius;

        var gradientEnd = start.clone();
        gradientEnd.x -= Math.sin(rad * Math.PI / 2) * gradientRadius;
        gradientEnd.y += Math.cos(rad * Math.PI / 2) * gradientRadius;

        // Build gradient
        var gradient = maskContext.createLinearGradient(gradientStart.x, gradientStart.y, gradientEnd.x, gradientEnd.y);
        gradient.addColorStop(0, "#000000");
        gradient.addColorStop(0.5, "#FFFFFF");
        gradient.addColorStop(1, "#000000");

        // Draw gradient
        maskContext.fillStyle = gradient;
        maskContext.fillRect(0, 0, canvas.width, canvas.height);

        return maskCanvas;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _applyMask: {

      /**
       * Applies the blur and mask to the input canvas
       * @param  {Canvas} inputCanvas
       * @param  {Canvas} blurryCanvas
       * @param  {Canvas} maskCanvas
       * @private
       */
      value: function ApplyMask(inputCanvas, blurryCanvas, maskCanvas) {
        var inputContext = inputCanvas.getContext("2d");
        var blurryContext = blurryCanvas.getContext("2d");
        var maskContext = maskCanvas.getContext("2d");

        var inputImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
        var pixels = inputImageData.data;
        var blurryPixels = blurryContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
        var maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;

        var index, alpha;
        for (var y = 0; y < inputCanvas.height; y++) {
          for (var x = 0; x < inputCanvas.width; x++) {
            index = (y * inputCanvas.width + x) * 4;
            alpha = maskPixels[index] / 255;

            pixels[index] = alpha * pixels[index] + (1 - alpha) * blurryPixels[index];
            pixels[index + 1] = alpha * pixels[index + 1] + (1 - alpha) * blurryPixels[index + 1];
            pixels[index + 2] = alpha * pixels[index + 2] + (1 - alpha) * blurryPixels[index + 2];
          }
        }

        inputContext.putImageData(inputImageData, 0, 0);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return TiltShiftOperation;
})(Operation);

module.exports = TiltShiftOperation;

},{"../lib/math/vector2":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/math/vector2.js","../vendor/stack-blur":"/Users/sash/development/js/imglykit-rewrite/src/js/vendor/stack-blur.js","./operation":"/Users/sash/development/js/imglykit-rewrite/src/js/operations/operation.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/renderers/canvas-renderer.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */
var Renderer = _interopRequire(require("./renderer"));

/**
 * @class
 * @alias ImglyKit.CanvasRenderer
 * @extends {ImglyKit.Renderer}
 * @private
 */
var CanvasRenderer = (function (Renderer) {
  function CanvasRenderer() {
    if (Object.getPrototypeOf(CanvasRenderer) !== null) {
      Object.getPrototypeOf(CanvasRenderer).apply(this, arguments);
    }
  }

  _inherits(CanvasRenderer, Renderer);

  _prototypeProperties(CanvasRenderer, {
    identifier: {
      /**
       * A unique string that identifies this renderer
       * @type {String}
       */
      get: function () {
        return "canvas";
      },
      enumerable: true,
      configurable: true
    },
    isSupported: {

      /**
       * Checks whether this type of renderer is supported in the current environment
       * @abstract
       * @returns {boolean}
       */
      value: function isSupported() {
        var elem = this.prototype.createCanvas();
        return !!(elem.getContext && elem.getContext("2d"));
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  }, {
    _getContext: {

      /**
       * Gets the rendering context from the Canva
       * @return {RenderingContext}
       * @abstract
       */
      value: function GetContext() {
        /* istanbul ignore next */
        return this._canvas.getContext("2d");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    drawImage: {

      /**
       * Draws the given image on the canvas
       * @param  {Image} image
       */
      value: function drawImage(image) {
        this._context.drawImage(image, 0, 0);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    resizeTo: {

      /**
       * Resizes the current canvas picture to the given dimensions
       * @param  {Vector2} dimensions
       * @return {Promise}
       */
      value: function resizeTo(dimensions) {
        // Create a temporary canvas to draw to
        var newCanvas = this.createCanvas();
        newCanvas.width = dimensions.x;
        newCanvas.height = dimensions.y;
        var newContext = newCanvas.getContext("2d");

        // Draw the source canvas onto the new one
        newContext.drawImage(this._canvas, 0, 0, this._canvas.width, this._canvas.height, 0, 0, newCanvas.width, newCanvas.height);

        // Set the new canvas and context
        this.setCanvas(newCanvas);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    cloneCanvas: {

      /**
       * Returns a cloned version of the current canvas
       * @return {Canvas}
       */
      value: function cloneCanvas() {
        var canvas = this.createCanvas();
        var context = canvas.getContext("2d");

        // Resize the canvas
        canvas.width = this._canvas.width;
        canvas.height = this._canvas.height;

        // Draw the current canvas on the new one
        context.drawImage(this._canvas, 0, 0);

        return canvas;
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return CanvasRenderer;
})(Renderer);

module.exports = CanvasRenderer;

},{"./renderer":"/Users/sash/development/js/imglykit-rewrite/src/js/renderers/renderer.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/renderers/renderer.js":[function(require,module,exports){
/*jshint unused:false */
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Vector2 = _interopRequire(require("../lib/math/vector2"));

/**
 * @class
 * @alias ImglyKit.Renderer
 * @param {Vector2} dimensions
 * @private
 */
var Renderer = (function () {
  function Renderer(dimensions) {
    /**
     * @type {Canvas}
     * @private
     */
    this._canvas = this.createCanvas();

    this.setSize(dimensions);

    /**
     * @type {RenderingContext}
     * @private
     */
    this._context = this._getContext();
  }

  _prototypeProperties(Renderer, {
    isSupported: {

      /**
       * Checks whether this type of renderer is supported in the current environment
       * @abstract
       * @returns {boolean}
       */
      value: function isSupported() {
        /* istanbul ignore next */
        throw new Error("Renderer#isSupported is abstract and not implemented in inherited class.");
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  }, {
    identifier: {

      /**
       * A unique string that identifies this renderer
       * @type {String}
       */
      get: function () {
        return null;
      },
      enumerable: true,
      configurable: true
    },
    createCanvas: {

      /**
       * Creates a new canvas
       * @param {Number} [width]
       * @param {Number} [height]
       * @return {Canvas}
       * @private
       */
      value: function createCanvas(width, height) {
        var isBrowser = typeof window !== "undefined";
        var canvas;
        if (isBrowser) {
          /* istanbul ignore next */
          canvas = document.createElement("canvas");
        } else {
          var Canvas = require("canvas");
          canvas = new Canvas();
        }

        // Apply width
        if (typeof width !== "undefined") {
          canvas.width = width;
        }

        // Apply height
        if (typeof height !== "undefined") {
          canvas.height = height;
        }

        return canvas;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    getSize: {

      /**
       * Returns the current size of the canvas
       * @return {Vector2}
       */
      value: function getSize() {
        return new Vector2(this._canvas.width, this._canvas.height);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    setSize: {

      /**
       * Sets the canvas dimensions
       * @param {Vector2} dimensions
       */
      value: function setSize(dimensions) {
        this._canvas.width = dimensions.x;
        this._canvas.height = dimensions.y;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _getContext: {

      /**
       * Gets the rendering context from the Canva
       * @return {RenderingContext}
       * @abstract
       */
      value: function GetContext() {
        /* istanbul ignore next */
        throw new Error("Renderer#_getContext is abstract and not implemented in inherited class.");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    resizeTo: {

      /**
       * Resizes the current canvas picture to the given dimensions
       * @param  {Vector2} dimensions
       * @return {Promise}
       * @abstract
       */
      value: function resizeTo(dimensions) {
        /* istanbul ignore next */
        throw new Error("Renderer#resizeTo is abstract and not implemented in inherited class.");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    drawImage: {

      /**
       * Draws the given image on the canvas
       * @param  {Image} image
       * @abstract
       */
      value: function drawImage(image) {
        /* istanbul ignore next */
        throw new Error("Renderer#drawImage is abstract and not implemented in inherited class.");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    renderFinal: {

      /**
       * Gets called after the stack has been rendered
       * @param  {Image} image
       */
      value: function renderFinal() {},
      writable: true,
      enumerable: true,
      configurable: true
    },
    getCanvas: {

      /**
       * Returns the canvas
       * @return {Canvas}
       */
      value: function getCanvas() {
        return this._canvas;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    getContext: {

      /**
       * Returns the context
       * @return {RenderingContext}
       */
      value: function getContext() {
        return this._context;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    setCanvas: {

      /**
       * Sets the current canvas to the given one
       * @param {Canvas} canvas
       */
      value: function setCanvas(canvas) {
        this._canvas = canvas;
        this._context = this._getContext();
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    setContext: {

      /**
       * Sets the current context to the given one
       * @param {RenderingContext2D} context
       */
      value: function setContext(context) {
        this._context = context;
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Renderer;
})();

module.exports = Renderer;

},{"../lib/math/vector2":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/math/vector2.js","canvas":"canvas"}],"/Users/sash/development/js/imglykit-rewrite/src/js/renderers/webgl-renderer.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Renderer = _interopRequire(require("./renderer"));

/**
 * @class
 * @alias ImglyKit.WebGLRenderer
 * @extends {ImglyKit.Renderer}
 * @private
 */
var WebGLRenderer = (function (Renderer) {
  function WebGLRenderer() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _get(Object.getPrototypeOf(WebGLRenderer.prototype), "constructor", this).apply(this, args);

    this._defaultProgram = this.setupGLSLProgram();
    this._lastTexture = null;
    this._textures = [];
    this._framebuffers = [];
    this._bufferIndex = 0;
    this._inputTexture = null;

    this._createFramebuffers();
  }

  _inherits(WebGLRenderer, Renderer);

  _prototypeProperties(WebGLRenderer, {
    isSupported: {

      /**
       * Checks whether this type of renderer is supported in the current environment
       * @abstract
       * @returns {boolean}
       */
      value: function isSupported() {
        return !!(typeof window !== "undefined" && window.WebGLRenderingContext);
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  }, {
    identifier: {

      /**
       * A unique string that identifies this renderer
       * @type {String}
       */
      get: function () {
        return "webgl";
      },
      enumerable: true,
      configurable: true
    },
    defaultVertexShader: {

      /**
       * The default vertex shader which just passes the texCoord to the
       * fragment shader.
       * @type {String}
       * @private
       */
      get: function () {
        var shader = "\n      attribute vec2 a_position;\n      attribute vec2 a_texCoord;\n      varying vec2 v_texCoord;\n\n      void main() {\n        gl_Position = vec4(a_position, 0, 1);\n        v_texCoord = a_texCoord;\n      }\n    ";
        return shader;
      },
      enumerable: true,
      configurable: true
    },
    defaultFragmentShader: {

      /**
       * The default fragment shader which will just look up the colors from the
       * texture.
       * @type {String}
       * @private
       */
      get: function () {
        var shader = "\n      precision mediump float;\n      uniform sampler2D u_image;\n      varying vec2 v_texCoord;\n\n      void main() {\n        gl_FragColor = texture2D(u_image, v_texCoord);\n      }\n    ";
        return shader;
      },
      enumerable: true,
      configurable: true
    },
    _getContext: {

      /**
       * Gets the rendering context from the Canvas
       * @return {RenderingContext}
       * @abstract
       */
      value: function GetContext() {
        /* istanbul ignore next */
        return this._canvas.getContext("webgl") || this._canvas.getContext("webgl-experimental");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    drawImage: {

      /**
       * Draws the given image on the canvas
       * @param  {Image} image
       */
      /* istanbul ignore next */
      value: function drawImage(image) {
        var gl = this._context;
        gl.useProgram(this._defaultProgram);

        // Create the texture
        var texture = this.createTexture();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        this._inputTexture = texture;
        this.setLastTexture(texture);

        // Upload the image into the texture
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

        // Draw the rectangle
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    runShader: {

      /**
       * Runs the given shader
       * @param  {String} [vertexShader]
       * @param  {String} [fragmentShader]
       */
      /* istanbul ignore next */
      value: function runShader(vertexShader, fragmentShader, options) {
        if (typeof options === "undefined") options = {};
        if (typeof options.uniforms === "undefined") options.uniforms = {};

        var gl = this._context;
        var program = this.setupGLSLProgram(vertexShader, fragmentShader);
        gl.useProgram(program);

        var fbo = this.getCurrentFramebuffer();
        var texture = this.getCurrentTexture();

        // Select the current framebuffer
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.viewport(0, 0, this._canvas.width, this._canvas.height);

        // Make sure we select the current texture
        gl.bindTexture(gl.TEXTURE_2D, this._lastTexture);

        // Set the uniforms
        for (var name in options.uniforms) {
          var location = gl.getUniformLocation(program, name);
          var uniform = options.uniforms[name];

          switch (uniform.type) {
            case "i":
            case "1i":
              gl.uniform1i(location, uniform.value);
              break;
            case "f":
            case "1f":
              gl.uniform1f(location, uniform.value);
              break;
            case "2f":
              gl.uniform2f(location, uniform.value[0], uniform.value[1]);
              break;
            case "3f":
              gl.uniform3f(location, uniform.value[0], uniform.value[1], uniform.value[2]);
              break;
            case "4f":
              gl.uniform4f(location, uniform.value[0], uniform.value[1], uniform.value[2], uniform.value[3]);
              break;
            case "2fv":
              gl.uniform2fv(location, uniform.value);
              break;
            case "mat3fv":
              gl.uniformMatrix3fv(location, false, uniform.value);
              break;
            default:
              throw new Error("Unknown uniform type: " + uniform.type);
              break;
          }
        }

        // Draw the rectangle
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        this.setLastTexture(texture);
        this.selectNextBuffer();
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    renderFinal: {

      /**
       * Draws the last used buffer onto the canvas
       */
      /* istanbul ignore next */
      value: function renderFinal() {
        var gl = this._context;
        var program = this._defaultProgram;
        gl.useProgram(program);

        // Don't draw to framebuffer
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        // Make sure the viewport size is correct
        gl.viewport(0, 0, this._canvas.width, this._canvas.height);

        // Select the last texture that has been rendered to
        gl.bindTexture(gl.TEXTURE_2D, this._lastTexture);

        // Draw the rectangle
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    setupGLSLProgram: {

      /**
       * Sets up a GLSL program. Uses the default vertex and fragment shader
       * if none are given.
       * @param {String} [vertexShader]
       * @param {String} [fragmentShader]
       * @return {WebGLProgram}
       */
      /* istanbul ignore next */
      value: function setupGLSLProgram(vertexShader, fragmentShader) {
        var gl = this._context;
        var shaders = [];

        // Use default vertex shader
        vertexShader = this._createShader(gl.VERTEX_SHADER, vertexShader || WebGLRenderer.prototype.defaultVertexShader);
        shaders.push(vertexShader);

        // Use default fragment shader
        fragmentShader = this._createShader(gl.FRAGMENT_SHADER, fragmentShader || WebGLRenderer.prototype.defaultFragmentShader);
        shaders.push(fragmentShader);

        // Create the program
        var program = gl.createProgram();

        // Attach the shaders
        for (var i = 0; i < shaders.length; i++) {
          gl.attachShader(program, shaders[i]);
        }

        // Link the program
        gl.linkProgram(program);

        // Check linking status
        var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!linked) {
          var lastError = gl.getProgramInfoLog(program);
          gl.deleteProgram(program);
          throw new Error("WebGL program linking error: " + lastError);
        }

        // Lookup texture coordinates location
        var positionLocation = gl.getAttribLocation(program, "a_position");
        var texCoordLocation = gl.getAttribLocation(program, "a_texCoord");

        // Provide texture coordinates
        var texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        // First triangle
        0, 0, 1, 0, 0, 1,

        // Second triangle
        0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(texCoordLocation);
        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

        // Create a buffer for the rectangle positions
        var buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        // First triangle
        -1, -1, 1, -1, -1, 1,

        // Second triangle
        -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);

        return program;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _createShader: {

      /**
       * Creates a WebGL shader with the given type and source code
       * @param  {WebGLShaderType} shaderType
       * @param  {String} shaderSource
       * @return {WebGLShader}
       * @private
       */
      /* istanbul ignore next */
      value: function CreateShader(shaderType, shaderSource) {
        var gl = this._context;

        // Create the shader and compile it
        var shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);

        // Check compilation status
        var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (!compiled) {
          var lastError = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);
          throw new Error("WebGL shader compilation error: " + lastError);
        }

        return shader;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    createTexture: {

      /**
       * Creates an empty texture
       * @return {WebGLTexture}
       */
      /* istanbul ignore next */
      value: function createTexture() {
        var gl = this._context;
        var texture = gl.createTexture();

        gl.bindTexture(gl.TEXTURE_2D, texture);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        return texture;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _createFramebuffers: {

      /**
       * Creates two textures and framebuffers that are used for the stack
       * rendering
       * @private
       */
      /* istanbul ignore next */
      value: function CreateFramebuffers() {
        var gl = this._context;

        for (var i = 0; i < 2; i++) {
          // Create texture
          var texture = this.createTexture();
          this._textures.push(texture);

          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this._canvas.width, this._canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

          // Create framebuffer
          var fbo = gl.createFramebuffer();
          this._framebuffers.push(fbo);
          gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

          // Attach the texture
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    resizeTo: {

      /**
       * Resizes the current canvas picture to the given dimensions
       * @param  {Vector2} dimensions
       * @todo Use a downsampling shader for smoother image resizing
       */
      /* istanbul ignore next */
      value: function resizeTo(dimensions) {
        var gl = this._context;

        // Resize the canvas
        this._canvas.width = dimensions.x;
        this._canvas.height = dimensions.y;

        // Update the viewport dimensions
        gl.viewport(0, 0, this._canvas.width, this._canvas.height);

        // Draw the rectangle
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    getCurrentFramebuffer: {

      /**
       * Returns the current framebuffer
       * @return {WebGLFramebuffer}
       */
      value: function getCurrentFramebuffer() {
        return this._framebuffers[this._bufferIndex % 2];
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    getCurrentTexture: {

      /**
       * Returns the current texture
       * @return {WebGLTexture}
       */
      value: function getCurrentTexture() {
        return this._textures[this._bufferIndex % 2];
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    selectNextBuffer: {

      /**
       * Increases the buffer index
       */
      value: function selectNextBuffer() {
        this._bufferIndex++;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    getDefaultProgram: {

      /**
       * Returns the default program
       * @return {WebGLProgram}
       */
      value: function getDefaultProgram() {
        return this._defaultProgram;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    getLastTexture: {

      /**
       * Returns the last texture that has been drawn to
       * @return {WebGLTexture}
       */
      value: function getLastTexture() {
        return this._lastTexture;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    getTextures: {

      /**
       * Returns all textures
       * @return {Array.<WebGLTexture>}
       */
      value: function getTextures() {
        return this._textures;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    setLastTexture: {

      /**
       * Sets the last texture
       * @param {WebGLTexture} texture
       */
      value: function setLastTexture(texture) {
        this._lastTexture = texture;
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return WebGLRenderer;
})(Renderer);

module.exports = WebGLRenderer;

},{"./renderer":"/Users/sash/development/js/imglykit-rewrite/src/js/renderers/renderer.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/ui/base/helpers.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Helpers = (function () {
  function Helpers(kit, ui, options) {
    this._kit = kit;
    this._ui = ui;
    this._options = options;
  }

  _prototypeProperties(Helpers, null, {
    assetPath: {
      value: function assetPath(asset) {
        return this._options.assetsUrl + "/" + asset;
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Helpers;
})();

module.exports = Helpers;

},{}],"/Users/sash/development/js/imglykit-rewrite/src/js/ui/base/ui.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */
var dot = _interopRequire(require("dot"));

var Utils = _interopRequire(require("../../lib/utils"));

var Helpers = _interopRequire(require("./helpers"));

var BaseUI = (function () {
  function BaseUI(kit, options) {
    this._kit = kit;
    this._options = options;
    this._operations = [];
    this._controls = [];
    this._helpers = new Helpers(this.kit, this, options);
    this.selectOperations(null);
  }

  _prototypeProperties(BaseUI, null, {
    run: {

      /**
       * Prepares the UI for use
       */
      value: function run() {
        this._attach();
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _attach: {

      /**
       * Renders and attaches the UI HTML
       * @private
       */
      value: function Attach() {
        if (this._options.container === null) {
          throw new Error("BaseUI#attach: No container set.");
        }

        var html = this._render();
        this._options.container.innerHTML = html;

        // Container has to be position: relative
        this._options.container.style.position = "relative";
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _render: {

      /**
       * Renders the template
       * @private
       */
      value: function Render() {
        if (typeof this._template === "undefined") {
          throw new Error("BaseUI#_render: No template set.");
        }

        var renderFn = dot.template(this._template);
        return renderFn(this.context);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    selectOperations: {

      /**
       * Selects the enabled operations
       * @param {ImglyKit.Selector}
       */
      value: function selectOperations(selector) {
        var registeredOperations = this._kit.registeredOperations;
        var operationIdentifiers = Object.keys(registeredOperations);

        var selectedOperations = Utils.select(operationIdentifiers, selector);
        this._operations = selectedOperations.map(function (identifier) {
          return registeredOperations[identifier];
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    isOperationSelected: {
      value: function isOperationSelected(identifier) {
        var operationIdentifiers = this._operations.map(function (operation) {
          return operation.prototype.identifier;
        });
        return operationIdentifiers.indexOf(identifier) !== -1;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    context: {

      /**
       * The data that is passed to the template renderer
       * @type {Object}
       */
      get: function () {
        return {
          operations: this._operations,
          helpers: this._helpers
        };
      },
      enumerable: true,
      configurable: true
    },
    container: {

      /**
       * The DOM container
       * @type {DOMElement}
       */
      get: function () {
        return this._options.container;
      },
      enumerable: true,
      configurable: true
    },
    operations: {

      /**
       * The selected / active operations
       * @type {Array.<ImglyKit.Operation>}
       */
      get: function () {
        return this._operations;
      },
      enumerable: true,
      configurable: true
    },
    options: {

      /**
       * The options
       * @type {Object}
       */
      get: function () {
        return this._options;
      },
      enumerable: true,
      configurable: true
    }
  });

  return BaseUI;
})();

module.exports = BaseUI;

},{"../../lib/utils":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/utils.js","./helpers":"/Users/sash/development/js/imglykit-rewrite/src/js/ui/base/helpers.js","dot":"/Users/sash/development/js/imglykit-rewrite/node_modules/dot/index.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/ui/night/controls/control.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var dot = _interopRequire(require("dot"));

var Helpers = _interopRequire(require("../../base/helpers"));

var EventEmitter = _interopRequire(require("../../../lib/event-emitter"));

var Control = (function (EventEmitter) {
  function Control(kit, ui, operation, controlsContainer, canvasControlsContainer) {
    _get(Object.getPrototypeOf(Control.prototype), "constructor", this).call(this);

    this._kit = kit;
    this._ui = ui;
    this._operation = operation;
    this._controlsContainer = controlsContainer;
    this._canvasControlsContainer = canvasControlsContainer;
    this._helpers = new Helpers(this._kit, this._ui, this._ui.options);

    this.init();
  }

  _inherits(Control, EventEmitter);

  _prototypeProperties(Control, null, {
    init: {

      /**
       * The entry point for this control
       */
      value: function init() {},
      writable: true,
      enumerable: true,
      configurable: true
    },
    _renderAllControls: {

      /**
       * Renders the controls
       * @private
       */
      value: function RenderAllControls() {
        this._renderControls();
        this._renderCanvasControls();
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _renderControls: {

      /**
       * Renders the controls
       * @private
       */
      value: function RenderControls() {
        if (typeof this._controlsTemplate === "undefined") {
          throw new Error("Control#_renderOverviewControls: Control needs to define this._controlsTemplate.");
        }

        // Render the template
        var renderFn = dot.template(this._controlsTemplate);
        var html = renderFn(this.context);

        // Create a wrapper
        this._controls = document.createElement("div");
        this._controls.innerHTML = html;

        // Append to DOM
        this._controlsContainer.appendChild(this._controls);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _renderCanvasControls: {

      /**
       * Renders the canvas controls
       * @private
       */
      value: function RenderCanvasControls() {
        if (typeof this._canvasControlsTemplate === "undefined") {
          return; // Canvas controls are optional
        }

        // Render the template
        var renderFn = dot.template(this._canvasControlsTemplate);
        var html = renderFn(this.context);

        // Create a wrapper
        this._canvasControls = document.createElement("div");
        this._canvasControls.innerHTML = html;

        // Append to DOM
        this._canvasControlsContainer.appendChild(this._canvasControls);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _removeControls: {

      /**
       * Removes the controls from the DOM
       * @private
       */
      value: function RemoveControls() {
        this._controls.parentNode.removeChild(this._controls);
        if (this._canvasControls) {
          this._canvasControls.parentNode.removeChild(this._canvasControls);
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _handleBackAndDoneButtons: {
      value: function HandleBackAndDoneButtons() {
        // Back button
        var backButton = this._controls.querySelector(".imglykit-controls-back");
        backButton.addEventListener("click", this._onBackButtonClick.bind(this));

        // Done button
        var doneButton = this._controls.querySelector(".imglykit-controls-done");
        doneButton.addEventListener("click", this._onDoneButtonClick.bind(this));
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _onBackButtonClick: {

      /**
       * Gets called when the back button has been clicked
       * @private
       */
      value: function OnBackButtonClick() {
        this._onBack();
        this.emit("back");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _onDoneButtonClick: {

      /**
       * Gets called when the done button has been clicked
       * @private
       */
      value: function OnDoneButtonClick() {
        this._onDone();
        this.emit("back");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    enter: {

      /**
       * Gets called when this control is activated
       * @internal Used by the SDK, don't override.
       */
      value: function enter() {
        this._renderAllControls();
        this._handleBackAndDoneButtons();
        this._onEnter();
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    leave: {

      /**
       * Gets called when this control is deactivated
       * @internal Used by the SDK, don't override.
       */
      value: function leave() {
        this._removeControls();
        this._onLeave();
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _onEnter: {

      // Protected methods

      /**
       * Gets called when this control is activated.
       * @protected
       */
      value: function OnEnter() {},
      writable: true,
      enumerable: true,
      configurable: true
    },
    _onLeave: {

      /**
       * Gets called when this control is deactivated
       * @protected
       */
      value: function OnLeave() {},
      writable: true,
      enumerable: true,
      configurable: true
    },
    _onBack: {

      /**
       * Gets called when the back button has been clicked
       * @protected
       */
      value: function OnBack() {},
      writable: true,
      enumerable: true,
      configurable: true
    },
    _onDone: {

      /**
       * Gets called when the done button has been clicked
       * @protected
       */
      value: function OnDone() {},
      writable: true,
      enumerable: true,
      configurable: true
    },
    context: {

      /**
       * The data that is available to the template
       * @type {Object}
       */
      get: function () {
        return {
          helpers: this._helpers
        };
      },
      enumerable: true,
      configurable: true
    }
  });

  return Control;
})(EventEmitter);

module.exports = Control;

},{"../../../lib/event-emitter":"/Users/sash/development/js/imglykit-rewrite/src/js/lib/event-emitter.js","../../base/helpers":"/Users/sash/development/js/imglykit-rewrite/src/js/ui/base/helpers.js","dot":"/Users/sash/development/js/imglykit-rewrite/node_modules/dot/index.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/ui/night/controls/filters.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Control = _interopRequire(require("./control"));



var FiltersControls = (function (Control) {
  function FiltersControls() {
    if (Object.getPrototypeOf(FiltersControls) !== null) {
      Object.getPrototypeOf(FiltersControls).apply(this, arguments);
    }
  }

  _inherits(FiltersControls, Control);

  _prototypeProperties(FiltersControls, null, {
    init: {
      /**
       * Entry point for this control
       */
      value: function init() {
        var canvasTemplate = "";
        this._canvasControlsTemplate = canvasTemplate;

        var controlsTemplate = "<div class=\"imglykit-controls-filters\">\n  <div class=\"imglykit-controls-button imglykit-controls-back\">\n    <img src=\"{{=it.helpers.assetPath('ui/night/buttons/back.png') }}\" />\n  </div>\n\n  <div>\n    <ul class=\"imglykit-controls-list imgly-controls-list-with-buttons\">\n      {{ for(var identifier in it.filters) { }}\n        {{ var filter = it.filters[identifier]; }}\n        {{ var enabled = it.activeFilter === identifier; }}\n        {{? identifier !== \"identity\"}}\n        <li data-identifier=\"{{= identifier}}\"{{? enabled}} class=\"imglykit-controls-item-active\"{{?}}>\n          <img src=\"{{=it.helpers.assetPath('ui/night/filters/' + identifier + '.png')}}\" />\n        </li>\n        {{?}}\n      {{ } }}\n    </ul>\n  </div>\n\n  <div class=\"imglykit-controls-button imglykit-controls-done\">\n    <img src=\"{{=it.helpers.assetPath('ui/night/buttons/done.png') }}\" />\n  </div>\n</div>\n";
        this._controlsTemplate = controlsTemplate;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _onEnter: {

      /**
       * Gets called when this control is activated
       * @override
       */
      value: function OnEnter() {
        var _this = this;
        this._initialFilter = this._operation.getFilter();

        var listItems = this._controls.querySelectorAll("li");
        this._listItems = Array.prototype.slice.call(listItems);

        // Listen to click events
        for (var _iterator = this._listItems[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
          (function () {
            var listItem = _step.value;
            listItem.addEventListener("click", function () {
              _this._onListItemClick(listItem);
            });
          })();
        }

        // Back button
        var backButton = this._controls.querySelector(".imglykit-controls-back");
        backButton.addEventListener("click", this._onBackButtonClick.bind(this));

        // Done button
        var doneButton = this._controls.querySelector(".imglykit-controls-done");
        doneButton.addEventListener("click", this._onDoneButtonClick.bind(this));
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _onBack: {

      /**
       * Gets called when the user hits the back button
       * @override
       */
      value: function OnBack() {
        this._operation.setFilter(this._initialFilter);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _onListItemClick: {

      /**
       * Gets called when the user clicked a list item
       * @private
       */
      value: function OnListItemClick(item) {
        this._deactivateAllItems();

        var identifier = item.dataset.identifier;
        this._operation.setFilter(identifier);

        item.classList.add("imglykit-controls-item-active");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _deactivateAllItems: {

      /**
       * Deactivates all list items
       * @private
       */
      value: function DeactivateAllItems() {
        for (var _iterator2 = this._listItems[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
          var listItem = _step2.value;
          listItem.classList.remove("imglykit-controls-item-active");
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    context: {

      /**
       * The data that is available to the template
       * @type {Object}
       * @override
       */
      get: function () {
        var context = _get(Object.getPrototypeOf(FiltersControls.prototype), "context", this);
        context.filters = this._operation.filters;
        context.activeFilter = this._operation.getFilter();
        return context;
      },
      enumerable: true,
      configurable: true
    }
  });

  return FiltersControls;
})(Control);

module.exports = FiltersControls;

},{"./control":"/Users/sash/development/js/imglykit-rewrite/src/js/ui/night/controls/control.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/ui/night/controls/rotation.js":[function(require,module,exports){
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */

var Control = _interopRequire(require("./control"));



var RotationControls = (function (Control) {
  function RotationControls() {
    if (Object.getPrototypeOf(RotationControls) !== null) {
      Object.getPrototypeOf(RotationControls).apply(this, arguments);
    }
  }

  _inherits(RotationControls, Control);

  _prototypeProperties(RotationControls, null, {
    init: {
      /**
       * Entry point for this control
       */
      value: function init() {
        var controlsTemplate = "<div class=\"imglykit-controls-rotation\">\n  <div class=\"imglykit-controls-button imglykit-controls-back\">\n    <img src=\"{{=it.helpers.assetPath('ui/night/buttons/back.png') }}\" />\n  </div>\n\n  <div>\n    <ul class=\"imglykit-controls-list imgly-controls-list-with-buttons\">\n      <li data-degrees=\"-90\">\n        <img src=\"{{=it.helpers.assetPath('ui/night/rotation/left.png')}}\" />\n      </li>\n      <li data-degrees=\"90\">\n        <img src=\"{{=it.helpers.assetPath('ui/night/rotation/right.png')}}\" />\n      </li>\n    </ul>\n  </div>\n\n  <div class=\"imglykit-controls-button imglykit-controls-done\">\n    <img src=\"{{=it.helpers.assetPath('ui/night/buttons/done.png') }}\" />\n  </div>\n</div>\n";
        this._controlsTemplate = controlsTemplate;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _onEnter: {

      /**
       * Gets called when this control is activated
       */
      value: function OnEnter() {
        var _this = this;
        this._initialDegrees = this._operation.getDegrees();

        var listItems = this._controls.querySelectorAll("li");
        this._listItems = Array.prototype.slice.call(listItems);

        // Listen to click events
        for (var _iterator = this._listItems[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
          (function () {
            var listItem = _step.value;
            listItem.addEventListener("click", function () {
              _this._onListItemClick(listItem);
            });
          })();
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _onListItemClick: {
      value: function OnListItemClick(item) {
        var degrees = item.dataset.degrees;
        degrees = parseInt(degrees);

        var currentDegrees = this._operation.getDegrees();
        this._operation.setDegrees(currentDegrees + degrees);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _onBack: {

      /**
       * Gets called when the back button has been clicked
       * @override
       */
      value: function OnBack() {
        this._operation.setDegrees(this._initialDegrees);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    context: {

      /**
       * The data that is available to the template
       * @type {Object}
       */
      get: function () {
        var context = _get(Object.getPrototypeOf(RotationControls.prototype), "context", this);
        return context;
      },
      enumerable: true,
      configurable: true
    }
  });

  return RotationControls;
})(Control);

module.exports = RotationControls;

},{"./control":"/Users/sash/development/js/imglykit-rewrite/src/js/ui/night/controls/control.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/ui/night/ui.js":[function(require,module,exports){
/* global ImglyKit */
"use strict";
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

var _interopRequire = function (obj) {
  return obj && (obj["default"] || obj);
};

/*!
 * Copyright (c) 2013-2014 9elements GmbH
 *
 * Released under Attribution-NonCommercial 3.0 Unported
 * http://creativecommons.org/licenses/by-nc/3.0/
 *
 * For commercial use, please contact us at contact@9elements.com
 */


var UI = _interopRequire(require("../base/ui"));

var NightUI = (function (UI) {
  function NightUI() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _get(Object.getPrototypeOf(NightUI.prototype), "constructor", this).apply(this, args);

    this._template = "<div class=\"imglykit-container\">\n  <div class=\"imglykit-canvas-container\">\n    <canvas></canvas>\n    <div class=\"imglykit-canvas-controls-container\"></div>\n  </div>\n\n  <div class=\"imglykit-controls-container\">\n    <div class=\"imglykit-controls\">\n\n      <div>\n        <div class=\"imglykit-controls-overview\">\n          <ul class=\"imglykit-controls-list\">\n          {{~it.operations :operation:index}}\n            <li data-identifier=\"{{= operation.prototype.identifier}}\">\n              <img src=\"{{=it.helpers.assetPath('ui/night/operations/' + operation.prototype.identifier + '.png') }}\" />\n            </li>\n          {{~}}\n          </ul>\n        </div>\n      </div>\n\n    </div>\n  </div>\n</div>\n";
    this._registeredControls = {};

    // The `Night` UI has a fixed operation order
    this._preferredOperationOrder = [
    // First, all operations that affect the image dimensions
    "crop", "rotation", "flip",

    // Then color operations (first filters, then fine-tuning)
    "filters", "contrast", "brightness", "saturation",

    // Then post-processing
    "noise",

    // Everything else on top
    "text", "stickers", "frames"];
  }

  _inherits(NightUI, UI);

  _prototypeProperties(NightUI, null, {
    run: {
      value: function run() {
        _get(Object.getPrototypeOf(NightUI.prototype), "run", this).call(this);

        var container = this._options.container;


        this._controlsContainer = container.querySelector(".imglykit-controls");
        this._canvasControlsContainer = container.querySelector(".imglykit-canvas-controls-container");
        this._overviewControlsContainer = container.querySelector(".imglykit-controls-overview");

        this._operationsMap = {};

        this._initOperations();
        this._registerControls();
        this._handleOverview();
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _initOperations: {

      /**
       * Initializes all operations
       * @private
       */
      value: function InitOperations() {
        var operationsStack = this._kit.operationsStack;
        var registeredOperations = this._kit.registeredOperations;
        for (var _iterator = this._preferredOperationOrder[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
          var operationIdentifier = _step.value;
          if (this.isOperationSelected(operationIdentifier)) {
            var Operation = registeredOperations[operationIdentifier];
            var operationInstance = new Operation(this._kit);
            this._operationsMap[operationIdentifier] = operationInstance;
            operationsStack.push(operationInstance);
          }
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _registerControls: {

      /**
       * Registers all default operation controls
       * @private
       */
      value: function RegisterControls() {
        this.registerControl(this._operationsMap.filters, require("./controls/filters"));
        this.registerControl(this._operationsMap.rotation, require("./controls/rotation"));
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _handleOverview: {

      /**
       * Handles the overview button click events
       * @private
       */
      value: function HandleOverview() {
        var _this = this;
        var listItems = this._overviewControlsContainer.querySelectorAll(":scope > ul > li");

        // Turn NodeList into an Array
        listItems = Array.prototype.slice.call(listItems);

        // Add click events to all items
        for (var _iterator2 = listItems[Symbol.iterator](), _step2; !(_step2 = _iterator2.next()).done;) {
          (function () {
            var listItem = _step2.value;
            var identifier = listItem.dataset.identifier;
            listItem.addEventListener("click", function () {
              _this._onOverviewButtonClick(identifier);
            });
          })();
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _onOverviewButtonClick: {

      /**
       * Gets called when an overview button has been clicked
       * @private
       */
      value: function OnOverviewButtonClick(identifier) {
        this._overviewControlsContainer.style.display = "none";

        if (this._currentControl) {
          this._currentControl.leave();
        }

        this._currentControl = this._registeredControls[identifier];
        this._currentControl.enter();
        this._currentControl.once("back", this._switchToOverview.bind(this));
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _switchToOverview: {

      /**
       * Switches back to the overview controls
       * @private
       */
      value: function SwitchToOverview() {
        if (this._currentControl) {
          this._currentControl.leave();
        }

        this._currentControl = null;
        this._overviewControlsContainer.style.display = "block";
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    registerControl: {

      /**
       * Registers the controls for an operation
       */
      value: function registerControl(operation, Controls) {
        var instance = new Controls(this._kit, this, operation, this._controlsContainer, this._canvasControlsContainer);
        this._registeredControls[operation.identifier] = instance;
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return NightUI;
})(UI);

module.exports = NightUI;

},{"../base/ui":"/Users/sash/development/js/imglykit-rewrite/src/js/ui/base/ui.js","./controls/filters":"/Users/sash/development/js/imglykit-rewrite/src/js/ui/night/controls/filters.js","./controls/rotation":"/Users/sash/development/js/imglykit-rewrite/src/js/ui/night/controls/rotation.js"}],"/Users/sash/development/js/imglykit-rewrite/src/js/vendor/stack-blur.js":[function(require,module,exports){
"use strict";
/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version:  0.5
Author:   Mario Klingemann
Contact:  mario@quasimondo.com
Website:  http://www.quasimondo.com/StackBlurForCanvas
Twitter:  @quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr:
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

var mul_table = [
        512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
        454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
        482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
        437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
        497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
        320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
        446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
        329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
        505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
        399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
        324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
        268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
        451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
        385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
        332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
        289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];


var shg_table = [
       9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
    17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
    19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
    21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
    21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
    23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];

function stackBlurCanvasRGBA( imageData, top_x, top_y, width, height, radius )
{
  if ( isNaN(radius) || radius < 1 ) return;
  radius |= 0;

  var pixels = imageData.data;

  var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum,
  r_out_sum, g_out_sum, b_out_sum, a_out_sum,
  r_in_sum, g_in_sum, b_in_sum, a_in_sum,
  pr, pg, pb, pa, rbs;

  var div = radius + radius + 1;
  var widthMinus1  = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1  = radius + 1;
  var sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;

  var stackStart = new BlurStack();
  var stackEnd;
  var stack = stackStart;
  for ( i = 1; i < div; i++ )
  {
    stack = stack.next = new BlurStack();
    if ( i == radiusPlus1 ) stackEnd = stack;
  }
  stack.next = stackStart;
  var stackIn = null;
  var stackOut = null;

  yw = yi = 0;

  var mul_sum = mul_table[radius];
  var shg_sum = shg_table[radius];

  for ( y = 0; y < height; y++ )
  {
    r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

    r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
    g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
    b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );
    a_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );

    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;

    stack = stackStart;

    for( i = 0; i < radiusPlus1; i++ )
    {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }

    for( i = 1; i < radiusPlus1; i++ )
    {
      p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
      r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
      g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
      b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;
      a_sum += ( stack.a = ( pa = pixels[p+3])) * rbs;

      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;

      stack = stack.next;
    }


    stackIn = stackStart;
    stackOut = stackEnd;
    for ( x = 0; x < width; x++ )
    {
      pixels[yi+3] = pa = (a_sum * mul_sum) >> shg_sum;
      if ( pa !== 0 )
      {
        pa = 255 / pa;
        pixels[yi]   = ((r_sum * mul_sum) >> shg_sum) * pa;
        pixels[yi+1] = ((g_sum * mul_sum) >> shg_sum) * pa;
        pixels[yi+2] = ((b_sum * mul_sum) >> shg_sum) * pa;
      } else {
        pixels[yi] = pixels[yi+1] = pixels[yi+2] = 0;
      }

      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;

      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;

      p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;

      r_in_sum += ( stackIn.r = pixels[p]);
      g_in_sum += ( stackIn.g = pixels[p+1]);
      b_in_sum += ( stackIn.b = pixels[p+2]);
      a_in_sum += ( stackIn.a = pixels[p+3]);

      r_sum += r_in_sum;
      g_sum += g_in_sum;
      b_sum += b_in_sum;
      a_sum += a_in_sum;

      stackIn = stackIn.next;

      r_out_sum += ( pr = stackOut.r );
      g_out_sum += ( pg = stackOut.g );
      b_out_sum += ( pb = stackOut.b );
      a_out_sum += ( pa = stackOut.a );

      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;

      stackOut = stackOut.next;

      yi += 4;
    }
    yw += width;
  }


  for ( x = 0; x < width; x++ )
  {
    g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

    yi = x << 2;
    r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
    g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
    b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);
    a_out_sum = radiusPlus1 * ( pa = pixels[yi+3]);

    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;

    stack = stackStart;

    for( i = 0; i < radiusPlus1; i++ )
    {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }

    yp = width;

    for( i = 1; i <= radius; i++ )
    {
      yi = ( yp + x ) << 2;

      r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
      g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
      b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;
      a_sum += ( stack.a = ( pa = pixels[yi+3])) * rbs;

      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;

      stack = stack.next;

      if( i < heightMinus1 )
      {
        yp += width;
      }
    }

    yi = x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for ( y = 0; y < height; y++ )
    {
      p = yi << 2;
      pixels[p+3] = pa = (a_sum * mul_sum) >> shg_sum;
      if ( pa > 0 )
      {
        pa = 255 / pa;
        pixels[p]   = ((r_sum * mul_sum) >> shg_sum ) * pa;
        pixels[p+1] = ((g_sum * mul_sum) >> shg_sum ) * pa;
        pixels[p+2] = ((b_sum * mul_sum) >> shg_sum ) * pa;
      } else {
        pixels[p] = pixels[p+1] = pixels[p+2] = 0;
      }

      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;

      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;

      p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;

      r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
      g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
      b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));
      a_sum += ( a_in_sum += ( stackIn.a = pixels[p+3]));

      stackIn = stackIn.next;

      r_out_sum += ( pr = stackOut.r );
      g_out_sum += ( pg = stackOut.g );
      b_out_sum += ( pb = stackOut.b );
      a_out_sum += ( pa = stackOut.a );

      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;

      stackOut = stackOut.next;

      yi += width;
    }
  }
}

function BlurStack()
{
  this.r = 0;
  this.g = 0;
  this.b = 0;
  this.a = 0;
  this.next = null;
}

module.exports = {
  stackBlurCanvasRGBA: stackBlurCanvasRGBA
};

},{}],"lodash":[function(require,module,exports){
(function (global){
/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash include="defaults,extend"`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;(function() {

  /** Used internally to indicate various things */
  var indicatorObject = {};

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to fix the JScript [[DontEnum]] bug */
  var shadowedProps = [
    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
    'toLocaleString', 'toString', 'valueOf'
  ];

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      errorClass = '[object Error]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used as the data object for `iteratorTemplate` */
  var iteratorData = {
    'args': '',
    'array': null,
    'bottom': '',
    'firstArg': '',
    'init': '',
    'keys': null,
    'loop': '',
    'shadowedProps': null,
    'support': null,
    'top': '',
    'useHas': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Used for `Array` method references.
   *
   * Normally `Array.prototype` would suffice, however, using an array literal
   * avoids issues in Narwhal.
   */
  var arrayRef = [];

  /** Used for native method references */
  var errorProto = Error.prototype,
      objectProto = Object.prototype,
      stringProto = String.prototype;

  /** Used to resolve the internal [[Class]] of values */
  var toString = objectProto.toString;

  /** Used to detect if a method is native */
  var reNative = RegExp('^' +
    String(toString)
      .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
      .replace(/toString| for [^\]]+/g, '.*?') + '$'
  );

  /** Native method shortcuts */
  var fnToString = Function.prototype.toString,
      hasOwnProperty = objectProto.hasOwnProperty,
      push = arrayRef.push,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      unshift = arrayRef.unshift;

  /** Used to set meta data on functions */
  var defineProperty = (function() {
    // IE 8 only accepts DOM elements
    try {
      var o = {},
          func = isNative(func = Object.defineProperty) && func,
          result = func(o, o, o) && func;
    } catch(e) { }
    return result;
  }());

  /* Native method shortcuts for methods with the same name as other `lodash` methods */
  var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
      nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
      nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;

  /** Used to avoid iterating non-enumerable properties in IE < 9 */
  var nonEnumProps = {};
  nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
  nonEnumProps[boolClass] = nonEnumProps[stringClass] = { 'constructor': true, 'toString': true, 'valueOf': true };
  nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { 'constructor': true, 'toString': true };
  nonEnumProps[objectClass] = { 'constructor': true };

  (function() {
    var length = shadowedProps.length;
    while (length--) {
      var key = shadowedProps[length];
      for (var className in nonEnumProps) {
        if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {
          nonEnumProps[className][key] = false;
        }
      }
    }
  }());

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object which wraps the given value to enable intuitive
   * method chaining.
   *
   * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
   * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
   * and `unshift`
   *
   * Chaining is supported in custom builds as long as the `value` method is
   * implicitly or explicitly included in the build.
   *
   * The chainable wrapper functions are:
   * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
   * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
   * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
   * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
   * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
   * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
   * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
   * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
   * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
   * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
   * and `zip`
   *
   * The non-chainable wrapper functions are:
   * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
   * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
   * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
   * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
   * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
   * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
   * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
   * `template`, `unescape`, `uniqueId`, and `value`
   *
   * The wrapper functions `first` and `last` return wrapped values when `n` is
   * provided, otherwise they return unwrapped values.
   *
   * Explicit chaining can be enabled by using the `_.chain` method.
   *
   * @name _
   * @constructor
   * @category Chaining
   * @param {*} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns a `lodash` instance.
   * @example
   *
   * var wrapped = _([1, 2, 3]);
   *
   * // returns an unwrapped value
   * wrapped.reduce(function(sum, num) {
   *   return sum + num;
   * });
   * // => 6
   *
   * // returns a wrapped value
   * var squares = wrapped.map(function(num) {
   *   return num * num;
   * });
   *
   * _.isArray(squares);
   * // => false
   *
   * _.isArray(squares.value());
   * // => true
   */
  function lodash() {
    // no operation performed
  }

  /**
   * An object used to flag environments features.
   *
   * @static
   * @memberOf _
   * @type Object
   */
  var support = lodash.support = {};

  (function() {
    var ctor = function() { this.x = 1; },
        object = { '0': 1, 'length': 1 },
        props = [];

    ctor.prototype = { 'valueOf': 1, 'y': 1 };
    for (var key in new ctor) { props.push(key); }
    for (key in arguments) { }

    /**
     * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox < 4, IE < 9).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.argsClass = toString.call(arguments) == argsClass;

    /**
     * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera < 10.5).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);

    /**
     * Detect if `name` or `message` properties of `Error.prototype` are
     * enumerable by default. (IE < 9, Safari < 5.1)
     *
     * @memberOf _.support
     * @type boolean
     */
    support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');

    /**
     * Detect if `prototype` properties are enumerable by default.
     *
     * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
     * (if the prototype or a property on the prototype has been set)
     * incorrectly sets a function's `prototype` property [[Enumerable]]
     * value to `true`.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(root.WinRTError) && reThis.test(function() { return this; });

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * Detect if `arguments` object indexes are non-enumerable
     * (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.nonEnumArgs = key != 0;

    /**
     * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
     *
     * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
     * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.nonEnumShadows = !/valueOf/.test(props);

    /**
     * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
     *
     * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
     * and `splice()` functions that fail to remove the last element, `value[0]`,
     * of array-like objects even though the `length` property is set to `0`.
     * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
     * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);

    /**
     * Detect lack of support for accessing string characters by index.
     *
     * IE < 8 can't access characters by index and IE 8 can only access
     * characters by index on string literals.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';
  }(1));

  /*--------------------------------------------------------------------------*/

  /**
   * The template used to create iterator functions.
   *
   * @private
   * @param {Object} data The data object used to populate the text.
   * @returns {string} Returns the interpolated text.
   */
  var iteratorTemplate = function(obj) {

    var __p = 'var index, iterable = ' +
    (obj.firstArg) +
    ', result = ' +
    (obj.init) +
    ';\nif (!iterable) return result;\n' +
    (obj.top) +
    ';';
     if (obj.array) {
    __p += '\nvar length = iterable.length; index = -1;\nif (' +
    (obj.array) +
    ') {  ';
     if (support.unindexedChars) {
    __p += '\n  if (isString(iterable)) {\n    iterable = iterable.split(\'\')\n  }  ';
     }
    __p += '\n  while (++index < length) {\n    ' +
    (obj.loop) +
    ';\n  }\n}\nelse {  ';
     } else if (support.nonEnumArgs) {
    __p += '\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += \'\';\n      ' +
    (obj.loop) +
    ';\n    }\n  } else {  ';
     }

     if (support.enumPrototypes) {
    __p += '\n  var skipProto = typeof iterable == \'function\';\n  ';
     }

     if (support.enumErrorProps) {
    __p += '\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ';
     }

        var conditions = [];    if (support.enumPrototypes) { conditions.push('!(skipProto && index == "prototype")'); }    if (support.enumErrorProps)  { conditions.push('!(skipErrorProps && (index == "message" || index == "name"))'); }

     if (obj.useHas && obj.keys) {
    __p += '\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\n      length = ownProps ? ownProps.length : 0;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n';
        if (conditions.length) {
    __p += '    if (' +
    (conditions.join(' && ')) +
    ') {\n  ';
     }
    __p +=
    (obj.loop) +
    ';    ';
     if (conditions.length) {
    __p += '\n    }';
     }
    __p += '\n  }  ';
     } else {
    __p += '\n  for (index in iterable) {\n';
        if (obj.useHas) { conditions.push("hasOwnProperty.call(iterable, index)"); }    if (conditions.length) {
    __p += '    if (' +
    (conditions.join(' && ')) +
    ') {\n  ';
     }
    __p +=
    (obj.loop) +
    ';    ';
     if (conditions.length) {
    __p += '\n    }';
     }
    __p += '\n  }    ';
     if (support.nonEnumShadows) {
    __p += '\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ';
     for (k = 0; k < 7; k++) {
    __p += '\n    index = \'' +
    (obj.shadowedProps[k]) +
    '\';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))';
            if (!obj.useHas) {
    __p += ' || (!nonEnum[index] && iterable[index] !== objectProto[index])';
     }
    __p += ') {\n      ' +
    (obj.loop) +
    ';\n    }      ';
     }
    __p += '\n  }    ';
     }

     }

     if (obj.array || support.nonEnumArgs) {
    __p += '\n}';
     }
    __p +=
    (obj.bottom) +
    ';\nreturn result';

    return __p
  };

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.bind` that creates the bound function and
   * sets its meta data.
   *
   * @private
   * @param {Array} bindData The bind data array.
   * @returns {Function} Returns the new bound function.
   */
  function baseBind(bindData) {
    var func = bindData[0],
        partialArgs = bindData[2],
        thisArg = bindData[4];

    function bound() {
      // `Function#bind` spec
      // http://es5.github.io/#x15.3.4.5
      if (partialArgs) {
        // avoid `arguments` object deoptimizations by using `slice` instead
        // of `Array.prototype.slice.call` and not assigning `arguments` to a
        // variable as a ternary expression
        var args = slice(partialArgs);
        push.apply(args, arguments);
      }
      // mimic the constructor's `return` behavior
      // http://es5.github.io/#x13.2.2
      if (this instanceof bound) {
        // ensure `new bound` is an instance of `func`
        var thisBinding = baseCreate(func.prototype),
            result = func.apply(thisBinding, args || arguments);
        return isObject(result) ? result : thisBinding;
      }
      return func.apply(thisArg, args || arguments);
    }
    setBindData(bound, bindData);
    return bound;
  }

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} prototype The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  function baseCreate(prototype, properties) {
    return isObject(prototype) ? nativeCreate(prototype) : {};
  }
  // fallback for browsers without `Object.create`
  if (!nativeCreate) {
    baseCreate = (function() {
      function Object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          Object.prototype = prototype;
          var result = new Object;
          Object.prototype = null;
        }
        return result || root.Object();
      };
    }());
  }

  /**
   * The base implementation of `_.createCallback` without support for creating
   * "_.pluck" or "_.where" style callbacks.
   *
   * @private
   * @param {*} [func=identity] The value to convert to a callback.
   * @param {*} [thisArg] The `this` binding of the created callback.
   * @param {number} [argCount] The number of arguments the callback accepts.
   * @returns {Function} Returns a callback function.
   */
  function baseCreateCallback(func, thisArg, argCount) {
    if (typeof func != 'function') {
      return identity;
    }
    // exit early for no `thisArg` or already bound by `Function#bind`
    if (typeof thisArg == 'undefined' || !('prototype' in func)) {
      return func;
    }
    var bindData = func.__bindData__;
    if (typeof bindData == 'undefined') {
      if (support.funcNames) {
        bindData = !func.name;
      }
      bindData = bindData || !support.funcDecomp;
      if (!bindData) {
        var source = fnToString.call(func);
        if (!support.funcNames) {
          bindData = !reFuncName.test(source);
        }
        if (!bindData) {
          // checks if `func` references the `this` keyword and stores the result
          bindData = reThis.test(source);
          setBindData(func, bindData);
        }
      }
    }
    // exit early if there are no `this` references or `func` is bound
    if (bindData === false || (bindData !== true && bindData[1] & 1)) {
      return func;
    }
    switch (argCount) {
      case 1: return function(value) {
        return func.call(thisArg, value);
      };
      case 2: return function(a, b) {
        return func.call(thisArg, a, b);
      };
      case 3: return function(value, index, collection) {
        return func.call(thisArg, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(thisArg, accumulator, value, index, collection);
      };
    }
    return bind(func, thisArg);
  }

  /**
   * The base implementation of `createWrapper` that creates the wrapper and
   * sets its meta data.
   *
   * @private
   * @param {Array} bindData The bind data array.
   * @returns {Function} Returns the new function.
   */
  function baseCreateWrapper(bindData) {
    var func = bindData[0],
        bitmask = bindData[1],
        partialArgs = bindData[2],
        partialRightArgs = bindData[3],
        thisArg = bindData[4],
        arity = bindData[5];

    var isBind = bitmask & 1,
        isBindKey = bitmask & 2,
        isCurry = bitmask & 4,
        isCurryBound = bitmask & 8,
        key = func;

    function bound() {
      var thisBinding = isBind ? thisArg : this;
      if (partialArgs) {
        var args = slice(partialArgs);
        push.apply(args, arguments);
      }
      if (partialRightArgs || isCurry) {
        args || (args = slice(arguments));
        if (partialRightArgs) {
          push.apply(args, partialRightArgs);
        }
        if (isCurry && args.length < arity) {
          bitmask |= 16 & ~32;
          return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
        }
      }
      args || (args = arguments);
      if (isBindKey) {
        func = thisBinding[key];
      }
      if (this instanceof bound) {
        thisBinding = baseCreate(func.prototype);
        var result = func.apply(thisBinding, args);
        return isObject(result) ? result : thisBinding;
      }
      return func.apply(thisBinding, args);
    }
    setBindData(bound, bindData);
    return bound;
  }

  /**
   * Creates a function that, when called, either curries or invokes `func`
   * with an optional `this` binding and partially applied arguments.
   *
   * @private
   * @param {Function|string} func The function or method name to reference.
   * @param {number} bitmask The bitmask of method flags to compose.
   *  The bitmask may be composed of the following flags:
   *  1 - `_.bind`
   *  2 - `_.bindKey`
   *  4 - `_.curry`
   *  8 - `_.curry` (bound)
   *  16 - `_.partial`
   *  32 - `_.partialRight`
   * @param {Array} [partialArgs] An array of arguments to prepend to those
   *  provided to the new function.
   * @param {Array} [partialRightArgs] An array of arguments to append to those
   *  provided to the new function.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new function.
   */
  function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
    var isBind = bitmask & 1,
        isBindKey = bitmask & 2,
        isCurry = bitmask & 4,
        isCurryBound = bitmask & 8,
        isPartial = bitmask & 16,
        isPartialRight = bitmask & 32;

    if (!isBindKey && !isFunction(func)) {
      throw new TypeError;
    }
    if (isPartial && !partialArgs.length) {
      bitmask &= ~16;
      isPartial = partialArgs = false;
    }
    if (isPartialRight && !partialRightArgs.length) {
      bitmask &= ~32;
      isPartialRight = partialRightArgs = false;
    }
    var bindData = func && func.__bindData__;
    if (bindData && bindData !== true) {
      // clone `bindData`
      bindData = slice(bindData);
      if (bindData[2]) {
        bindData[2] = slice(bindData[2]);
      }
      if (bindData[3]) {
        bindData[3] = slice(bindData[3]);
      }
      // set `thisBinding` is not previously bound
      if (isBind && !(bindData[1] & 1)) {
        bindData[4] = thisArg;
      }
      // set if previously bound but not currently (subsequent curried functions)
      if (!isBind && bindData[1] & 1) {
        bitmask |= 8;
      }
      // set curried arity if not yet set
      if (isCurry && !(bindData[1] & 4)) {
        bindData[5] = arity;
      }
      // append partial left arguments
      if (isPartial) {
        push.apply(bindData[2] || (bindData[2] = []), partialArgs);
      }
      // append partial right arguments
      if (isPartialRight) {
        unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
      }
      // merge flags
      bindData[1] |= bitmask;
      return createWrapper.apply(null, bindData);
    }
    // fast path for `_.bind`
    var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
    return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
  }

  /**
   * Creates compiled iteration functions.
   *
   * @private
   * @param {...Object} [options] The compile options object(s).
   * @param {string} [options.array] Code to determine if the iterable is an array or array-like.
   * @param {boolean} [options.useHas] Specify using `hasOwnProperty` checks in the object loop.
   * @param {Function} [options.keys] A reference to `_.keys` for use in own property iteration.
   * @param {string} [options.args] A comma separated string of iteration function arguments.
   * @param {string} [options.top] Code to execute before the iteration branches.
   * @param {string} [options.loop] Code to execute in the object loop.
   * @param {string} [options.bottom] Code to execute after the iteration branches.
   * @returns {Function} Returns the compiled function.
   */
  function createIterator() {
    // data properties
    iteratorData.shadowedProps = shadowedProps;

    // iterator options
    iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = '';
    iteratorData.init = 'iterable';
    iteratorData.useHas = true;

    // merge options into a template data object
    for (var object, index = 0; object = arguments[index]; index++) {
      for (var key in object) {
        iteratorData[key] = object[key];
      }
    }
    var args = iteratorData.args;
    iteratorData.firstArg = /^[^,]+/.exec(args)[0];

    // create the function factory
    var factory = Function(
        'baseCreateCallback, errorClass, errorProto, hasOwnProperty, ' +
        'indicatorObject, isArguments, isArray, isString, keys, objectProto, ' +
        'objectTypes, nonEnumProps, stringClass, stringProto, toString',
      'return function(' + args + ') {\n' + iteratorTemplate(iteratorData) + '\n}'
    );

    // return the compiled function
    return factory(
      baseCreateCallback, errorClass, errorProto, hasOwnProperty,
      indicatorObject, isArguments, isArray, isString, iteratorData.keys, objectProto,
      objectTypes, nonEnumProps, stringClass, stringProto, toString
    );
  }

  /**
   * Checks if `value` is a native function.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
   */
  function isNative(value) {
    return typeof value == 'function' && reNative.test(value);
  }

  /**
   * Sets `this` binding data on a given function.
   *
   * @private
   * @param {Function} func The function to set data on.
   * @param {Array} value The data array to set.
   */
  var setBindData = !defineProperty ? noop : function(func, value) {
    descriptor.value = value;
    defineProperty(func, '__bindData__', descriptor);
  };

  /*--------------------------------------------------------------------------*/

  /**
   * Checks if `value` is an `arguments` object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
   * @example
   *
   * (function() { return _.isArguments(arguments); })(1, 2, 3);
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  function isArguments(value) {
    return value && typeof value == 'object' && typeof value.length == 'number' &&
      toString.call(value) == argsClass || false;
  }
  // fallback for browsers that can't detect `arguments` objects by [[Class]]
  if (!support.argsClass) {
    isArguments = function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee') || false;
    };
  }

  /**
   * Checks if `value` is an array.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
   * @example
   *
   * (function() { return _.isArray(arguments); })();
   * // => false
   *
   * _.isArray([1, 2, 3]);
   * // => true
   */
  var isArray = nativeIsArray || function(value) {
    return value && typeof value == 'object' && typeof value.length == 'number' &&
      toString.call(value) == arrayClass || false;
  };

  /**
   * A fallback implementation of `Object.keys` which produces an array of the
   * given object's own enumerable property names.
   *
   * @private
   * @type Function
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property names.
   */
  var shimKeys = createIterator({
    'args': 'object',
    'init': '[]',
    'top': 'if (!(objectTypes[typeof object])) return result',
    'loop': 'result.push(index)'
  });

  /**
   * Creates an array composed of the own enumerable property names of an object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property names.
   * @example
   *
   * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
   * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
   */
  var keys = !nativeKeys ? shimKeys : function(object) {
    if (!isObject(object)) {
      return [];
    }
    if ((support.enumPrototypes && typeof object == 'function') ||
        (support.nonEnumArgs && object.length && isArguments(object))) {
      return shimKeys(object);
    }
    return nativeKeys(object);
  };

  /** Reusable iterator options for `assign` and `defaults` */
  var defaultsIteratorOptions = {
    'args': 'object, source, guard',
    'top':
      'var args = arguments,\n' +
      '    argsIndex = 0,\n' +
      "    argsLength = typeof guard == 'number' ? 2 : args.length;\n" +
      'while (++argsIndex < argsLength) {\n' +
      '  iterable = args[argsIndex];\n' +
      '  if (iterable && objectTypes[typeof iterable]) {',
    'keys': keys,
    'loop': "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
    'bottom': '  }\n}'
  };

  /*--------------------------------------------------------------------------*/

  /**
   * Assigns own enumerable properties of source object(s) to the destination
   * object. Subsequent sources will overwrite property assignments of previous
   * sources. If a callback is provided it will be executed to produce the
   * assigned values. The callback is bound to `thisArg` and invoked with two
   * arguments; (objectValue, sourceValue).
   *
   * @static
   * @memberOf _
   * @type Function
   * @alias extend
   * @category Objects
   * @param {Object} object The destination object.
   * @param {...Object} [source] The source objects.
   * @param {Function} [callback] The function to customize assigning values.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the destination object.
   * @example
   *
   * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
   * // => { 'name': 'fred', 'employer': 'slate' }
   *
   * var defaults = _.partialRight(_.assign, function(a, b) {
   *   return typeof a == 'undefined' ? b : a;
   * });
   *
   * var object = { 'name': 'barney' };
   * defaults(object, { 'name': 'fred', 'employer': 'slate' });
   * // => { 'name': 'barney', 'employer': 'slate' }
   */
  var assign = createIterator(defaultsIteratorOptions, {
    'top':
      defaultsIteratorOptions.top.replace(';',
        ';\n' +
        "if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n" +
        '  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n' +
        "} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n" +
        '  callback = args[--argsLength];\n' +
        '}'
      ),
    'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'
  });

  /**
   * Assigns own enumerable properties of source object(s) to the destination
   * object for all destination properties that resolve to `undefined`. Once a
   * property is set, additional defaults of the same property will be ignored.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {Object} object The destination object.
   * @param {...Object} [source] The source objects.
   * @param- {Object} [guard] Allows working with `_.reduce` without using its
   *  `key` and `object` arguments as sources.
   * @returns {Object} Returns the destination object.
   * @example
   *
   * var object = { 'name': 'barney' };
   * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
   * // => { 'name': 'barney', 'employer': 'slate' }
   */
  var defaults = createIterator(defaultsIteratorOptions);

  /**
   * Checks if `value` is a function.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   */
  function isFunction(value) {
    return typeof value == 'function';
  }
  // fallback for older versions of Chrome and Safari
  if (isFunction(/x/)) {
    isFunction = function(value) {
      return typeof value == 'function' && toString.call(value) == funcClass;
    };
  }

  /**
   * Checks if `value` is the language type of Object.
   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(1);
   * // => false
   */
  function isObject(value) {
    // check if the value is the ECMAScript language type of Object
    // http://es5.github.io/#x8
    // and avoid a V8 bug
    // http://code.google.com/p/v8/issues/detail?id=2291
    return !!(value && objectTypes[typeof value]);
  }

  /**
   * Checks if `value` is a string.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
   * @example
   *
   * _.isString('fred');
   * // => true
   */
  function isString(value) {
    return typeof value == 'string' ||
      value && typeof value == 'object' && toString.call(value) == stringClass || false;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a function that, when called, invokes `func` with the `this`
   * binding of `thisArg` and prepends any additional `bind` arguments to those
   * provided to the bound function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to bind.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {...*} [arg] Arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   * @example
   *
   * var func = function(greeting) {
   *   return greeting + ' ' + this.name;
   * };
   *
   * func = _.bind(func, { 'name': 'fred' }, 'hi');
   * func();
   * // => 'hi fred'
   */
  function bind(func, thisArg) {
    return arguments.length > 2
      ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
      : createWrapper(func, 1, null, null, thisArg);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * This method returns the first argument provided to it.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'name': 'fred' };
   * _.identity(object) === object;
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * A no-operation function.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @example
   *
   * var object = { 'name': 'fred' };
   * _.noop(object) === undefined;
   * // => true
   */
  function noop() {
    // no operation performed
  }

  /*--------------------------------------------------------------------------*/

  lodash.assign = assign;
  lodash.bind = bind;
  lodash.defaults = defaults;
  lodash.keys = keys;

  lodash.extend = assign;

  /*--------------------------------------------------------------------------*/

  lodash.identity = identity;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isFunction = isFunction;
  lodash.isObject = isObject;
  lodash.isString = isString;
  lodash.noop = noop;

  /*--------------------------------------------------------------------------*/

  /**
   * The semantic version number.
   *
   * @static
   * @memberOf _
   * @type string
   */
  lodash.VERSION = '2.4.1';

  /*--------------------------------------------------------------------------*/

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = lodash;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return lodash;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = lodash)._ = lodash;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = lodash;
    }
  }
  else {
    // in a browser or Rhino
    root._ = lodash;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},["./index.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL21haW4vYW55LmpzIiwibm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL21haW4vYXN5bmMuanMiLCJub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvbWFpbi9ibHVlYmlyZC5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9tYWluL2NhbGxfZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL21haW4vY2FuY2VsLmpzIiwibm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL21haW4vY2FwdHVyZWRfdHJhY2UuanMiLCJub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvbWFpbi9jYXRjaF9maWx0ZXIuanMiLCJub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvbWFpbi9kaXJlY3RfcmVzb2x2ZS5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9tYWluL2VhY2guanMiLCJub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvbWFpbi9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvbWFpbi9lcnJvcnNfYXBpX3JlamVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9tYWluL2VzNS5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9tYWluL2ZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9tYWluL2ZpbmFsbHkuanMiLCJub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvbWFpbi9nZW5lcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL21haW4vam9pbi5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9tYWluL21hcC5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9tYWluL25vZGVpZnkuanMiLCJub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvbWFpbi9wcm9ncmVzcy5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9tYWluL3Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvbWFpbi9wcm9taXNlX2FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL21haW4vcHJvbWlzZV9yZXNvbHZlci5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9tYWluL3Byb21pc2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9tYWluL3Byb3BzLmpzIiwibm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL21haW4vcXVldWUuanMiLCJub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvbWFpbi9yYWNlLmpzIiwibm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL21haW4vcmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL21haW4vc2NoZWR1bGUuanMiLCJub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvbWFpbi9zZXR0bGUuanMiLCJub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvbWFpbi9zb21lLmpzIiwibm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL21haW4vc3luY2hyb25vdXNfaW5zcGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9tYWluL3RoZW5hYmxlcy5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9tYWluL3RpbWVycy5qcyIsIm5vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9tYWluL3VzaW5nLmpzIiwibm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL21haW4vdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L2xpYi9fZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9kb3QvZG9ULmpzIiwibm9kZV9tb2R1bGVzL2RvdC9pbmRleC5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL2NvbnN0YW50cy5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL2ltZ2x5a2l0LmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvbGliL2NvbG9yLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvbGliL2V2ZW50LWVtaXR0ZXIuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9saWIvZXh0ZW5kLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvbGliL2ltYWdlLWRpbWVuc2lvbnMuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9saWIvaW1hZ2UtZXhwb3J0ZXIuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9saWIvbWF0aC92ZWN0b3IyLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvbGliL3JlbmRlci1pbWFnZS5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL2xpYi91dGlscy5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvYnJpZ2h0bmVzcy1vcGVyYXRpb24uanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL2NvbnRyYXN0LW9wZXJhdGlvbi5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvY3JvcC1vcGVyYXRpb24uanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL2ZpbHRlcnMtb3BlcmF0aW9uLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvb3BlcmF0aW9ucy9maWx0ZXJzL2ExNS1maWx0ZXIuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL2ZpbHRlcnMvYnJlZXplLWZpbHRlci5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9idy1maWx0ZXIuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL2ZpbHRlcnMvYndoYXJkLWZpbHRlci5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9jZWxzaXVzLWZpbHRlci5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9jaGVzdC1maWx0ZXIuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL2ZpbHRlcnMvZmlsdGVyLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvb3BlcmF0aW9ucy9maWx0ZXJzL2ZpeGllLWZpbHRlci5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9mb29kLWZpbHRlci5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9mcmlkZ2UtZmlsdGVyLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvb3BlcmF0aW9ucy9maWx0ZXJzL2Zyb250LWZpbHRlci5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9nbGFtLWZpbHRlci5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9nb2JibGluLWZpbHRlci5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9pZGVudGl0eS1maWx0ZXIuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL2ZpbHRlcnMvazEtZmlsdGVyLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvb3BlcmF0aW9ucy9maWx0ZXJzL2syLWZpbHRlci5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9rNi1maWx0ZXIuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL2ZpbHRlcnMva2R5bmFtaWMtZmlsdGVyLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvb3BlcmF0aW9ucy9maWx0ZXJzL2xlbmluLWZpbHRlci5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9sb21vLWZpbHRlci5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9tZWxsb3ctZmlsdGVyLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvb3BlcmF0aW9ucy9maWx0ZXJzL21vcm5pbmctZmlsdGVyLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvb3BlcmF0aW9ucy9maWx0ZXJzL29yY2hpZC1maWx0ZXIuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL2ZpbHRlcnMvcG9sYS1maWx0ZXIuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL2ZpbHRlcnMvcG9sYTY2OS1maWx0ZXIuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy1zdGFjay5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2JyaWdodG5lc3MuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9jb250cmFzdC5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2Rlc2F0dXJhdGlvbi5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2dsb3cuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9nb2JibGluLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvZ3JheXNjYWxlLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvbG9va3VwLXRhYmxlLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvcHJpbWl0aXZlLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvc2F0dXJhdGlvbi5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL3NvZnQtY29sb3Itb3ZlcmxheS5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL3RvbmUtY3VydmUuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy94NDAwLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvb3BlcmF0aW9ucy9maWx0ZXJzL3F1b3ppLWZpbHRlci5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9zZW1pcmVkLWZpbHRlci5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZmlsdGVycy9zdW5ueS1maWx0ZXIuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL2ZpbHRlcnMvdGV4YXMtZmlsdGVyLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvb3BlcmF0aW9ucy9maWx0ZXJzL3g0MDAtZmlsdGVyLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvb3BlcmF0aW9ucy9mbGlwLW9wZXJhdGlvbi5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvZnJhbWVzLW9wZXJhdGlvbi5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvb3BlcmF0aW9uLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvb3BlcmF0aW9ucy9yYWRpYWwtYmx1ci1vcGVyYXRpb24uanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL3JvdGF0aW9uLW9wZXJhdGlvbi5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvc2F0dXJhdGlvbi1vcGVyYXRpb24uanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL3N0aWNrZXJzLW9wZXJhdGlvbi5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL29wZXJhdGlvbnMvdGV4dC1vcGVyYXRpb24uanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy9vcGVyYXRpb25zL3RpbHQtc2hpZnQtb3BlcmF0aW9uLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvcmVuZGVyZXJzL2NhbnZhcy1yZW5kZXJlci5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL3JlbmRlcmVycy9yZW5kZXJlci5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL3JlbmRlcmVycy93ZWJnbC1yZW5kZXJlci5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL3VpL2Jhc2UvaGVscGVycy5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL3VpL2Jhc2UvdWkuanMiLCIvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9pbWdseWtpdC1yZXdyaXRlL3NyYy9qcy91aS9uaWdodC9jb250cm9scy9jb250cm9sLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvdWkvbmlnaHQvY29udHJvbHMvZmlsdGVycy5qcyIsIi9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL2ltZ2x5a2l0LXJld3JpdGUvc3JjL2pzL3VpL25pZ2h0L2NvbnRyb2xzL3JvdGF0aW9uLmpzIiwiL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvaW1nbHlraXQtcmV3cml0ZS9zcmMvanMvdWkvbmlnaHQvdWkuanMiLCJzcmMvanMvdmVuZG9yL3N0YWNrLWJsdXIuanMiLCJzcmMvanMvdmVuZG9yL2xvZGFzaCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0lDVU8sUUFBUSwyQkFBTSxtQkFBbUI7OztBQUd4QyxDQUFDLFlBQVk7QUFDWCxNQUFJLE9BQU8sTUFBTSxLQUFLLFdBQVcsRUFBRTtBQUNqQyxVQUFNLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztHQUM1QixNQUFNLElBQUksT0FBTyxNQUFNLEtBQUssV0FBVyxFQUFFO0FBQ3hDLFVBQU0sQ0FBQyxPQUFPLEdBQUcsUUFBUSxDQUFDO0dBQzNCLE1BQU0sSUFBSSxPQUFPLE1BQU0sS0FBSyxXQUFXLEVBQUU7QUFDeEMsVUFBTSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7R0FDNUI7Q0FDRixDQUFBLEVBQUcsQ0FBQzs7Ozs7QUNyQkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaitCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hRQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2hJTyxJQUFJLFVBQVUsV0FBVixVQUFVLEdBQUc7QUFDdEI7QUFDQTs7Ozs7Ozs7QUFRSyxJQUFJLFdBQVcsV0FBWCxXQUFXLEdBQUc7QUFDdkI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNqQkssQ0FBQywyQkFBTSxRQUFROztJQUNmLFFBQVEsMkJBQU0sVUFBVTs7SUFDeEIsV0FBVywyQkFBTSxvQkFBb0I7O0lBQ3JDLGFBQWEsMkJBQU0sc0JBQXNCOztJQUN2QyxVQUFVLFdBQXFCLGFBQWEsRUFBNUMsVUFBVTtJQUFFLFdBQVcsV0FBUSxhQUFhLEVBQWhDLFdBQVc7SUFDekIsS0FBSywyQkFBTSxhQUFhOzs7SUFHeEIsT0FBTywyQkFBTSxlQUFlOzs7QUFHbkMsUUFBUSxDQUFDLDRCQUE0QixDQUFDLFVBQUMsS0FBSyxFQUFLO0FBQUUsUUFBTSxLQUFLLENBQUM7Q0FBRSxDQUFDLENBQUM7Ozs7Ozs7Ozs7SUFVN0QsUUFBUTtBQUNBLFdBRFIsUUFBUSxDQUNDLE9BQU8sRUFBRTs7QUFHcEIsUUFBSSxPQUFPLE9BQU8sS0FBSyxXQUFXLEVBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDOztBQUV6RSxRQUFJLE9BQU8sT0FBTyxDQUFDLEtBQUssS0FBSyxXQUFXLEVBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFDOzs7QUFHM0YsV0FBTyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFO0FBQzVCLGVBQVMsRUFBRSxRQUFRO0FBQ25CLGVBQVMsRUFBRSxJQUFJO0FBQ2YsUUFBRSxFQUFFLElBQUk7S0FDVCxDQUFDLENBQUM7Ozs7OztBQU1ILFFBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDOzs7Ozs7O0FBT3hCLFFBQUksQ0FBQyxlQUFlLEdBQUcsRUFBRSxDQUFDOzs7Ozs7O0FBTzFCLFFBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxDQUFDOzs7QUFHekIsUUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDOzs7Ozs7QUFNcEIsUUFBSSxDQUFDLHFCQUFxQixHQUFHLEVBQUUsQ0FBQzs7O0FBR2hDLFFBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDOztBQUUzQixRQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFO0FBQ3BCLFVBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztLQUNoQjtHQUNGOzt1QkFsREcsUUFBUTtBQTJEWixVQUFNOzs7Ozs7Ozs7YUFBQyxnQkFBQyxVQUFVLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRTtBQUMzQyxZQUFJLFFBQVEsR0FBRyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLFdBQVcsQ0FBQyxDQUFDOztBQUV2RSxrQkFBVSxHQUFHLFFBQVEsQ0FBQyxVQUFVLENBQUM7QUFDakMsbUJBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDOzs7QUFHbkMsWUFBSSxXQUFXLEdBQUcsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLGVBQWUsRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQzs7O0FBR2pILGVBQU8sV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUN4QixJQUFJLENBQUMsWUFBWTtBQUNoQixjQUFJLE1BQU0sR0FBRyxXQUFXLENBQUMsV0FBVyxFQUFFLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDbkQsaUJBQU8sYUFBYSxVQUFPLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxXQUFXLENBQUMsQ0FBQztTQUM5RCxDQUFDLENBQUM7T0FDTjs7Ozs7QUFLRCxTQUFLOzs7OzthQUFDLGlCQUFHLEVBRVI7Ozs7O0FBT0QsZ0JBQVk7Ozs7Ozs7YUFBQyxzQkFBQyxLQUFLLEVBQUU7QUFDbkIsWUFBSSxTQUFTLEdBQUcsT0FBTyxNQUFNLEtBQUssV0FBVyxDQUFDO0FBQzlDLFlBQUksU0FBUyxFQUFFOztBQUViLGlCQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUM7U0FDOUMsTUFBTTtBQUNMLGNBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUMzQixpQkFBTyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQ3JEO09BQ0Y7Ozs7O0FBTUQsZ0JBQVk7Ozs7OzthQUFDLHVCQUFHO0FBQ2QsWUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztPQUMxQjs7Ozs7QUFNRCx1QkFBbUI7Ozs7OzthQUFDLDhCQUFHO0FBQ3JCLGFBQUssSUFBSSxhQUFhLElBQUksUUFBUSxDQUFDLFVBQVUsRUFBRTtBQUM3QyxjQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1NBQzVEO09BQ0Y7Ozs7O0FBTUQscUJBQWlCOzs7Ozs7YUFBQywyQkFBQyxTQUFTLEVBQUU7QUFDNUIsWUFBSSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLEdBQUcsU0FBUyxDQUFDO09BQ3hFOzs7OztBQU1ELGNBQVU7Ozs7OzthQUFDLG9CQUFDLEVBQUUsRUFBRTtBQUNkLFlBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUM7T0FDbkQ7Ozs7O0FBT0QsV0FBTzs7Ozs7OzthQUFDLGtCQUFHO0FBQ1QsWUFBSSxFQUFFLENBQUM7O0FBRVAsWUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsS0FBSyxJQUFJLEVBQUU7O0FBRTdCLFlBQUUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMzQyxNQUFNOztBQUVMLFlBQUUsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDNUM7OztBQUdELFlBQUksT0FBTyxFQUFFLEtBQUssV0FBVyxFQUFFO0FBQzdCLGdCQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDOUQ7Ozs7O1lBS0ssU0FBUyxHQUFnQixJQUFJLENBQUMsUUFBUSxDQUF0QyxTQUFTO1lBQUUsU0FBUyxHQUFLLElBQUksQ0FBQyxRQUFRLENBQTNCLFNBQVM7QUFDMUIsWUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxTQUFTLEVBQVQsU0FBUyxFQUFFLFNBQVMsRUFBVCxTQUFTLEVBQUUsQ0FBQyxDQUFDO09BQ2xEOzs7OztBQUVHLHdCQUFvQjtXQUFDLFlBQUc7QUFDMUIsZUFBTyxJQUFJLENBQUMscUJBQXFCLENBQUM7T0FDbkM7Ozs7QUFFRCxPQUFHO2FBQUMsZUFBRztBQUNMLFlBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7T0FDZjs7Ozs7OztTQXZLRyxRQUFROzs7Ozs7OztBQStLZCxRQUFRLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQzs7O0FBRzNCLFFBQVEsQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0FBQ25DLFFBQVEsQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3hDLFFBQVEsQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLHdCQUF3QixDQUFDLENBQUM7QUFDdkQsUUFBUSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFDekIsUUFBUSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztBQUNqRixRQUFRLENBQUMsVUFBVSxDQUFDLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO0FBQ25GLFFBQVEsQ0FBQyxVQUFVLENBQUMsYUFBYSxHQUFHLE9BQU8sQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO0FBQzNFLFFBQVEsQ0FBQyxVQUFVLENBQUMsbUJBQW1CLEdBQUcsT0FBTyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7QUFDdkYsUUFBUSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsR0FBRyxPQUFPLENBQUMsaUNBQWlDLENBQUMsQ0FBQztBQUNuRixRQUFRLENBQUMsVUFBVSxDQUFDLG1CQUFtQixHQUFHLE9BQU8sQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO0FBQ3ZGLFFBQVEsQ0FBQyxVQUFVLENBQUMsYUFBYSxHQUFHLE9BQU8sQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO0FBQzNFLFFBQVEsQ0FBQyxVQUFVLENBQUMsa0JBQWtCLEdBQUcsT0FBTyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7QUFDdEYsUUFBUSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsR0FBRyxPQUFPLENBQUMsb0NBQW9DLENBQUMsQ0FBQztBQUN4RixRQUFRLENBQUMsVUFBVSxDQUFDLGFBQWEsR0FBRyxPQUFPLENBQUMsNkJBQTZCLENBQUMsQ0FBQztBQUMzRSxRQUFRLENBQUMsVUFBVSxDQUFDLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO0FBQ25GLFFBQVEsQ0FBQyxVQUFVLENBQUMsZUFBZSxHQUFHLE9BQU8sQ0FBQywrQkFBK0IsQ0FBQyxDQUFDOzs7QUFHL0UsUUFBUSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7QUFDakMsUUFBUSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7QUFDbkMsUUFBUSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQzs7aUJBRWxDLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNuTmpCLEtBQUs7QUFDRyxXQURSLEtBQUssQ0FDSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDdkIsUUFBSSxPQUFPLENBQUMsS0FBSyxXQUFXLEVBQUUsQ0FBQyxHQUFHLENBQUcsQ0FBQzs7QUFFdEMsUUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDWCxRQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNYLFFBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ1gsUUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7R0FDWjs7dUJBUkcsS0FBSztBQWNULFVBQU07Ozs7OzthQUFDLGtCQUFHO0FBQ1IsWUFBSSxNQUFNLEdBQUcsQ0FDWCxJQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFDWixJQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFDWixJQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFDWixJQUFJLENBQUMsQ0FBQyxDQUNQLENBQUM7QUFDRixlQUFPLE9BQU8sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztPQUN6Qzs7Ozs7QUFNRCxTQUFLOzs7Ozs7YUFBQyxpQkFBRztBQUNQLFlBQUksVUFBVSxHQUFHLENBQ2YsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUNsQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQ2xDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FDbkMsQ0FBQztBQUNGLGVBQU8sR0FBRyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7T0FDbEM7Ozs7O0FBTUQsYUFBUzs7Ozs7O2FBQUMscUJBQUc7QUFDWCxlQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO09BQ3pDOzs7OztBQU1ELGdCQUFZOzs7Ozs7YUFBQyx3QkFBRztBQUNkLGVBQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO09BQ2pDOzs7OztBQVFELG1CQUFlOzs7Ozs7OzthQUFDLHdCQUFDLFNBQVMsRUFBRTtBQUMxQixZQUFJLEdBQUcsR0FBRyxTQUFTLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2pDLGVBQU8sR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7T0FDMUM7Ozs7Ozs7U0E5REcsS0FBSzs7O2lCQWlFSSxLQUFLOzs7Ozs7Ozs7Ozs7OztBQy9FcEIsSUFBTSxxQkFBcUIsR0FBRyxFQUFFLENBQUM7O0FBRWpDLFNBQVMsS0FBSyxDQUFFLE9BQU8sRUFBVztvQ0FBTixJQUFJO0FBQUosUUFBSTs7O0FBQzlCLFNBQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3JELFNBQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztDQUNqQjs7SUFFSyxZQUFZO0FBQ0osV0FEUixZQUFZLEdBQ0Q7QUFDYixRQUFJLENBQUMsYUFBYSxHQUFHLHFCQUFxQixDQUFDO0FBQzNDLFFBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO0dBQ25COzt1QkFKRyxZQUFZO0FBTWhCLE1BQUU7YUFBQyxZQUFDLElBQUksRUFBRSxRQUFRLEVBQUU7QUFDbEIsWUFBRyxPQUFPLFFBQVEsSUFBSSxVQUFVLEVBQUU7QUFDaEMsZ0JBQU0sSUFBSSxTQUFTLEVBQUUsQ0FBQztTQUN2Qjs7QUFFRCxZQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFBLEFBQUMsQ0FBQztBQUMvRCxZQUFJLFNBQVMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUU7QUFDckMsaUJBQU8sSUFBSSxDQUFDO1NBQ2I7QUFDRCxpQkFBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzs7QUFFekIsWUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUU7QUFDekMsZUFBSyxDQUNILCtDQUErQyxHQUMvQyxrREFBa0QsR0FDbEQscUNBQXFDLEVBQ3JDLFNBQVMsQ0FBQyxNQUFNLEVBQ2hCLElBQUksRUFDSixJQUFJLENBQUMsYUFBYSxDQUNuQixDQUFDO1NBQ0g7QUFDRCxlQUFPLElBQUksQ0FBQztPQUNiOzs7OztBQUVELFFBQUk7YUFBQyxjQUFDLElBQUksRUFBRSxRQUFRLEVBQUU7MkJBRXBCLFlBQXlCO0FBQ3ZCLHdCQUFjLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQztBQUN2QyxrQkFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7U0FDakM7O0FBSkQsWUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDO0FBSzFCLGVBQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLENBQUM7T0FDcEM7Ozs7O0FBRUQsT0FBRzthQUFDLGFBQUMsSUFBSSxFQUFXOzJDQUFOLElBQUk7QUFBSixjQUFJOzs7QUFDaEIsWUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUNyQixjQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQztTQUMzQjs7QUFFRCxZQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkIsWUFBSSxPQUFPLFFBQVEsSUFBSSxVQUFVLEVBQUU7QUFDakMsZ0JBQU0sSUFBSSxTQUFTLEVBQUUsQ0FBQztTQUN2Qjs7QUFFRCxZQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ25DLFlBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFO0FBQ25DLGlCQUFPLElBQUksQ0FBQztTQUNiOztBQUVELFlBQUksZUFBZSxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDbEQsWUFBSSxlQUFlLElBQUksQ0FBQyxDQUFDLEVBQUU7QUFDekIsaUJBQU8sSUFBSSxDQUFDO1NBQ2I7O0FBRUQsaUJBQVMsQ0FBQyxNQUFNLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3JDLGVBQU8sSUFBSSxDQUFDO09BQ2I7Ozs7O0FBRUQsUUFBSTthQUFDLGNBQUMsSUFBSSxFQUFXOzJDQUFOLElBQUk7QUFBSixjQUFJOzs7QUFDakIsWUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNuQyxZQUFHLENBQUMsU0FBUyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRTtBQUNsQyxpQkFBTyxLQUFLLENBQUM7U0FDZDs7QUFFRCxpQkFBUyxDQUFDLE9BQU8sQ0FBQyxVQUFBLEVBQUU7aUJBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO1NBQUEsQ0FBQyxDQUFDOztBQUU5QyxlQUFPLElBQUksQ0FBQztPQUNiOzs7OztBQUVELG1CQUFlO2FBQUMseUJBQUMsZUFBZSxFQUFFO0FBQ2hDLFlBQUksUUFBUSxDQUFDLGVBQWUsQ0FBQyxLQUFLLGVBQWUsRUFBRTtBQUNqRCxnQkFBTSxJQUFJLFNBQVMsRUFBRSxDQUFDO1NBQ3ZCOztBQUVELFlBQUksQ0FBQyxhQUFhLEdBQUcsZUFBZSxDQUFDO09BQ3RDOzs7Ozs7O1NBaEZHLFlBQVk7OztpQkFtRkgsWUFBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCQzlFRCxtQkFBbUIsRUFBRSxlQUFlLEVBQUU7O0FBRTlEO0FBQ0E7Ozs7O0FBS0EsNkJBQ0UsbUJBQW1CLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxFQUFFO0FBQ2pELFNBQUssR0FBRyxtQkFBbUIsQ0FBQyxXQUFXLENBQUM7R0FDM0MsTUFBTTtBQUNMLFNBQUssR0FBRyxZQUFVO0FBQUUsYUFBTyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztLQUFFLENBQUM7R0FDN0Q7OztBQUdELE1BQUksR0FBRyxDQUFDO0FBQ1IsT0FBSyxHQUFHLElBQUksTUFBTSxFQUFFO0FBQ2xCLFNBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7R0FDMUI7QUFDRCxNQUFJLE9BQU8sZUFBZSxLQUFLLFdBQVcsRUFBRTtBQUMxQyxTQUFLLEdBQUcsSUFBSSxlQUFlLEVBQUU7QUFDM0IsV0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNuQztHQUNGOzs7O0FBSUQsTUFBSSxTQUFTLEdBQUcsWUFBVTtBQUFFLFFBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO0dBQUUsQ0FBQztBQUN4RCxXQUFTLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7QUFDdkMsT0FBSyxDQUFDLFNBQVMsR0FBRyxJQUFJLFNBQVMsRUFBRSxDQUFDOzs7O0FBSWxDLE1BQUksbUJBQW1CLEVBQUU7QUFDdkIsU0FBSyxHQUFHLElBQUksbUJBQW1CLEVBQUU7QUFDL0IsV0FBSyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNqRDtHQUNGOzs7O0FBSUQsT0FBSyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDOztBQUVuQyxTQUFPLEtBQUssQ0FBQztDQUNkLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUM5Q0ksZUFBZTtBQUNQLFdBRFIsZUFBZSxDQUNOLFVBQVUsRUFBRTs7Ozs7O0FBTXZCLFFBQUksQ0FBQyxVQUFVLEdBQUc7QUFDaEIsV0FBSyxFQUFFLEdBQUc7S0FDWCxDQUFDOzs7Ozs7QUFNRixRQUFJLENBQUMsaUJBQWlCLEdBQUcsVUFBVSxDQUFDOzs7Ozs7QUFNcEMsUUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7O0FBRTVCLFFBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztHQUN2Qjs7dUJBeEJHLGVBQWU7QUE4Qm5CLFVBQU07Ozs7OzthQUFDLGlCQUFHO0FBQ1IsWUFBSSxPQUFPLElBQUksQ0FBQyxpQkFBaUIsS0FBSyxXQUFXLEVBQUU7QUFDakQsaUJBQU8sSUFBSSxDQUFDO1NBQ2I7O0FBRUQsWUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO0FBQzFFLFlBQUksQ0FBQyxLQUFLLEVBQUU7QUFDVixnQkFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztTQUNuRTs7QUFFRCxlQUFPO0FBQ0wsV0FBQyxFQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM5QyxXQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzlDLGtCQUFRLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUNuQixDQUFDO09BQ0g7Ozs7O0FBTUQsa0JBQWM7Ozs7OzthQUFDLHlCQUFHO0FBQ2hCLFlBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxJQUFJLEVBQUUsT0FBTzs7QUFFakMsWUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDO0FBQ3hDLFlBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQzs7QUFFeEMsWUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsS0FBSyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFLFVBQVUsSUFBSSxVQUFVLENBQUEsQUFBQyxFQUFFO0FBQ2pGLGdCQUFNLElBQUksS0FBSyxDQUFDLG9FQUFvRSxDQUFDLENBQUM7U0FDdkY7O0FBRUQsWUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLFVBQVUsRUFBRTtBQUM5QixnQkFBTSxJQUFJLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO1NBQ25EO09BQ0Y7Ozs7O0FBUUQsNEJBQXdCOzs7Ozs7OzthQUFDLGtDQUFDLGlCQUFpQixFQUFFO0FBQzNDLFlBQUksVUFBVSxHQUFHLGlCQUFpQixDQUFDLEtBQUssRUFBRSxFQUFFLEtBQUssQ0FBQzs7QUFFbEQsWUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLElBQUksRUFBRSxPQUFPLFVBQVUsQ0FBQzs7O0FBRzVDLFlBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEtBQUssSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUU7O0FBRWxELG9CQUFVLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDOUMsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLElBQUksSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUU7O0FBRTNELGVBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdFLG9CQUFVLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzVCLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUU7O0FBRWpDLGVBQUssR0FBRyxpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO0FBQ2xELG9CQUFVLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQzdCLG9CQUFVLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO1NBQ3JDLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUU7O0FBRWpDLGVBQUssR0FBRyxpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO0FBQ2xELG9CQUFVLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQzdCLG9CQUFVLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO1NBQ3JDOztBQUVELGVBQU8sVUFBVSxDQUFDO09BQ25COzs7Ozs7O1NBbEdHLGVBQWU7OztpQkFxR04sZUFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDN0dyQixVQUFVLFdBQXFCLGNBQWMsRUFBN0MsVUFBVTtJQUFFLFdBQVcsV0FBUSxjQUFjLEVBQWpDLFdBQVc7SUFDekIsS0FBSywyQkFBTSxTQUFTOzs7Ozs7O0lBT3JCLGFBQWE7V0FBYixhQUFhOzt1QkFBYixhQUFhO0FBRVYsb0JBQWdCO2FBQUMsMEJBQUMsVUFBVSxFQUFFLFdBQVcsRUFBRTtBQUNoRCxZQUFJLFFBQVEsR0FBRztBQUNiLG9CQUFVLEVBQUUsVUFBVTtBQUN0QixxQkFBVyxFQUFFLFdBQVc7U0FDekIsQ0FBQzs7O0FBR0YsWUFBSSxBQUFDLE9BQU8sUUFBUSxDQUFDLFVBQVUsS0FBSyxXQUFXLElBQUksUUFBUSxDQUFDLFVBQVUsS0FBSyxJQUFJLElBQzdFLEtBQUssQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtBQUM1RCxnQkFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsR0FBRyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDbEUsTUFBTSxJQUFJLE9BQU8sVUFBVSxLQUFLLFdBQVcsRUFBRTtBQUM1QyxrQkFBUSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUMsUUFBUSxDQUFDO1NBQzNDOzs7QUFHRCxZQUFJLEFBQUMsT0FBTyxRQUFRLENBQUMsV0FBVyxLQUFLLFdBQVcsSUFBSSxRQUFRLENBQUMsV0FBVyxLQUFLLElBQUksSUFDL0UsS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO0FBQzlELGdCQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUNwRSxNQUFNLElBQUksT0FBTyxXQUFXLEtBQUssV0FBVyxFQUFFO0FBQzdDLGtCQUFRLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUM7U0FDeEM7O0FBRUQsZUFBTyxRQUFRLENBQUM7T0FDakI7Ozs7Ozs7Ozs7Ozs7O2FBU2EsaUJBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUU7QUFDOUMsWUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUMzQyxZQUFJLFVBQVUsSUFBSSxVQUFVLENBQUMsS0FBSyxFQUFFO0FBQ2xDLGNBQUksS0FBSyxDQUFDOzs7QUFHVixjQUFJLE9BQU8sTUFBTSxLQUFLLFdBQVcsRUFBRTs7QUFFakMsZ0JBQUksV0FBVyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDMUMsaUJBQUssR0FBRyxJQUFJLFdBQVcsRUFBRSxDQUFDO1dBQzNCLE1BQU07QUFDTCxpQkFBSyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7V0FDckI7O0FBRUQsZUFBSyxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUM7QUFDbkIsZ0JBQU0sR0FBRyxLQUFLLENBQUM7U0FDaEI7QUFDRCxlQUFPLE1BQU0sQ0FBQztPQUNmOzs7Ozs7O1NBcERHLGFBQWE7OztpQkF3REosYUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDdER0QixPQUFPO0FBQ0MsV0FEUixPQUFPLENBQ0UsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUNqQixRQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNYLFFBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ1gsUUFBSSxPQUFPLElBQUksQ0FBQyxDQUFDLEtBQUssV0FBVyxFQUFFO0FBQ2pDLFVBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ1o7QUFDRCxRQUFJLE9BQU8sSUFBSSxDQUFDLENBQUMsS0FBSyxXQUFXLEVBQUU7QUFDakMsVUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDWjtHQUNGOzt1QkFWRyxPQUFPO0FBa0JYLE9BQUc7Ozs7Ozs7O2FBQUMsYUFBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQ1QsWUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDWCxZQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNYLGVBQU8sSUFBSSxDQUFDO09BQ2I7Ozs7O0FBTUQsU0FBSzs7Ozs7O2FBQUMsaUJBQUc7QUFDUCxlQUFPLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO09BQ3BDOzs7OztBQU9ELFFBQUk7Ozs7Ozs7YUFBQyxjQUFDLEtBQUssRUFBRTtBQUNYLFlBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUNqQixZQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDakIsZUFBTyxJQUFJLENBQUM7T0FDYjs7Ozs7QUFRRCxTQUFLOzs7Ozs7OzthQUFDLGVBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRTs7QUFFdkIsWUFBSSxFQUFFLE9BQU8sWUFBWSxPQUFPLENBQUEsQUFBQyxFQUFFO0FBQ2pDLGlCQUFPLEdBQUcsSUFBSSxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ3pDOztBQUVELFlBQUksRUFBRSxPQUFPLFlBQVksT0FBTyxDQUFBLEFBQUMsRUFBRTtBQUNqQyxpQkFBTyxHQUFHLElBQUksT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztTQUN6QztBQUNELFlBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMxRCxZQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUQsZUFBTyxJQUFJLENBQUM7T0FDYjs7Ozs7QUFRRCxVQUFNOzs7Ozs7OzthQUFDLGdCQUFDLE9BQU8sRUFBRSxDQUFDLEVBQUU7QUFDbEIsWUFBSSxPQUFPLFlBQVksT0FBTyxFQUFFO0FBQzlCLGNBQUksQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQztBQUNwQixjQUFJLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUM7U0FDckIsTUFBTTtBQUNMLGNBQUksQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDO0FBQ2xCLGNBQUksQ0FBQyxDQUFDLElBQUssT0FBTyxDQUFDLEtBQUssV0FBVyxHQUFHLE9BQU8sR0FBRyxDQUFDLEFBQUMsQ0FBQztTQUNwRDtBQUNELGVBQU8sSUFBSSxDQUFDO09BQ2I7Ozs7O0FBUUQsWUFBUTs7Ozs7Ozs7YUFBQyxrQkFBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFO0FBQ3ZCLFlBQUksVUFBVSxZQUFZLE9BQU8sRUFBRTtBQUNqQyxjQUFJLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUM7QUFDdkIsY0FBSSxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDO1NBQ3hCLE1BQU07QUFDTCxjQUFJLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQztBQUNyQixjQUFJLENBQUMsQ0FBQyxJQUFLLE9BQU8sQ0FBQyxLQUFLLFdBQVcsR0FBRyxVQUFVLEdBQUcsQ0FBQyxBQUFDLENBQUM7U0FDdkQ7QUFDRCxlQUFPLElBQUksQ0FBQztPQUNiOzs7OztBQVFELFlBQVE7Ozs7Ozs7O2FBQUMsa0JBQUMsTUFBTSxFQUFFLENBQUMsRUFBRTtBQUNuQixZQUFJLE1BQU0sWUFBWSxPQUFPLEVBQUU7QUFDN0IsY0FBSSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ25CLGNBQUksQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQztTQUNwQixNQUFNO0FBQ0wsY0FBSSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUM7QUFDakIsY0FBSSxDQUFDLENBQUMsSUFBSyxPQUFPLENBQUMsS0FBSyxXQUFXLEdBQUcsTUFBTSxHQUFHLENBQUMsQUFBQyxDQUFDO1NBQ25EO0FBQ0QsZUFBTyxJQUFJLENBQUM7T0FDYjs7Ozs7QUFPRCxPQUFHOzs7Ozs7O2FBQUMsYUFBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFO0FBQ2QsWUFBSSxNQUFNLFlBQVksT0FBTyxFQUFFO0FBQzdCLGNBQUksQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNuQixjQUFJLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUM7U0FDcEIsTUFBTTtBQUNMLGNBQUksQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDO0FBQ2pCLGNBQUksQ0FBQyxDQUFDLElBQUssT0FBTyxDQUFDLEtBQUssV0FBVyxHQUFHLE1BQU0sR0FBRyxDQUFDLEFBQUMsQ0FBQztTQUNuRDtBQUNELGVBQU8sSUFBSSxDQUFDO09BQ2I7Ozs7O0FBUUQsVUFBTTs7Ozs7Ozs7YUFBQyxnQkFBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFO0FBQ2QsWUFBSSxHQUFHLFlBQVksT0FBTyxFQUFFO0FBQzFCLGlCQUFPLEdBQUcsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDN0MsTUFBTTtBQUNMLGlCQUFPLEdBQUcsS0FBSyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ3ZDO09BQ0Y7Ozs7O0FBTUQsWUFBUTs7Ozs7O2FBQUMsb0JBQUc7QUFDVixlQUFPLGVBQWUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztPQUM1RDs7Ozs7OztTQXRKRyxPQUFPOzs7aUJBMEpFLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ3BLZixRQUFRLDJCQUFNLFVBQVU7O0lBQ3hCLGVBQWUsMkJBQU0sb0JBQW9COztJQUN6QyxPQUFPLDJCQUFNLGdCQUFnQjs7SUFDN0IsY0FBYywyQkFBTSw4QkFBOEI7O0lBQ2xELGFBQWEsMkJBQU0sNkJBQTZCOzs7Ozs7Ozs7Ozs7SUFZakQsV0FBVztBQUNILFdBRFIsV0FBVyxDQUNGLEtBQUssRUFBRSxlQUFlLEVBQUUsVUFBVSxFQUFFLGlCQUFpQixFQUFFOzs7OztBQUtsRSxRQUFJLENBQUMsUUFBUSxHQUFHO0FBQ2QsdUJBQWlCLEVBQUUsaUJBQWlCO0tBQ3JDLENBQUM7Ozs7Ozs7QUFPRixRQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQzs7Ozs7O0FBTTNCLFFBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDOzs7Ozs7QUFNdEIsUUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7Ozs7OztBQU1wQixRQUFJLENBQUMsTUFBTSxHQUFHLGVBQWUsQ0FBQzs7Ozs7O0FBTTlCLFFBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7Ozs7OztBQU1uRCxRQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQzs7QUFFN0UsUUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO0dBQ3RCOzt1QkFoREcsV0FBVztBQXVEZixpQkFBYTs7Ozs7OzthQUFDLHdCQUFHOztBQUVmLFlBQUksYUFBYSxDQUFDLFdBQVcsRUFBRSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLEtBQUssUUFBUSxFQUFFO0FBQy9FLGNBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxhQUFhLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDNUQsY0FBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7U0FDM0IsTUFBTSxJQUFJLGNBQWMsQ0FBQyxXQUFXLEVBQUUsRUFBRTtBQUN2QyxjQUFJLENBQUMsU0FBUyxHQUFHLElBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQzdELGNBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDO1NBQzVCOzs7QUFHRCxZQUFJLElBQUksQ0FBQyxTQUFTLEtBQUssSUFBSSxFQUFFO0FBQzNCLGdCQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQUM7U0FDckU7O0FBRUQsWUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO09BQ3ZDOzs7OztBQU1ELFVBQU07Ozs7OzthQUFDLGtCQUFHO0FBQ1IsWUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2hCLGVBQU8sUUFBUSxDQUNaLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFVBQVUsU0FBUyxFQUFFO0FBQ3JDLGlCQUFPLFNBQVMsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1NBQ3JDLENBQUMsQ0FDRCxJQUFJLENBQUMsWUFBWTtBQUNoQixpQkFBTyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsVUFBVSxTQUFTLEVBQUU7QUFDcEQsbUJBQU8sU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7V0FDekMsRUFBRSxFQUFFLFdBQVcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZO0FBQ3RDLG1CQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUM7V0FDckMsQ0FBQyxDQUFDO1NBQ0osQ0FBQyxDQUNELElBQUksQ0FBQyxZQUFZO0FBQ2hCLGNBQUksV0FBVyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDM0MsY0FBSSxlQUFlLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyx3QkFBd0IsQ0FBQyxXQUFXLENBQUMsQ0FBQzs7QUFFN0UsY0FBSSxlQUFlLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFFOztBQUV2QyxtQkFBTztXQUNSOztBQUVELGlCQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1NBQ2pELENBQUMsQ0FBQztPQUNOOzs7OztBQU1ELGVBQVc7Ozs7OzthQUFDLHVCQUFHO0FBQ2IsZUFBTyxJQUFJLENBQUMsU0FBUyxDQUFDO09BQ3ZCOzs7Ozs7O1NBN0dHLFdBQVc7OztpQkFnSEYsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDekhwQixLQUFLO1dBQUwsS0FBSzs7dUJBQUwsS0FBSztBQU9GLFdBQU87Ozs7Ozs7YUFBQyxpQkFBQyxNQUFNLEVBQUU7QUFDdEIsZUFBTyxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssZ0JBQWdCLENBQUM7T0FDcEU7Ozs7O0FBUU0sVUFBTTs7Ozs7Ozs7YUFBQyxnQkFBQyxLQUFLLEVBQUUsUUFBUSxFQUFFO0FBQzlCLFlBQUksUUFBUSxLQUFLLElBQUksRUFBRTtBQUNyQixpQkFBTyxLQUFLLENBQUM7U0FDZDs7O0FBR0QsWUFBSSxPQUFPLFFBQVEsS0FBSyxRQUFRLEVBQUU7QUFDaEMsa0JBQVEsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLFVBQVUsRUFBRTtBQUN2RCxtQkFBTyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUM7V0FDMUIsQ0FBQyxDQUFDO1NBQ0o7OztBQUdELFlBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRTtBQUMzQixrQkFBUSxHQUFHLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxDQUFDO1NBQy9COztBQUVELFlBQUksT0FBTyxRQUFRLENBQUMsSUFBSSxLQUFLLFdBQVcsRUFBRTs7QUFFeEMsaUJBQU8sS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFVLElBQUksRUFBRTtBQUNsQyxtQkFBTyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztXQUMzQyxDQUFDLENBQUM7U0FDSixNQUFNLElBQUcsT0FBTyxRQUFRLENBQUMsTUFBTSxLQUFLLFdBQVcsRUFBRTs7QUFFaEQsaUJBQU8sS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFVLElBQUksRUFBRTtBQUNsQyxtQkFBTyxRQUFRLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztXQUM3QyxDQUFDLENBQUM7U0FDSjs7QUFFRCxjQUFNLElBQUksS0FBSyxDQUFDLHNDQUFzQyxDQUFDLENBQUM7T0FDekQ7Ozs7O0FBT00sVUFBTTs7Ozs7OzthQUFDLGdCQUFDLE1BQU0sRUFBRTtBQUNyQixZQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDaEIsYUFBSyxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUU7QUFDdEIsZ0JBQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDMUI7QUFDRCxlQUFPLE1BQU0sQ0FBQztPQUNmOzs7OztBQVFNLGdCQUFZOzs7Ozs7OzthQUFDLHNCQUFDLENBQUMsRUFBRTtBQUN0QixlQUNFLE9BQU8sV0FBVyxLQUFLLFFBQVEsR0FBRyxDQUFDLFlBQVksV0FBVyxHQUMxRCxDQUFDLElBQUksT0FBTyxDQUFDLEtBQUssUUFBUSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLFFBQVEsS0FBSyxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsUUFBUSxLQUFHLFFBQVEsQ0FDNUY7T0FDSDs7Ozs7OztTQXpFRyxLQUFLOzs7aUJBNkVJLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDbkZiLFNBQVMsMkJBQU0sYUFBYTs7SUFDNUIsZUFBZSwyQkFBTSw0QkFBNEI7O0lBQ2pELG1CQUFtQiwyQkFBTSxpQ0FBaUM7Ozs7Ozs7SUFPM0QsbUJBQW1CLGNBQVMsU0FBUztBQUM3QixXQURSLG1CQUFtQixHQUNEO3NDQUFOLElBQUk7QUFBSixVQUFJOzs7QUFDbEIsUUFBSSxDQUFDLGdCQUFnQixHQUFHO0FBQ3RCLGdCQUFVLEVBQUUsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLFdBQVMsQ0FBQyxFQUFFO0tBQzNDLENBQUM7O0FBRUYsK0JBTkUsbUJBQW1CLDhDQU1aLElBQUksRUFBRTtHQUNoQjs7WUFQRyxtQkFBbUIsRUFBUyxTQUFTOzt1QkFBckMsbUJBQW1CO0FBY25CLGNBQVU7Ozs7Ozs7V0FBQyxZQUFHO0FBQ2hCLGVBQU8sWUFBWSxDQUFDO09BQ3JCOzs7O0FBT0QsVUFBTTs7Ozs7OzthQUFDLGdCQUFDLFFBQVEsRUFBRTtBQUNoQixZQUFJLEtBQUssR0FBRyxJQUFJLGVBQWUsRUFBRSxDQUFDOztBQUVsQyxhQUFLLENBQUMsR0FBRyxDQUFDLElBQUksbUJBQW1CLENBQUM7QUFDaEMsb0JBQVUsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVU7U0FDckMsQ0FBQyxDQUFDLENBQUM7O0FBRUosYUFBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztPQUN4Qjs7Ozs7OztTQS9CRyxtQkFBbUI7R0FBUyxTQUFTOztpQkFrQzVCLG1CQUFtQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUMzQzNCLFNBQVMsMkJBQU0sYUFBYTs7SUFDNUIsZUFBZSwyQkFBTSw0QkFBNEI7O0lBQ2pELGlCQUFpQiwyQkFBTSwrQkFBK0I7Ozs7Ozs7SUFPdkQsaUJBQWlCLGNBQVMsU0FBUztBQUMzQixXQURSLGlCQUFpQixHQUNDO3NDQUFOLElBQUk7QUFBSixVQUFJOzs7QUFDbEIsUUFBSSxDQUFDLGdCQUFnQixHQUFHO0FBQ3RCLGNBQVEsRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsV0FBUyxDQUFHLEVBQUU7S0FDM0MsQ0FBQzs7QUFFRiwrQkFORSxpQkFBaUIsOENBTVYsSUFBSSxFQUFFO0dBQ2hCOztZQVBHLGlCQUFpQixFQUFTLFNBQVM7O3VCQUFuQyxpQkFBaUI7QUFjakIsY0FBVTs7Ozs7OztXQUFDLFlBQUc7QUFDaEIsZUFBTyxVQUFVLENBQUM7T0FDbkI7Ozs7QUFPRCxVQUFNOzs7Ozs7O2FBQUMsZ0JBQUMsUUFBUSxFQUFFO0FBQ2hCLFlBQUksS0FBSyxHQUFHLElBQUksZUFBZSxFQUFFLENBQUM7O0FBRWxDLGFBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxpQkFBaUIsQ0FBQztBQUM5QixrQkFBUSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUTtTQUNqQyxDQUFDLENBQUMsQ0FBQzs7QUFFSixhQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ3hCOzs7Ozs7O1NBL0JHLGlCQUFpQjtHQUFTLFNBQVM7O2lCQWtDMUIsaUJBQWlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQzNDekIsU0FBUywyQkFBTSxhQUFhOztJQUM1QixPQUFPLDJCQUFNLHFCQUFxQjs7Ozs7Ozs7O0lBU25DLGFBQWEsY0FBUyxTQUFTO0FBQ3ZCLFdBRFIsYUFBYSxHQUNLO3NDQUFOLElBQUk7QUFBSixVQUFJOzs7QUFDbEIsUUFBSSxDQUFDLGdCQUFnQixHQUFHO0FBQ3RCLFdBQUssRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRTtBQUMxQyxTQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUU7S0FDekMsQ0FBQzs7Ozs7QUFLRixRQUFJLENBQUMsY0FBYyx3VUFXbEIsQ0FBQzs7QUFFRiwrQkF2QkUsYUFBYSw4Q0F1Qk4sSUFBSSxFQUFFO0dBQ2hCOztZQXhCRyxhQUFhLEVBQVMsU0FBUzs7dUJBQS9CLGFBQWE7QUErQmIsY0FBVTs7Ozs7OztXQUFDLFlBQUc7QUFDaEIsZUFBTyxNQUFNLENBQUM7T0FDZjs7OztBQU9ELGdCQUFZOzs7Ozs7O2FBQUMscUJBQUMsUUFBUSxFQUFFO0FBQ3RCLFlBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUNsQyxZQUFJLEVBQUUsR0FBRyxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUM7QUFDL0IsWUFBSSxVQUFVLEdBQUcsSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7O0FBRTFELFlBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQ3hDLFlBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDOztBQUVwQyxZQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxLQUFLLFVBQVUsRUFBRTtBQUM3QyxlQUFLLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ3pCLGFBQUcsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDeEI7OztBQUdELFlBQUksY0FBYyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDN0IsYUFBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNwQixXQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxjQUFjLENBQUM7OztBQUczQixZQUFJLGFBQWEsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLENBQUM7OztBQUdyRCxZQUFJLFdBQVcsR0FBRyxRQUFRLENBQUMsY0FBYyxFQUFFLENBQUM7OztBQUc1QyxZQUFJLFFBQVEsR0FBRyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDdEMsWUFBSSxPQUFPLENBQUM7QUFDWixhQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN4QyxpQkFBTyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0QixjQUFJLE9BQU8sS0FBSyxXQUFXLEVBQUUsU0FBUzs7QUFFdEMsWUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3ZDLFlBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksRUFBRSxhQUFhLENBQUMsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNoSDs7O0FBR0QsY0FBTSxDQUFDLEtBQUssR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDO0FBQy9CLGNBQU0sQ0FBQyxNQUFNLEdBQUcsYUFBYSxDQUFDLENBQUMsQ0FBQzs7O0FBR2hDLGdCQUFRLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsY0FBYyxFQUFFO0FBQzVDLGtCQUFRLEVBQUU7QUFDUix1QkFBVyxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRTtBQUN0RCxxQkFBUyxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTtXQUNqRDtTQUNGLENBQUMsQ0FBQzs7O0FBR0gsVUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQzNDLFVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksRUFBRSxhQUFhLENBQUMsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsQ0FBQztPQUNoSDs7Ozs7QUFNRCxpQkFBYTs7Ozs7O2FBQUMsc0JBQUMsUUFBUSxFQUFFO0FBQ3ZCLFlBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUNsQyxZQUFJLFVBQVUsR0FBRyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQzs7QUFFMUQsWUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxDQUFDOzs7QUFHckQsWUFBSSxTQUFTLEdBQUcsUUFBUSxDQUFDLFlBQVksRUFBRSxDQUFDO0FBQ3hDLGlCQUFTLENBQUMsS0FBSyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUM7QUFDbEMsaUJBQVMsQ0FBQyxNQUFNLEdBQUcsYUFBYSxDQUFDLENBQUMsQ0FBQztBQUNuQyxZQUFJLFVBQVUsR0FBRyxTQUFTLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDOzs7QUFHNUMsWUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7O0FBRWhELFlBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEtBQUssVUFBVSxFQUFFO0FBQzdDLHVCQUFhLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ3BDOzs7QUFHRCxrQkFBVSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQ3pCLGFBQWEsQ0FBQyxDQUFDLEVBQUUsYUFBYSxDQUFDLENBQUM7QUFDaEMscUJBQWEsQ0FBQyxDQUFDLEVBQUUsYUFBYSxDQUFDLENBQUM7QUFDaEMsU0FBQyxFQUFFLENBQUM7QUFDSixxQkFBYSxDQUFDLENBQUMsRUFBRSxhQUFhLENBQUMsQ0FBQztBQUFBLFNBQy9CLENBQUM7OztBQUdKLGdCQUFRLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO09BQy9COzs7OztBQU9ELHFCQUFpQjs7Ozs7OzthQUFDLDBCQUFDLFFBQVEsRUFBRTtBQUMzQixZQUFJLE1BQU0sR0FBRyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDbEMsWUFBSSxVQUFVLEdBQUcsSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7O0FBRTFELFlBQUksYUFBYSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUNsQyxLQUFLLEVBQUUsQ0FDUCxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7QUFFakMsWUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksS0FBSyxVQUFVLEVBQUU7QUFDN0MsdUJBQWEsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDcEM7O0FBRUQsZUFBTyxhQUFhLENBQUM7T0FDdEI7Ozs7Ozs7U0FqSkcsYUFBYTtHQUFTLFNBQVM7O2lCQW9KdEIsYUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUM5SnJCLFNBQVMsMkJBQU0sYUFBYTs7Ozs7Ozs7O0lBUzdCLGdCQUFnQixjQUFTLFNBQVM7QUFDMUIsV0FEUixnQkFBZ0IsR0FDRTtzQ0FBTixJQUFJO0FBQUosVUFBSTs7O0FBQ2xCLFFBQUksQ0FBQyxnQkFBZ0IsR0FBRztBQUN0QixZQUFNLEVBQUUsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLFdBQVMsVUFBVTtBQUMzQyxjQUFNLEVBQUUsVUFBVSxLQUFLLEVBQUU7QUFDdkIsY0FBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNsQyxjQUFJLE9BQU8sTUFBTSxLQUFLLFdBQVcsRUFBRTtBQUNqQyxrQkFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUM7V0FDeEU7QUFDRCxjQUFJLENBQUMsZUFBZSxHQUFHLElBQUksTUFBTSxFQUFFLENBQUM7QUFDcEMsaUJBQU8sS0FBSyxDQUFDO1NBQ2Q7T0FDRjtLQUNGLENBQUM7Ozs7OztBQU1GLFFBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO0FBQ25CLFFBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDOztBQUV4QiwrQkF0QkUsZ0JBQWdCLDhDQXNCVCxJQUFJLEVBQUU7R0FDaEI7O1lBdkJHLGdCQUFnQixFQUFTLFNBQVM7O3VCQUFsQyxnQkFBZ0I7QUE4QmhCLGNBQVU7Ozs7Ozs7V0FBQyxZQUFHO0FBQ2hCLGVBQU8sU0FBUyxDQUFDO09BQ2xCOzs7O0FBT0QsVUFBTTs7Ozs7OzthQUFDLGdCQUFDLFFBQVEsRUFBRTtBQUNoQixZQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztPQUN2Qzs7Ozs7QUFNRCxvQkFBZ0I7Ozs7OzthQUFDLDJCQUFHO0FBQ2xCLFlBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLDJCQUEyQixDQUFDLENBQUMsQ0FBQztBQUMzRCxZQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUM7QUFDckQsWUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDO0FBQ3JELFlBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQztBQUNyRCxZQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQyxDQUFDLENBQUM7QUFDM0QsWUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMseUJBQXlCLENBQUMsQ0FBQyxDQUFDO0FBQ3pELFlBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLHlCQUF5QixDQUFDLENBQUMsQ0FBQztBQUN6RCxZQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLENBQUM7QUFDekQsWUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsd0JBQXdCLENBQUMsQ0FBQyxDQUFDO0FBQ3hELFlBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLHdCQUF3QixDQUFDLENBQUMsQ0FBQztBQUN4RCxZQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLENBQUM7QUFDeEQsWUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxDQUFDO0FBQ3ZELFlBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQztBQUNyRCxZQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLENBQUM7QUFDekQsWUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsd0JBQXdCLENBQUMsQ0FBQyxDQUFDO0FBQ3hELFlBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLHdCQUF3QixDQUFDLENBQUMsQ0FBQztBQUN4RCxZQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQywwQkFBMEIsQ0FBQyxDQUFDLENBQUM7QUFDMUQsWUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxDQUFDO0FBQ3ZELFlBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQztBQUN2RCxZQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLENBQUM7QUFDdkQsWUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsMEJBQTBCLENBQUMsQ0FBQyxDQUFDO0FBQzFELFlBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLHdCQUF3QixDQUFDLENBQUMsQ0FBQztBQUN4RCxZQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQywwQkFBMEIsQ0FBQyxDQUFDLENBQUM7QUFDMUQsWUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxDQUFDO0FBQ3ZELFlBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLDBCQUEwQixDQUFDLENBQUMsQ0FBQztBQUMxRCxZQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLENBQUM7QUFDekQsWUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsd0JBQXdCLENBQUMsQ0FBQyxDQUFDO0FBQ3hELFlBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQztBQUN0RCxZQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQywwQkFBMEIsQ0FBQyxDQUFDLENBQUM7T0FDM0Q7Ozs7O0FBT0QsbUJBQWU7Ozs7Ozs7YUFBQyx3QkFBQyxNQUFNLEVBQUU7QUFDdkIsWUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsTUFBTSxDQUFDO09BQzNDOzs7OztBQU1HLFdBQU87Ozs7OztXQUFDLFlBQUc7QUFDYixlQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7T0FDdEI7Ozs7OztTQTlGRyxnQkFBZ0I7R0FBUyxTQUFTOztpQkFpR3pCLGdCQUFnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQzFHeEIsTUFBTSwyQkFBTSxVQUFVOzs7Ozs7OztJQVF2QixTQUFTLGNBQVMsTUFBTTtXQUF4QixTQUFTOzhCQUFULFNBQVM7NEJBQVQsU0FBUzs7OztZQUFULFNBQVMsRUFBUyxNQUFNOzt1QkFBeEIsU0FBUztBQU1GLGNBQVU7Ozs7OztXQUFDLFlBQUc7QUFDdkIsZUFBTyxLQUFLLENBQUM7T0FDZDs7Ozs7QUFRRCxVQUFNOzs7Ozs7OzthQUFDLGdCQUFDLFFBQVEsRUFBRTtBQUNoQixZQUFJLEtBQUssR0FBRyxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQzs7QUFFekMsYUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDO0FBQ3ZDLGtCQUFRLEVBQUUsSUFBSTtTQUNmLENBQUMsQ0FBQyxDQUFDOztBQUVKLGFBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztBQUN6QyxvQkFBVSxFQUFFLElBQUk7U0FDakIsQ0FBQyxDQUFDLENBQUM7O0FBRUosYUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDO0FBQ3hDLDBCQUFnQixFQUFFO0FBQ2hCLGVBQUcsRUFBRSxDQUNILENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUNQLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO0FBQ0QsaUJBQUssRUFBRSxDQUNMLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNOLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO0FBQ0QsZ0JBQUksRUFBRSxDQUNKLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUNQLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO1dBQ0Y7U0FDRixDQUFDLENBQUMsQ0FBQzs7QUFFSixhQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ3hCOzs7Ozs7O1NBcERHLFNBQVM7R0FBUyxNQUFNOztpQkF1RGYsU0FBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQy9EakIsTUFBTSwyQkFBTSxVQUFVOzs7Ozs7OztJQVF2QixZQUFZLGNBQVMsTUFBTTtXQUEzQixZQUFZOzhCQUFaLFlBQVk7NEJBQVosWUFBWTs7OztZQUFaLFlBQVksRUFBUyxNQUFNOzt1QkFBM0IsWUFBWTtBQU9MLGNBQVU7Ozs7Ozs7V0FBQyxZQUFHO0FBQ3ZCLGVBQU8sUUFBUSxDQUFDO09BQ2pCOzs7OztBQU9ELFVBQU07Ozs7Ozs7YUFBQyxnQkFBQyxRQUFRLEVBQUU7QUFDaEIsWUFBSSxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsZUFBZSxFQUFFLENBQUM7OztBQUd6QyxhQUFLLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUM7QUFDM0Msc0JBQVksRUFBRSxHQUFHO1NBQ2xCLENBQUMsQ0FBQyxDQUFDOzs7QUFHSixhQUFLLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUM7QUFDeEMsMEJBQWdCLEVBQUU7QUFDaEIsZUFBRyxFQUFFLENBQ0gsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ04sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQ1g7QUFDRCxpQkFBSyxFQUFFLENBQ0wsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ04sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQ1g7QUFDRCxnQkFBSSxFQUFFLENBQ0osQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ04sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQ1g7V0FDRjtTQUNGLENBQUMsQ0FBQyxDQUFDOztBQUVKLGFBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7T0FDeEI7Ozs7Ozs7U0FsREcsWUFBWTtHQUFTLE1BQU07O2lCQXFEbEIsWUFBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQzdEcEIsTUFBTSwyQkFBTSxVQUFVOzs7Ozs7OztJQVF2QixRQUFRLGNBQVMsTUFBTTtXQUF2QixRQUFROzhCQUFSLFFBQVE7NEJBQVIsUUFBUTs7OztZQUFSLFFBQVEsRUFBUyxNQUFNOzt1QkFBdkIsUUFBUTtBQU1ELGNBQVU7Ozs7OztXQUFDLFlBQUc7QUFDdkIsZUFBTyxJQUFJLENBQUM7T0FDYjs7Ozs7QUFPRCxVQUFNOzs7Ozs7O2FBQUMsZ0JBQUMsUUFBUSxFQUFFO0FBQ2hCLFlBQUksS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDOztBQUV6QyxhQUFLLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDOztBQUU3QyxhQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ3hCOzs7Ozs7O1NBckJHLFFBQVE7R0FBUyxNQUFNOztpQkF3QmQsUUFBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ2hDaEIsTUFBTSwyQkFBTSxVQUFVOzs7Ozs7OztJQVF2QixZQUFZLGNBQVMsTUFBTTtXQUEzQixZQUFZOzhCQUFaLFlBQVk7NEJBQVosWUFBWTs7OztZQUFaLFlBQVksRUFBUyxNQUFNOzt1QkFBM0IsWUFBWTtBQU1MLGNBQVU7Ozs7OztXQUFDLFlBQUc7QUFDdkIsZUFBTyxRQUFRLENBQUM7T0FDakI7Ozs7O0FBT0QsVUFBTTs7Ozs7OzthQUFDLGdCQUFDLFFBQVEsRUFBRTtBQUNoQixZQUFJLEtBQUssR0FBRyxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQzs7QUFFekMsYUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQztBQUM3QyxhQUFLLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUM7QUFDdkMsa0JBQVEsRUFBRSxHQUFHO1NBQ2QsQ0FBQyxDQUFDLENBQUM7O0FBRUosYUFBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztPQUN4Qjs7Ozs7OztTQXhCRyxZQUFZO0dBQVMsTUFBTTs7aUJBMkJsQixZQUFZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDbkNwQixNQUFNLDJCQUFNLFVBQVU7Ozs7Ozs7O0lBUXZCLGFBQWEsY0FBUyxNQUFNO1dBQTVCLGFBQWE7OEJBQWIsYUFBYTs0QkFBYixhQUFhOzs7O1lBQWIsYUFBYSxFQUFTLE1BQU07O3VCQUE1QixhQUFhO0FBTU4sY0FBVTs7Ozs7O1dBQUMsWUFBRztBQUN2QixlQUFPLFNBQVMsQ0FBQztPQUNsQjs7Ozs7QUFPRCxVQUFNOzs7Ozs7O2FBQUMsZ0JBQUMsUUFBUSxFQUFFO0FBQ2hCLFlBQUksS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDOztBQUV6QyxhQUFLLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUM7QUFDeEMsMEJBQWdCLEVBQUU7QUFDaEIsZUFBRyxFQUFFLENBQ0gsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQ1AsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLEVBQ1QsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQ1g7QUFDRCxpQkFBSyxFQUFFLENBQ0wsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQ1AsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQ1IsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQ1g7QUFDRCxnQkFBSSxFQUFFLENBQ0osQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQ1AsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQ1IsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQ1g7V0FDRjtTQUNGLENBQUMsQ0FBQyxDQUFDOztBQUVKLGFBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7T0FDeEI7Ozs7Ozs7U0ExQ0csYUFBYTtHQUFTLE1BQU07O2lCQTZDbkIsYUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ3JEckIsTUFBTSwyQkFBTSxVQUFVOzs7Ozs7OztJQVF2QixXQUFXLGNBQVMsTUFBTTtXQUExQixXQUFXOzhCQUFYLFdBQVc7NEJBQVgsV0FBVzs7OztZQUFYLFdBQVcsRUFBUyxNQUFNOzt1QkFBMUIsV0FBVztBQU1KLGNBQVU7Ozs7OztXQUFDLFlBQUc7QUFDdkIsZUFBTyxPQUFPLENBQUM7T0FDaEI7Ozs7O0FBT0QsVUFBTTs7Ozs7OzthQUFDLGdCQUFDLFFBQVEsRUFBRTtBQUNoQixZQUFJLEtBQUssR0FBRyxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQzs7O0FBR3pDLGFBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQztBQUN4QywwQkFBZ0IsRUFBRTtBQUNoQixlQUFHLEVBQUUsQ0FDSCxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDTixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFDUixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FDWDtBQUNELGlCQUFLLEVBQUUsQ0FDTCxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDTixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FDWDtBQUNELGdCQUFJLEVBQUUsQ0FDSixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDTixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFDUixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FDWDtXQUNGO1NBQ0YsQ0FBQyxDQUFDLENBQUM7O0FBRUosYUFBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztPQUN4Qjs7Ozs7OztTQTVDRyxXQUFXO0dBQVMsTUFBTTs7aUJBK0NqQixXQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNqRHBCLE1BQU07V0FBTixNQUFNOzt1QkFBTixNQUFNO0FBTUMsY0FBVTs7Ozs7O1dBQUMsWUFBRztBQUFFLGVBQU8sSUFBSSxDQUFDO09BQUU7Ozs7O0FBT3pDLFVBQU07Ozs7Ozs7YUFBQyxnQkFBQyxRQUFRLEVBQUU7O0FBRWhCLGNBQU0sSUFBSSxLQUFLLENBQUMsbUVBQW1FLENBQUMsQ0FBQztPQUN0Rjs7Ozs7OztTQWhCRyxNQUFNOzs7Ozs7OztBQXdCWixNQUFNLENBQUMsTUFBTSxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDOzs7QUFHNUMsTUFBTSxDQUFDLGVBQWUsR0FBRyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUN2RCxNQUFNLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztBQUN2QixNQUFNLENBQUMsVUFBVSxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMseUJBQXlCLENBQUMsQ0FBQztBQUNsRSxNQUFNLENBQUMsVUFBVSxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsMkJBQTJCLENBQUMsQ0FBQztBQUNyRSxNQUFNLENBQUMsVUFBVSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMseUJBQXlCLENBQUMsQ0FBQztBQUNqRSxNQUFNLENBQUMsVUFBVSxDQUFDLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO0FBQ2hGLE1BQU0sQ0FBQyxVQUFVLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO0FBQ3RFLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQ3RELE1BQU0sQ0FBQyxVQUFVLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0FBQ2hFLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBQzlELE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQ3RELE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBQzVELE1BQU0sQ0FBQyxVQUFVLENBQUMsVUFBVSxHQUFHLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDOztpQkFFbkQsTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQy9DZCxNQUFNLDJCQUFNLFVBQVU7Ozs7Ozs7O0lBUXZCLFdBQVcsY0FBUyxNQUFNO1dBQTFCLFdBQVc7OEJBQVgsV0FBVzs0QkFBWCxXQUFXOzs7O1lBQVgsV0FBVyxFQUFTLE1BQU07O3VCQUExQixXQUFXO0FBTUosY0FBVTs7Ozs7O1dBQUMsWUFBRztBQUN2QixlQUFPLE9BQU8sQ0FBQztPQUNoQjs7Ozs7QUFPRCxVQUFNOzs7Ozs7O2FBQUMsZ0JBQUMsUUFBUSxFQUFFO0FBQ2hCLFlBQUksS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDOzs7QUFHekMsYUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDO0FBQ3hDLDBCQUFnQixFQUFFO0FBQ2hCLGVBQUcsRUFBRSxDQUNILENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNOLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO0FBQ0QsaUJBQUssRUFBRSxDQUNMLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNOLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO0FBQ0QsZ0JBQUksRUFBRSxDQUNKLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUNQLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO1dBQ0Y7U0FDRixDQUFDLENBQUMsQ0FBQzs7QUFFSixhQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ3hCOzs7Ozs7O1NBaERHLFdBQVc7R0FBUyxNQUFNOztpQkFtRGpCLFdBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUMzRG5CLE1BQU0sMkJBQU0sVUFBVTs7Ozs7Ozs7SUFRdkIsVUFBVSxjQUFTLE1BQU07V0FBekIsVUFBVTs4QkFBVixVQUFVOzRCQUFWLFVBQVU7Ozs7WUFBVixVQUFVLEVBQVMsTUFBTTs7dUJBQXpCLFVBQVU7QUFNSCxjQUFVOzs7Ozs7V0FBQyxZQUFHO0FBQ3ZCLGVBQU8sTUFBTSxDQUFDO09BQ2Y7Ozs7O0FBT0QsVUFBTTs7Ozs7OzthQUFDLGdCQUFDLFFBQVEsRUFBRTtBQUNoQixZQUFJLEtBQUssR0FBRyxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQzs7QUFFekMsYUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDO0FBQ3pDLG9CQUFVLEVBQUUsSUFBSTtTQUNqQixDQUFDLENBQUMsQ0FBQzs7QUFFSixhQUFLLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUM7QUFDdkMsa0JBQVEsRUFBRSxHQUFHO1NBQ2QsQ0FBQyxDQUFDLENBQUM7O0FBRUosYUFBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztPQUN4Qjs7Ozs7OztTQTNCRyxVQUFVO0dBQVMsTUFBTTs7aUJBOEJoQixVQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDdENsQixNQUFNLDJCQUFNLFVBQVU7Ozs7Ozs7O0lBUXZCLFlBQVksY0FBUyxNQUFNO1dBQTNCLFlBQVk7OEJBQVosWUFBWTs0QkFBWixZQUFZOzs7O1lBQVosWUFBWSxFQUFTLE1BQU07O3VCQUEzQixZQUFZO0FBTUwsY0FBVTs7Ozs7O1dBQUMsWUFBRztBQUN2QixlQUFPLFFBQVEsQ0FBQztPQUNqQjs7Ozs7QUFPRCxVQUFNOzs7Ozs7O2FBQUMsZ0JBQUMsUUFBUSxFQUFFO0FBQ2hCLFlBQUksS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDOzs7QUFHekMsYUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDO0FBQ3hDLDBCQUFnQixFQUFFO0FBQ2hCLGVBQUcsRUFBRSxDQUNILENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNOLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO0FBQ0QsaUJBQUssRUFBRSxDQUNMLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUNQLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO0FBQ0QsZ0JBQUksRUFBRSxDQUNKLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUNQLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO1dBQ0Y7U0FDRixDQUFDLENBQUMsQ0FBQzs7QUFFSixhQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ3hCOzs7Ozs7O1NBN0NHLFlBQVk7R0FBUyxNQUFNOztpQkFnRGxCLFlBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUN4RHBCLE1BQU0sMkJBQU0sVUFBVTs7Ozs7Ozs7SUFRdkIsV0FBVyxjQUFTLE1BQU07V0FBMUIsV0FBVzs4QkFBWCxXQUFXOzRCQUFYLFdBQVc7Ozs7WUFBWCxXQUFXLEVBQVMsTUFBTTs7dUJBQTFCLFdBQVc7QUFNSixjQUFVOzs7Ozs7V0FBQyxZQUFHO0FBQ3ZCLGVBQU8sT0FBTyxDQUFDO09BQ2hCOzs7OztBQU9ELFVBQU07Ozs7Ozs7YUFBQyxnQkFBQyxRQUFRLEVBQUU7QUFDaEIsWUFBSSxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsZUFBZSxFQUFFLENBQUM7OztBQUd6QyxhQUFLLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUM7QUFDeEMsMEJBQWdCLEVBQUU7QUFDaEIsZUFBRyxFQUFFLENBQ0gsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQ1AsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQ1IsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLEVBQ1QsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQ1g7QUFDRCxpQkFBSyxFQUFFLENBQ0wsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQ1AsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQ1IsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQ1g7QUFDRCxnQkFBSSxFQUFFLENBQ0osQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQ1AsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQ1IsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLEVBQ1QsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQ1g7V0FDRjtTQUNGLENBQUMsQ0FBQyxDQUFDOztBQUVKLGFBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7T0FDeEI7Ozs7Ozs7U0EvQ0csV0FBVztHQUFTLE1BQU07O2lCQWtEakIsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQzFEbkIsTUFBTSwyQkFBTSxVQUFVOzs7Ozs7OztJQVF2QixVQUFVLGNBQVMsTUFBTTtXQUF6QixVQUFVOzhCQUFWLFVBQVU7NEJBQVYsVUFBVTs7OztZQUFWLFVBQVUsRUFBUyxNQUFNOzt1QkFBekIsVUFBVTtBQU1ILGNBQVU7Ozs7OztXQUFDLFlBQUc7QUFDdkIsZUFBTyxNQUFNLENBQUM7T0FDZjs7Ozs7QUFPRCxVQUFNOzs7Ozs7O2FBQUMsZ0JBQUMsUUFBUSxFQUFFO0FBQ2hCLFlBQUksS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDOztBQUV6QyxhQUFLLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUM7QUFDdkMsa0JBQVEsRUFBRSxHQUFHO1NBQ2QsQ0FBQyxDQUFDLENBQUM7O0FBRUosYUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDO0FBQ3hDLDBCQUFnQixFQUFFO0FBQ2hCLGVBQUcsRUFBRSxDQUNILENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNOLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO0FBQ0QsaUJBQUssRUFBRSxDQUNMLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNOLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO0FBQ0QsZ0JBQUksRUFBRSxDQUNKLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNOLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUNULENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO1dBQ0Y7U0FDRixDQUFDLENBQUMsQ0FBQzs7QUFFSixhQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ3hCOzs7Ozs7O1NBN0NHLFVBQVU7R0FBUyxNQUFNOztpQkFnRGhCLFVBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUN4RGxCLE1BQU0sMkJBQU0sVUFBVTs7Ozs7Ozs7SUFRdkIsYUFBYSxjQUFTLE1BQU07V0FBNUIsYUFBYTs4QkFBYixhQUFhOzRCQUFiLGFBQWE7Ozs7WUFBYixhQUFhLEVBQVMsTUFBTTs7dUJBQTVCLGFBQWE7QUFNTixjQUFVOzs7Ozs7V0FBQyxZQUFHO0FBQ3ZCLGVBQU8sU0FBUyxDQUFDO09BQ2xCOzs7OztBQU9ELFVBQU07Ozs7Ozs7YUFBQyxnQkFBQyxRQUFRLEVBQUU7QUFDaEIsWUFBSSxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsZUFBZSxFQUFFLENBQUM7O0FBRXpDLGFBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7O0FBRTNDLGFBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7T0FDeEI7Ozs7Ozs7U0FyQkcsYUFBYTtHQUFTLE1BQU07O2lCQXdCbkIsYUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ2hDckIsTUFBTSwyQkFBTSxVQUFVOzs7Ozs7OztJQVF2QixjQUFjLGNBQVMsTUFBTTtXQUE3QixjQUFjOzhCQUFkLGNBQWM7NEJBQWQsY0FBYzs7OztZQUFkLGNBQWMsRUFBUyxNQUFNOzt1QkFBN0IsY0FBYztBQU1QLGNBQVU7Ozs7OztXQUFDLFlBQUc7QUFDdkIsZUFBTyxVQUFVLENBQUM7T0FDbkI7Ozs7O0FBT0QsVUFBTTs7Ozs7OzthQUFDLGdCQUFDLFFBQVEsRUFBRSxFQUVqQjs7Ozs7OztTQWpCRyxjQUFjO0dBQVMsTUFBTTs7aUJBb0JwQixjQUFjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQzVCdEIsTUFBTSwyQkFBTSxVQUFVOzs7Ozs7OztJQVF2QixRQUFRLGNBQVMsTUFBTTtXQUF2QixRQUFROzhCQUFSLFFBQVE7NEJBQVIsUUFBUTs7OztZQUFSLFFBQVEsRUFBUyxNQUFNOzt1QkFBdkIsUUFBUTtBQU1ELGNBQVU7Ozs7OztXQUFDLFlBQUc7QUFDdkIsZUFBTyxJQUFJLENBQUM7T0FDYjs7Ozs7QUFPRCxVQUFNOzs7Ozs7O2FBQUMsZ0JBQUMsUUFBUSxFQUFFO0FBQ2hCLFlBQUksS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDOzs7QUFHekMsYUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDO0FBQ3hDLHVCQUFhLEVBQUUsQ0FDYixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDTixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFDUixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFDUixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FDWDtTQUNGLENBQUMsQ0FBQyxDQUFDOzs7QUFHSixhQUFLLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7QUFDekMsb0JBQVUsRUFBRSxHQUFHO1NBQ2hCLENBQUMsQ0FBQyxDQUFDOztBQUVKLGFBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7T0FDeEI7Ozs7Ozs7U0FuQ0csUUFBUTtHQUFTLE1BQU07O2lCQXNDZCxRQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDOUNoQixNQUFNLDJCQUFNLFVBQVU7O0lBQ3RCLEtBQUssMkJBQU0saUJBQWlCOzs7Ozs7OztJQVE3QixRQUFRLGNBQVMsTUFBTTtXQUF2QixRQUFROzhCQUFSLFFBQVE7NEJBQVIsUUFBUTs7OztZQUFSLFFBQVEsRUFBUyxNQUFNOzt1QkFBdkIsUUFBUTtBQU1ELGNBQVU7Ozs7OztXQUFDLFlBQUc7QUFDdkIsZUFBTyxJQUFJLENBQUM7T0FDYjs7Ozs7QUFPRCxVQUFNOzs7Ozs7O2FBQUMsZ0JBQUMsUUFBUSxFQUFFO0FBQ2hCLFlBQUksS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDOzs7QUFHekMsYUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDO0FBQ3hDLHVCQUFhLEVBQUUsQ0FDYixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDTixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFDUixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFDUixDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsRUFDVCxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FDWDtTQUNGLENBQUMsQ0FBQyxDQUFDOzs7QUFHSixhQUFLLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQztBQUMvQyxlQUFLLEVBQUUsSUFBSSxLQUFLLENBQUMsRUFBRSxHQUFHLEdBQUcsRUFBRSxFQUFFLEdBQUcsR0FBRyxFQUFFLEVBQUUsR0FBRyxHQUFHLENBQUM7U0FDL0MsQ0FBQyxDQUFDLENBQUM7O0FBRUosYUFBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztPQUN4Qjs7Ozs7OztTQXRDRyxRQUFRO0dBQVMsTUFBTTs7aUJBeUNkLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNsRGhCLE1BQU0sMkJBQU0sVUFBVTs7Ozs7Ozs7SUFRdkIsUUFBUSxjQUFTLE1BQU07V0FBdkIsUUFBUTs4QkFBUixRQUFROzRCQUFSLFFBQVE7Ozs7WUFBUixRQUFRLEVBQVMsTUFBTTs7dUJBQXZCLFFBQVE7QUFNRCxjQUFVOzs7Ozs7V0FBQyxZQUFHO0FBQ3ZCLGVBQU8sSUFBSSxDQUFDO09BQ2I7Ozs7O0FBT0QsVUFBTTs7Ozs7OzthQUFDLGdCQUFDLFFBQVEsRUFBRTtBQUNoQixZQUFJLEtBQUssR0FBRyxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQzs7O0FBR3pDLGFBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztBQUN6QyxvQkFBVSxFQUFFLEdBQUc7U0FDaEIsQ0FBQyxDQUFDLENBQUM7O0FBRUosYUFBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztPQUN4Qjs7Ozs7OztTQXhCRyxRQUFRO0dBQVMsTUFBTTs7aUJBMkJkLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNuQ2hCLE1BQU0sMkJBQU0sVUFBVTs7Ozs7Ozs7SUFRdkIsY0FBYyxjQUFTLE1BQU07V0FBN0IsY0FBYzs4QkFBZCxjQUFjOzRCQUFkLGNBQWM7Ozs7WUFBZCxjQUFjLEVBQVMsTUFBTTs7dUJBQTdCLGNBQWM7QUFNUCxjQUFVOzs7Ozs7V0FBQyxZQUFHO0FBQ3ZCLGVBQU8sVUFBVSxDQUFDO09BQ25COzs7OztBQU9ELFVBQU07Ozs7Ozs7YUFBQyxnQkFBQyxRQUFRLEVBQUU7QUFDaEIsWUFBSSxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsZUFBZSxFQUFFLENBQUM7OztBQUd6QyxhQUFLLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUM7QUFDeEMsdUJBQWEsRUFBRSxDQUNiLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNOLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxFQUNULENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO1NBQ0YsQ0FBQyxDQUFDLENBQUM7OztBQUdKLGFBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztBQUN6QyxvQkFBVSxFQUFFLEdBQUc7U0FDaEIsQ0FBQyxDQUFDLENBQUM7O0FBRUosYUFBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztPQUN4Qjs7Ozs7OztTQXJDRyxjQUFjO0dBQVMsTUFBTTs7aUJBd0NwQixjQUFjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDaER0QixNQUFNLDJCQUFNLFVBQVU7Ozs7Ozs7O0lBUXZCLFdBQVcsY0FBUyxNQUFNO1dBQTFCLFdBQVc7OEJBQVgsV0FBVzs0QkFBWCxXQUFXOzs7O1lBQVgsV0FBVyxFQUFTLE1BQU07O3VCQUExQixXQUFXO0FBTUosY0FBVTs7Ozs7O1dBQUMsWUFBRztBQUN2QixlQUFPLE9BQU8sQ0FBQztPQUNoQjs7Ozs7QUFPRCxVQUFNOzs7Ozs7O2FBQUMsZ0JBQUMsUUFBUSxFQUFFO0FBQ2hCLFlBQUksS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDOzs7QUFHekMsYUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDO0FBQzNDLHNCQUFZLEVBQUUsR0FBRztTQUNsQixDQUFDLENBQUMsQ0FBQzs7O0FBR0osYUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDO0FBQ3hDLDBCQUFnQixFQUFFO0FBQ2hCLGVBQUcsRUFBRSxDQUNILENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUNQLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO0FBQ0QsaUJBQUssRUFBRSxDQUNMLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUNQLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO0FBQ0QsZ0JBQUksRUFBRSxDQUNKLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUNQLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO1dBQ0Y7U0FDRixDQUFDLENBQUMsQ0FBQzs7QUFFSixhQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ3hCOzs7Ozs7O1NBekRHLFdBQVc7R0FBUyxNQUFNOztpQkE0RGpCLFdBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNwRW5CLE1BQU0sMkJBQU0sVUFBVTs7Ozs7Ozs7SUFRdkIsVUFBVSxjQUFTLE1BQU07V0FBekIsVUFBVTs4QkFBVixVQUFVOzRCQUFWLFVBQVU7Ozs7WUFBVixVQUFVLEVBQVMsTUFBTTs7dUJBQXpCLFVBQVU7QUFPSCxjQUFVOzs7Ozs7O1dBQUMsWUFBRztBQUN2QixlQUFPLE1BQU0sQ0FBQztPQUNmOzs7OztBQU9ELFVBQU07Ozs7Ozs7YUFBQyxnQkFBQyxRQUFRLEVBQUU7QUFDaEIsWUFBSSxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsZUFBZSxFQUFFLENBQUM7O0FBRXpDLGFBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQztBQUN4Qyx1QkFBYSxFQUFFLENBQ2IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ04sQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQ1IsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQ1g7U0FDRixDQUFDLENBQUMsQ0FBQzs7QUFFSixhQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ3hCOzs7Ozs7O1NBOUJHLFVBQVU7R0FBUyxNQUFNOztpQkFpQ2hCLFVBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUN6Q2xCLE1BQU0sMkJBQU0sVUFBVTs7Ozs7Ozs7SUFRdkIsWUFBWSxjQUFTLE1BQU07V0FBM0IsWUFBWTs4QkFBWixZQUFZOzRCQUFaLFlBQVk7Ozs7WUFBWixZQUFZLEVBQVMsTUFBTTs7dUJBQTNCLFlBQVk7QUFNTCxjQUFVOzs7Ozs7V0FBQyxZQUFHO0FBQ3ZCLGVBQU8sUUFBUSxDQUFDO09BQ2pCOzs7OztBQU9ELFVBQU07Ozs7Ozs7YUFBQyxnQkFBQyxRQUFRLEVBQUU7QUFDaEIsWUFBSSxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsZUFBZSxFQUFFLENBQUM7O0FBRXpDLGFBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQztBQUN4QywwQkFBZ0IsRUFBRTtBQUNoQixlQUFHLEVBQUUsQ0FDSCxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDTixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFDUixDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsRUFDVCxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FDWDtBQUNELGlCQUFLLEVBQUUsQ0FDTCxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDTixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FDWDtBQUNELGdCQUFJLEVBQUUsQ0FDSixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDTixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FDWDtXQUNGO1NBQ0YsQ0FBQyxDQUFDLENBQUM7O0FBRUosYUFBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztPQUN4Qjs7Ozs7OztTQXRDRyxZQUFZO0dBQVMsTUFBTTs7aUJBeUNsQixZQUFZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDakRwQixNQUFNLDJCQUFNLFVBQVU7Ozs7Ozs7O0lBUXZCLGFBQWEsY0FBUyxNQUFNO1dBQTVCLGFBQWE7OEJBQWIsYUFBYTs0QkFBYixhQUFhOzs7O1lBQWIsYUFBYSxFQUFTLE1BQU07O3VCQUE1QixhQUFhO0FBTU4sY0FBVTs7Ozs7O1dBQUMsWUFBRztBQUN2QixlQUFPLFNBQVMsQ0FBQztPQUNsQjs7Ozs7QUFPRCxVQUFNOzs7Ozs7O2FBQUMsZ0JBQUMsUUFBUSxFQUFFO0FBQ2hCLFlBQUksS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDOztBQUV6QyxhQUFLLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUM7QUFDeEMsMEJBQWdCLEVBQUU7QUFDaEIsZUFBRyxFQUFFLENBQ0gsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQ1AsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQ1g7QUFDRCxpQkFBSyxFQUFFLENBQ0wsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQ1AsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQ1g7QUFDRCxnQkFBSSxFQUFFLENBQ0osQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQ1AsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQ1g7V0FDRjtTQUNGLENBQUMsQ0FBQyxDQUFDOztBQUVKLGFBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7O0FBRXhDLGFBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7T0FDeEI7Ozs7Ozs7U0F0Q0csYUFBYTtHQUFTLE1BQU07O2lCQXlDbkIsYUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ2pEckIsTUFBTSwyQkFBTSxVQUFVOzs7Ozs7OztJQVF2QixZQUFZLGNBQVMsTUFBTTtXQUEzQixZQUFZOzhCQUFaLFlBQVk7NEJBQVosWUFBWTs7OztZQUFaLFlBQVksRUFBUyxNQUFNOzt1QkFBM0IsWUFBWTtBQU1MLGNBQVU7Ozs7OztXQUFDLFlBQUc7QUFDdkIsZUFBTyxRQUFRLENBQUM7T0FDakI7Ozs7O0FBT0QsVUFBTTs7Ozs7OzthQUFDLGdCQUFDLFFBQVEsRUFBRTtBQUNoQixZQUFJLEtBQUssR0FBRyxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQzs7O0FBR3pDLGFBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQztBQUN4QywwQkFBZ0IsRUFBRTtBQUNoQixlQUFHLEVBQUUsQ0FDSCxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDTixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FDWDtBQUNELGlCQUFLLEVBQUUsQ0FDTCxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDTixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FDWDtBQUNELGdCQUFJLEVBQUUsQ0FDSixDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFDUCxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFDUixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FDWDtXQUNGO1NBQ0YsQ0FBQyxDQUFDLENBQUM7OztBQUdKLGFBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQztBQUN4Qyx1QkFBYSxFQUFFLENBQ2IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ04sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQ1g7U0FDRixDQUFDLENBQUMsQ0FBQzs7O0FBR0osYUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDO0FBQzNDLHNCQUFZLEVBQUUsSUFBSTtTQUNuQixDQUFDLENBQUMsQ0FBQzs7QUFFSixhQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ3hCOzs7Ozs7O1NBMURHLFlBQVk7R0FBUyxNQUFNOztpQkE2RGxCLFlBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNyRXBCLE1BQU0sMkJBQU0sVUFBVTs7Ozs7Ozs7SUFRdkIsVUFBVSxjQUFTLE1BQU07V0FBekIsVUFBVTs4QkFBVixVQUFVOzRCQUFWLFVBQVU7Ozs7WUFBVixVQUFVLEVBQVMsTUFBTTs7dUJBQXpCLFVBQVU7QUFNSCxjQUFVOzs7Ozs7V0FBQyxZQUFHO0FBQ3ZCLGVBQU8sTUFBTSxDQUFDO09BQ2Y7Ozs7O0FBT0QsVUFBTTs7Ozs7OzthQUFDLGdCQUFDLFFBQVEsRUFBRTtBQUNoQixZQUFJLEtBQUssR0FBRyxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQzs7QUFFekMsYUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDO0FBQ3hDLDBCQUFnQixFQUFFO0FBQ2hCLGVBQUcsRUFBRSxDQUNILENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNOLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO0FBQ0QsaUJBQUssRUFBRSxDQUNMLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNOLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNSLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO0FBQ0QsZ0JBQUksRUFBRSxDQUNKLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUNOLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUNULENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUNWLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUNYO1dBQ0Y7U0FDRixDQUFDLENBQUMsQ0FBQzs7QUFFSixhQUFLLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7QUFDekMsb0JBQVUsRUFBRSxHQUFHO1NBQ2hCLENBQUMsQ0FBQyxDQUFDOztBQUVKLGFBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQztBQUN2QyxrQkFBUSxFQUFFLEdBQUc7U0FDZCxDQUFDLENBQUMsQ0FBQzs7QUFFSixhQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ3hCOzs7Ozs7O1NBbkRHLFVBQVU7R0FBUyxNQUFNOztpQkFzRGhCLFVBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUM5RGxCLE1BQU0sMkJBQU0sVUFBVTs7Ozs7Ozs7SUFRdkIsYUFBYSxjQUFTLE1BQU07V0FBNUIsYUFBYTs4QkFBYixhQUFhOzRCQUFiLGFBQWE7Ozs7WUFBYixhQUFhLEVBQVMsTUFBTTs7dUJBQTVCLGFBQWE7QUFNTixjQUFVOzs7Ozs7V0FBQyxZQUFHO0FBQ3ZCLGVBQU8sU0FBUyxDQUFDO09BQ2xCOzs7OztBQU9ELFVBQU07Ozs7Ozs7YUFBQyxnQkFBQyxRQUFRLEVBQUU7QUFDaEIsWUFBSSxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsZUFBZSxFQUFFLENBQUM7O0FBRXpDLGFBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQztBQUN4QywwQkFBZ0IsRUFBRTtBQUNoQixlQUFHLEVBQUUsQ0FDSCxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDTixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFDUixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FDWDtBQUNELGlCQUFLLEVBQUUsQ0FDTCxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFDUCxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFDUixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FDWDtBQUNELGdCQUFJLEVBQUUsQ0FDSixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDTixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFDVixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FDWDtXQUNGO1NBQ0YsQ0FBQyxDQUFDLENBQUM7O0FBRUosYUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDO0FBQ3pDLG9CQUFVLEVBQUUsR0FBRztTQUNoQixDQUFDLENBQUMsQ0FBQzs7QUFFSixhQUFLLENBQUMsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUM7QUFDdkMsa0JBQVEsRUFBRSxHQUFHO1NBQ2QsQ0FBQyxDQUFDLENBQUM7O0FBRUosYUFBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztPQUN4Qjs7Ozs7OztTQWpERyxhQUFhO0dBQVMsTUFBTTs7aUJBb0RuQixhQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDdER0QixlQUFlO0FBQ1AsV0FEUixlQUFlLEdBQ0c7c0NBQU4sSUFBSTtBQUFKLFVBQUk7OztBQUNsQiwrQkFGRSxlQUFlLDhDQUVSLElBQUksRUFBRTs7Ozs7OztBQU9mLFFBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO0dBQ2xCOzt1QkFWRyxlQUFlO0FBZ0JuQixPQUFHOzs7Ozs7YUFBQyxhQUFDLFNBQVMsRUFBRTtBQUNkLFlBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO09BQzdCOzs7OztBQU1ELFVBQU07Ozs7OzthQUFDLGdCQUFDLFFBQVEsRUFBRTtBQUNoQixhQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDM0MsY0FBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMvQixtQkFBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUM1QjtPQUNGOzs7Ozs7O1NBN0JHLGVBQWU7OztpQkFnQ04sZUFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUN0Q3ZCLENBQUMsMkJBQU0sUUFBUTs7SUFDZixTQUFTLDJCQUFNLGFBQWE7Ozs7Ozs7O0lBUTdCLFVBQVUsY0FBUyxTQUFTO0FBQ3BCLFdBRFIsVUFBVSxHQUNRO3NDQUFOLElBQUk7QUFBSixVQUFJOzs7QUFDbEIsK0JBRkUsVUFBVSw4Q0FFSCxJQUFJLEVBQUU7O0FBRWYsUUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7QUFDeEMsZ0JBQVUsRUFBRSxDQUFHO0tBQ2hCLENBQUMsQ0FBQzs7Ozs7OztBQU9ILFFBQUksQ0FBQyxlQUFlLDRUQVluQixDQUFDO0dBRUg7O1lBM0JHLFVBQVUsRUFBUyxTQUFTOzt1QkFBNUIsVUFBVTtBQWtDZCxlQUFXOzs7Ozs7O2FBQUMscUJBQUMsUUFBUSxFQUFFO0FBQ3JCLGdCQUFRLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFO0FBQzdDLGtCQUFRLEVBQUU7QUFDUix3QkFBWSxFQUFFLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUU7V0FDN0Q7U0FDRixDQUFDLENBQUM7T0FDSjs7Ozs7QUFNRCxnQkFBWTs7Ozs7O2FBQUMsc0JBQUMsUUFBUSxFQUFFO0FBQ3RCLFlBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUNsQyxZQUFJLFNBQVMsR0FBRyxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDdEYsWUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUM7O0FBRTFDLGFBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3JDLGVBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3RDLGdCQUFJLEtBQUssR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQSxHQUFJLENBQUMsQ0FBQzs7QUFFdkMscUJBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxVQUFVLEdBQUcsR0FBRyxDQUFDO0FBQ3JFLHFCQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxVQUFVLEdBQUcsR0FBRyxDQUFDO0FBQ3pFLHFCQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxVQUFVLEdBQUcsR0FBRyxDQUFDO1dBQzFFO1NBQ0Y7O0FBRUQsZ0JBQVEsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztPQUNyRDs7Ozs7OztTQTlERyxVQUFVO0dBQVMsU0FBUzs7aUJBaUVuQixVQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQzFFbEIsQ0FBQywyQkFBTSxRQUFROztJQUNmLFNBQVMsMkJBQU0sYUFBYTs7Ozs7Ozs7SUFRN0IsUUFBUSxjQUFTLFNBQVM7QUFDbEIsV0FEUixRQUFRLEdBQ1U7c0NBQU4sSUFBSTtBQUFKLFVBQUk7OztBQUNsQiwrQkFGRSxRQUFRLDhDQUVELElBQUksRUFBRTs7QUFFZixRQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtBQUN4QyxjQUFRLEVBQUUsQ0FBRztLQUNkLENBQUMsQ0FBQzs7Ozs7OztBQU9ILFFBQUksQ0FBQyxlQUFlLDRVQVluQixDQUFDO0dBQ0g7O1lBMUJHLFFBQVEsRUFBUyxTQUFTOzt1QkFBMUIsUUFBUTtBQWlDWixlQUFXOzs7Ozs7O2FBQUMscUJBQUMsUUFBUSxFQUFFO0FBQ3JCLGdCQUFRLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFO0FBQzdDLGtCQUFRLEVBQUU7QUFDUixzQkFBVSxFQUFFLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUU7V0FDekQ7U0FDRixDQUFDLENBQUM7T0FDSjs7Ozs7QUFNRCxnQkFBWTs7Ozs7O2FBQUMsc0JBQUMsUUFBUSxFQUFFO0FBQ3RCLFlBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUNsQyxZQUFJLFNBQVMsR0FBRyxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDdEYsWUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUM7O0FBRXRDLGFBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3JDLGVBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3RDLGdCQUFJLEtBQUssR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQSxHQUFJLENBQUMsQ0FBQzs7QUFFdkMscUJBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQSxHQUFJLFFBQVEsR0FBRyxHQUFHLENBQUM7QUFDM0UscUJBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFBLEdBQUksUUFBUSxHQUFHLEdBQUcsQ0FBQztBQUMvRSxxQkFBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUEsR0FBSSxRQUFRLEdBQUcsR0FBRyxDQUFDO1dBQ2hGO1NBQ0Y7O0FBRUQsZ0JBQVEsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztPQUNyRDs7Ozs7OztTQTdERyxRQUFRO0dBQVMsU0FBUzs7aUJBZ0VqQixRQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ3pFaEIsQ0FBQywyQkFBTSxRQUFROztJQUNmLFNBQVMsMkJBQU0sYUFBYTs7Ozs7Ozs7SUFRN0IsWUFBWSxjQUFTLFNBQVM7QUFDdEIsV0FEUixZQUFZLEdBQ007c0NBQU4sSUFBSTtBQUFKLFVBQUk7OztBQUNsQiwrQkFGRSxZQUFZLDhDQUVMLElBQUksRUFBRTs7QUFFZixRQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtBQUN4QyxrQkFBWSxFQUFFLENBQUc7S0FDbEIsQ0FBQyxDQUFDOzs7Ozs7O0FBT0gsUUFBSSxDQUFDLGVBQWUsa2VBY25CLENBQUM7R0FDSDs7WUE1QkcsWUFBWSxFQUFTLFNBQVM7O3VCQUE5QixZQUFZO0FBb0NoQixlQUFXOzs7Ozs7OzthQUFDLHFCQUFDLFFBQVEsRUFBRTtBQUNyQixnQkFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGVBQWUsRUFBRTtBQUM3QyxrQkFBUSxFQUFFO0FBQ1IsMEJBQWMsRUFBRSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFO1dBQ2pFO1NBQ0YsQ0FBQyxDQUFDO09BQ0o7Ozs7O0FBTUQsZ0JBQVk7Ozs7OzthQUFDLHNCQUFDLFFBQVEsRUFBRTtBQUN0QixZQUFJLE1BQU0sR0FBRyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDbEMsWUFBSSxTQUFTLEdBQUcsUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3RGLFlBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDOztBQUU5QyxhQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNyQyxlQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN0QyxnQkFBSSxLQUFLLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUEsR0FBSSxDQUFDLENBQUM7O0FBRXZDLGdCQUFJLFNBQVMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQ2xILHFCQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLFNBQVMsSUFBSSxDQUFDLEdBQUcsWUFBWSxDQUFBLEFBQUMsR0FBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLFlBQVksQUFBQyxDQUFDO0FBQ2hHLHFCQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTLElBQUksQ0FBQyxHQUFHLFlBQVksQ0FBQSxBQUFDLEdBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsWUFBWSxBQUFDLENBQUM7QUFDeEcscUJBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLFNBQVMsSUFBSSxDQUFDLEdBQUcsWUFBWSxDQUFBLEFBQUMsR0FBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxZQUFZLEFBQUMsQ0FBQztXQUN6RztTQUNGOztBQUVELGdCQUFRLENBQUMsVUFBVSxFQUFFLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7T0FDckQ7Ozs7Ozs7U0FqRUcsWUFBWTtHQUFTLFNBQVM7O2lCQW9FckIsWUFBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUM3RXBCLENBQUMsMkJBQU0sUUFBUTs7SUFDZixTQUFTLDJCQUFNLGFBQWE7O0lBQzVCLEtBQUssMkJBQU0sb0JBQW9COzs7Ozs7OztJQVFoQyxJQUFJLGNBQVMsU0FBUztBQUNkLFdBRFIsSUFBSSxHQUNjO3NDQUFOLElBQUk7QUFBSixVQUFJOzs7QUFDbEIsK0JBRkUsSUFBSSw4Q0FFRyxJQUFJLEVBQUU7O0FBRWYsUUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7QUFDeEMsV0FBSyxFQUFFLElBQUksS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQzFCLENBQUMsQ0FBQzs7Ozs7OztBQU9ILFFBQUksQ0FBQyxlQUFlLHdnQkFrQm5CLENBQUM7R0FDSDs7WUFoQ0csSUFBSSxFQUFTLFNBQVM7O3VCQUF0QixJQUFJO0FBd0NSLGVBQVc7Ozs7Ozs7O2FBQUMscUJBQUMsUUFBUSxFQUFFO0FBQ3JCLGdCQUFRLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFO0FBQzdDLGtCQUFRLEVBQUU7QUFDUixtQkFBTyxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFFLEVBQUM7V0FDbEU7U0FDRixDQUFDLENBQUM7T0FDSjs7Ozs7QUFPRCxnQkFBWTs7Ozs7OzthQUFDLHNCQUFDLFFBQVEsRUFBRTtBQUN0QixZQUFJLE1BQU0sR0FBRyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDbEMsWUFBSSxTQUFTLEdBQUcsUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3RGLFlBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDOztBQUVoQyxZQUFJLENBQUMsQ0FBQztBQUNOLGFBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3JDLGVBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3RDLGdCQUFJLEtBQUssR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQSxHQUFJLENBQUMsQ0FBQzs7QUFFdkMsZ0JBQUksR0FBRyxHQUFHLENBQUMsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDO0FBQzNCLGdCQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQzs7QUFFNUIsZ0JBQUksRUFBRSxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQSxHQUFJLElBQUksQ0FBQztBQUM1QixnQkFBSSxFQUFFLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFBLEdBQUksSUFBSSxDQUFDOztBQUU1QixnQkFBSSxPQUFPLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztBQUN0QixnQkFBSSxPQUFPLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztBQUN0QixhQUFDLEdBQUcsQ0FBQyxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUEsQUFBQyxDQUFDO0FBQzVCLGFBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUcsQ0FBQyxDQUFDOztBQUVwQyxxQkFBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFBLEFBQUMsQ0FBQztBQUNyRSxxQkFBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUEsQUFBQyxDQUFDO0FBQzdFLHFCQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQSxBQUFDLENBQUM7QUFDN0UscUJBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztXQUNqQztTQUNGOztBQUVELGdCQUFRLENBQUMsVUFBVSxFQUFFLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7T0FDckQ7Ozs7Ozs7U0FsRkcsSUFBSTtHQUFTLFNBQVM7O2lCQXFGYixJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQy9GWixTQUFTLDJCQUFNLGFBQWE7Ozs7Ozs7O0lBUTdCLE9BQU8sY0FBUyxTQUFTO0FBQ2pCLFdBRFIsT0FBTyxHQUNXO3NDQUFOLElBQUk7QUFBSixVQUFJOzs7QUFDbEIsK0JBRkUsT0FBTyw4Q0FFQSxJQUFJLEVBQUU7Ozs7Ozs7QUFPZixRQUFJLENBQUMsZUFBZSwyWUFhbkIsQ0FBQztHQUNIOztZQXZCRyxPQUFPLEVBQVMsU0FBUzs7dUJBQXpCLE9BQU87QUErQlgsZUFBVzs7Ozs7Ozs7YUFBQyxxQkFBQyxRQUFRLEVBQUU7QUFDckIsZ0JBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztPQUNoRDs7Ozs7QUFNRCxnQkFBWTs7Ozs7O2FBQUMsc0JBQUMsUUFBUSxFQUFFO0FBQ3RCLFlBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUNsQyxZQUFJLFNBQVMsR0FBRyxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7O0FBRXRGLGFBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3JDLGVBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3RDLGdCQUFJLEtBQUssR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQSxHQUFJLENBQUMsQ0FBQzs7QUFFdkMscUJBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztBQUM3RCxxQkFBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUNwRCxxQkFBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDMUQscUJBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUM1RCxxQkFBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1dBQ2pDO1NBQ0Y7O0FBRUQsZ0JBQVEsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztPQUNyRDs7Ozs7OztTQXhERyxPQUFPO0dBQVMsU0FBUzs7aUJBMkRoQixPQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ25FZixTQUFTLDJCQUFNLGFBQWE7Ozs7Ozs7O0lBUTdCLFNBQVMsY0FBUyxTQUFTO0FBQ25CLFdBRFIsU0FBUyxHQUNTO3NDQUFOLElBQUk7QUFBSixVQUFJOzs7QUFDbEIsK0JBRkUsU0FBUyw4Q0FFRixJQUFJLEVBQUU7Ozs7Ozs7QUFPZixRQUFJLENBQUMsZUFBZSx5VkFXbkIsQ0FBQztHQUNIOztZQXJCRyxTQUFTLEVBQVMsU0FBUzs7dUJBQTNCLFNBQVM7QUE2QmIsZUFBVzs7Ozs7Ozs7YUFBQyxxQkFBQyxRQUFRLEVBQUU7QUFDckIsZ0JBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztPQUNoRDs7Ozs7QUFNRCxnQkFBWTs7Ozs7O2FBQUMsc0JBQUMsUUFBUSxFQUFFO0FBQ3RCLFlBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUNsQyxZQUFJLFNBQVMsR0FBRyxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7O0FBRXRGLGFBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3JDLGVBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3RDLGdCQUFJLEtBQUssR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQSxHQUFJLENBQUMsQ0FBQzs7QUFFdkMsZ0JBQUksU0FBUyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsTUFBTSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7O0FBRXpILHFCQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLFNBQVMsQ0FBQztBQUNsQyxxQkFBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDO0FBQ3RDLHFCQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUM7V0FDdkM7U0FDRjs7QUFFRCxnQkFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO09BQ3JEOzs7Ozs7O1NBdERHLFNBQVM7R0FBUyxTQUFTOztpQkF5RGxCLFNBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNqRWpCLFNBQVMsMkJBQU0sYUFBYTs7Ozs7Ozs7O0lBUzdCLFdBQVcsY0FBUyxTQUFTO0FBQ3JCLFdBRFIsV0FBVyxHQUNBO0FBQ2IsYUFBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7O0FBRWpDLFFBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7O0FBT3ZCLFFBQUksQ0FBQyxlQUFlLHFmQWNuQixDQUFDO0dBQ0g7O1lBMUJHLFdBQVcsRUFBUyxTQUFTOzt1QkFBN0IsV0FBVztBQWlDZixlQUFXOzs7Ozs7O2FBQUMscUJBQUMsUUFBUSxFQUFFO0FBQ3JCLFlBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUM7O0FBRTlCLGdCQUFRLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFO0FBQzdDLGtCQUFRLEVBQUU7QUFDUix5QkFBYSxFQUFFLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFO1dBQ3ZDO1NBQ0YsQ0FBQyxDQUFDO09BQ0o7Ozs7O0FBTUQsZ0JBQVk7Ozs7OzthQUFDLHNCQUFDLFFBQVEsRUFBRTtBQUN0QixZQUFJLE1BQU0sR0FBRyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDbEMsWUFBSSxTQUFTLEdBQUcsUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3RGLFlBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDOztBQUUvQixhQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNyQyxlQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN0QyxnQkFBSSxLQUFLLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUEsR0FBSSxDQUFDLENBQUM7O0FBRXZDLGdCQUFJLENBQUMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzlCLHFCQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDckMsZ0JBQUksQ0FBQyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2xDLHFCQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUM3QyxnQkFBSSxDQUFDLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDbEMscUJBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1dBQzlDO1NBQ0Y7O0FBRUQsZ0JBQVEsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztPQUNyRDs7Ozs7QUFPRCxrQkFBYzs7Ozs7OzthQUFDLHVCQUFDLFFBQVEsRUFBRTtBQUN4QixZQUFJLEVBQUUsR0FBRyxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUM7O0FBRS9CLFlBQUksT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxXQUFXLEVBQUU7QUFDN0MsZ0JBQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztTQUNwRDs7QUFFRCxZQUFJLGNBQWMsR0FBRyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDOztBQUV4RCxVQUFFLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ25ELFlBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO0FBQ2xCLGNBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDLGFBQWEsRUFBRSxDQUFDO1NBQ3BDO0FBQ0QsVUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzs7QUFFN0MsVUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDbEUsVUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDbEUsVUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxjQUFjLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3JFLFVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsY0FBYyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsQ0FBQzs7QUFFckUsVUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLGFBQWEsRUFBRSxjQUFjLENBQUMsQ0FBQztBQUMvRixVQUFFLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztPQUMvQjs7Ozs7OztTQS9GRyxXQUFXO0dBQVMsU0FBUzs7aUJBa0dwQixXQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNyR3BCLFNBQVM7QUFDRCxXQURSLFNBQVMsQ0FDQSxPQUFPLEVBQUU7QUFDcEIsV0FBTyxHQUFHLE9BQU8sSUFBSSxFQUFFLENBQUM7O0FBRXhCLFFBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO0dBQ3pCOzt1QkFMRyxTQUFTO0FBWWIsVUFBTTs7Ozs7OzthQUFDLGdCQUFDLFFBQVEsRUFBRTtBQUNoQixZQUFJLFFBQVEsQ0FBQyxVQUFVLEtBQUssT0FBTyxFQUFFO0FBQ25DLGNBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDNUIsTUFBTTtBQUNMLGNBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDN0I7T0FDRjs7Ozs7QUFPRCxlQUFXOzs7Ozs7O2FBQUMscUJBQUMsUUFBUSxFQUFFOztBQUVyQixjQUFNLElBQUksS0FBSyxDQUFDLDJFQUEyRSxDQUFDLENBQUM7T0FDOUY7Ozs7O0FBTUQsZ0JBQVk7Ozs7OzthQUFDLHNCQUFDLFFBQVEsRUFBRTs7QUFFdEIsY0FBTSxJQUFJLEtBQUssQ0FBQyw0RUFBNEUsQ0FBQyxDQUFDO09BQy9GOzs7Ozs7O1NBckNHLFNBQVM7OztpQkF3Q0EsU0FBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUM5Q2pCLENBQUMsMkJBQU0sUUFBUTs7SUFDZixTQUFTLDJCQUFNLGFBQWE7Ozs7Ozs7O0lBUTdCLFVBQVUsY0FBUyxTQUFTO0FBQ3BCLFdBRFIsVUFBVSxHQUNRO3NDQUFOLElBQUk7QUFBSixVQUFJOzs7QUFDbEIsK0JBRkUsVUFBVSw4Q0FFSCxJQUFJLEVBQUU7O0FBRWYsUUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7QUFDeEMsZ0JBQVUsRUFBRSxDQUFDO0tBQ2QsQ0FBQyxDQUFDOzs7Ozs7O0FBT0gsUUFBSSxDQUFDLGVBQWUsaWdCQWdCbkIsQ0FBQztHQUNIOztZQTlCRyxVQUFVLEVBQVMsU0FBUzs7dUJBQTVCLFVBQVU7QUFxQ2QsZUFBVzs7Ozs7OzthQUFDLHFCQUFDLFFBQVEsRUFBRTtBQUNyQixnQkFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGVBQWUsRUFBRTtBQUM3QyxrQkFBUSxFQUFFO0FBQ1Isd0JBQVksRUFBRSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFO1dBQzdEO1NBQ0YsQ0FBQyxDQUFDO09BQ0o7Ozs7O0FBT0QsZ0JBQVk7Ozs7Ozs7YUFBQyxzQkFBQyxRQUFRLEVBQUU7QUFDdEIsWUFBSSxNQUFNLEdBQUcsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDO0FBQ2xDLFlBQUksU0FBUyxHQUFHLFFBQVEsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN0RixZQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQzs7QUFFMUMsWUFBSSxDQUFDLENBQUM7QUFDTixhQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNyQyxlQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN0QyxnQkFBSSxLQUFLLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUEsR0FBSSxDQUFDLENBQUM7O0FBRXZDLGdCQUFJLFNBQVMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLE1BQU0sR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDO0FBQ3pILHFCQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLFNBQVMsSUFBSSxDQUFDLEdBQUcsVUFBVSxDQUFBLEFBQUMsR0FBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLFVBQVUsQUFBQyxDQUFDO0FBQzVGLHFCQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTLElBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBQSxBQUFDLEdBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxBQUFDLENBQUM7QUFDcEcscUJBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLFNBQVMsSUFBSSxDQUFDLEdBQUcsVUFBVSxDQUFBLEFBQUMsR0FBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxVQUFVLEFBQUMsQ0FBQztXQUNyRztTQUNGOztBQUVELGdCQUFRLENBQUMsVUFBVSxFQUFFLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7T0FDckQ7Ozs7Ozs7U0FwRUcsVUFBVTtHQUFTLFNBQVM7O2lCQXVFbkIsVUFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNoRmxCLENBQUMsMkJBQU0sUUFBUTs7SUFDZixTQUFTLDJCQUFNLGFBQWE7O0lBQzVCLEtBQUssMkJBQU0sb0JBQW9COzs7Ozs7OztJQVFoQyxnQkFBZ0IsY0FBUyxTQUFTO0FBQzFCLFdBRFIsZ0JBQWdCLEdBQ0U7c0NBQU4sSUFBSTtBQUFKLFVBQUk7OztBQUNsQiwrQkFGRSxnQkFBZ0IsOENBRVQsSUFBSSxFQUFFOztBQUVmLFFBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO0FBQ3hDLFdBQUssRUFBRSxJQUFJLEtBQUssQ0FBQyxDQUFHLEVBQUUsQ0FBRyxFQUFFLENBQUcsQ0FBQztLQUNoQyxDQUFDLENBQUM7Ozs7Ozs7QUFPSCxRQUFJLENBQUMsZUFBZSxrVkFXbkIsQ0FBQztHQUNIOztZQXpCRyxnQkFBZ0IsRUFBUyxTQUFTOzt1QkFBbEMsZ0JBQWdCO0FBZ0NwQixlQUFXOzs7Ozs7O2FBQUMscUJBQUMsUUFBUSxFQUFFO0FBQ3JCLGdCQUFRLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFO0FBQzdDLGtCQUFRLEVBQUU7QUFDUixxQkFBUyxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFFLEVBQUU7V0FDckU7U0FDRixDQUFDLENBQUM7T0FDSjs7Ozs7QUFNRCxnQkFBWTs7Ozs7O2FBQUMsc0JBQUMsUUFBUSxFQUFFO0FBQ3RCLFlBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUNsQyxZQUFJLFNBQVMsR0FBRyxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7O0FBRXRGLGFBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3JDLGVBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3RDLGdCQUFJLEtBQUssR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQSxHQUFJLENBQUMsQ0FBQzs7QUFFdkMscUJBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQy9FLHFCQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3ZGLHFCQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1dBQ3hGO1NBQ0Y7O0FBRUQsZ0JBQVEsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztPQUNyRDs7Ozs7OztTQTNERyxnQkFBZ0I7R0FBUyxTQUFTOztpQkE4RHpCLGdCQUFnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUN4RXhCLENBQUMsMkJBQU0sUUFBUTs7SUFDZixXQUFXLDJCQUFNLGdCQUFnQjs7Ozs7Ozs7SUFRbEMsU0FBUyxjQUFTLFdBQVc7QUFDckIsV0FEUixTQUFTLEdBQ1M7c0NBQU4sSUFBSTtBQUFKLFVBQUk7OztBQUNsQiwrQkFGRSxTQUFTLDhDQUVGLElBQUksRUFBRTs7QUFFZixRQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtBQUN4QyxzQkFBZ0IsRUFBRTtBQUNoQixXQUFHLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhO0FBQ2hDLGFBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWE7QUFDbEMsWUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYTtPQUNsQztLQUNGLENBQUMsQ0FBQzs7QUFFSCxRQUFJLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsS0FBSyxXQUFXLEVBQUU7QUFDekQsVUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7S0FDM0I7R0FDRjs7WUFmRyxTQUFTLEVBQVMsV0FBVzs7dUJBQTdCLFNBQVM7QUFxQmIsc0JBQWtCOzs7Ozs7YUFBQyw2QkFBRztBQUNwQixZQUFJLENBQUMsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN2RSxZQUFJLENBQUMsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN6RSxZQUFJLENBQUMsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFeEUsWUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7T0FDdEQ7Ozs7O0FBVUQscUJBQWlCOzs7Ozs7Ozs7O2FBQUMsMEJBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDMUIsWUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDOztBQUVkLGFBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDNUIsY0FBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2hELGNBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNoRCxjQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDaEQsY0FBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNoQjs7QUFFRCxlQUFPLElBQUksQ0FBQztPQUNiOzs7OztBQU9ELHlCQUFxQjs7Ozs7OzthQUFDLDhCQUFDLE1BQU0sRUFBRTtBQUM3QixjQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDbkMsaUJBQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNwQixDQUFDLENBQUM7O0FBRUgsWUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNoRCxZQUFJLGdCQUFnQixHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2QyxZQUFJLENBQUMsQ0FBQzs7QUFFTixZQUFJLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUMzQixlQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3hDLHdCQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7V0FDOUI7U0FDRjs7QUFFRCxZQUFJLGNBQWMsR0FBRyxFQUFFLENBQUM7QUFDeEIsYUFBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3hDLGNBQUksUUFBUSxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMvQixjQUFJLFNBQVMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7QUFFM0MsY0FBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FDdEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUN2QyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQ3hDLENBQUM7O0FBRUYsY0FBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQzlCLG9CQUFRLEdBQUcsQ0FBQyxRQUFRLENBQUM7V0FDdEI7O0FBRUQsd0JBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDL0I7O0FBRUQsZUFBTyxjQUFjLENBQUM7T0FDdkI7Ozs7O0FBRUQsbUJBQWU7YUFBQyx3QkFBQyxNQUFNLEVBQUU7QUFDdkIsWUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDOztBQUV6QyxZQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDO0FBQ25CLFlBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQztBQUNaLFlBQUksQ0FBQyxDQUFDOztBQUVOLGFBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3RCLFlBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDaEI7O0FBRUQsWUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDOztBQUVoQixhQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDeEIsY0FBSSxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLGNBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUM7O0FBRXZCLGVBQUssSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDckMsZ0JBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQSxJQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUEsQUFBQyxDQUFDOztBQUUxQyxnQkFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNkLGdCQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDVixnQkFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7QUFFekIsZ0JBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxBQUFDLENBQUMsR0FBQyxDQUFDLEdBQUMsQ0FBQyxJQUFNLENBQUMsQ0FBQyxHQUFDLENBQUMsR0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFBLEdBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsR0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFBLEdBQUUsRUFBRSxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQSxBQUFDLENBQUM7O0FBRWxGLGdCQUFJLENBQUMsR0FBRyxHQUFHLEVBQUU7QUFDWCxlQUFDLEdBQUcsR0FBRyxDQUFDO2FBQ1QsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDaEIsZUFBQyxHQUFHLENBQUMsQ0FBQzthQUNQOztBQUVELGtCQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7V0FDckI7U0FDRjs7QUFFRCxZQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssR0FBRyxFQUFFO0FBQ3pCLGdCQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDeEM7O0FBRUQsZUFBTyxNQUFNLENBQUM7T0FDZjs7Ozs7QUFFRCxxQkFBaUI7YUFBQywwQkFBQyxNQUFNLEVBQUU7QUFDekIsWUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztBQUN0QixZQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtBQUNyQixpQkFBTyxJQUFJLENBQUM7U0FDYjs7QUFFRCxZQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDaEIsWUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ2hCLFlBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQzs7QUFFVCxjQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDOztBQUV0QixhQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDeEIsY0FBSSxFQUFFLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUN2QixjQUFJLEVBQUUsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbkIsY0FBSSxFQUFFLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzs7QUFFdkIsZ0JBQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO0FBQzVCLGdCQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBLEdBQUksQ0FBQyxDQUFDO0FBQ25DLGdCQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBLEdBQUksQ0FBQyxDQUFDO0FBQ25DLGdCQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBLEdBQUksQ0FBQyxDQUFDO0FBQ25DLGdCQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBLElBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQSxBQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBLElBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQSxBQUFDLENBQUM7U0FDbkY7O0FBRUQsY0FBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNkLGNBQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDOztBQUVsQixjQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzs7O0FBRzFCLGFBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFF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QUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztBQUU3QyxVQUFFLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNsRSxVQUFFLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNsRSxVQUFFLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLGNBQWMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDckUsVUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxjQUFjLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDOztBQUVyRSxVQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsYUFBYSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQzNFLFVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDOzs7QUFHOUIsZ0JBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxlQUFlLEVBQUU7QUFDN0Msa0JBQVEsRUFBRTtBQUNSLDBCQUFjLEVBQUUsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFO0FBQ3hELHNCQUFVLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQzNELGtCQUFNLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFB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WUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUM7O0FBRWxELFlBQUksVUFBVSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDcEUsWUFBSSxXQUFXLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFOUMsWUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDeEMsWUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7O0FBRXBDLFlBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEtBQUssVUFBVSxFQUFFO0FBQzdDLGVBQUssQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDM0IsYUFBRyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUMxQjs7QUFFRCxZQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFBLElBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFBLEFBQUMsQ0FBQyxDQUFDOztBQUUzRCxZQUFJLGFBQWEsR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDbEMscUJBQWEsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxjQUFjLENBQUM7QUFDaEUscUJBQWEsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxjQUFjLENBQUM7O0FBRWhFLFlBQUksV0FBVyxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUUs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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBJbWdseUtpdCBmcm9tIFwiLi9zcmMvanMvaW1nbHlraXRcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbihmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luZG93LkltZ2x5S2l0ID0gSW1nbHlLaXQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gSW1nbHlLaXQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGdsb2JhbC5JbWdseUtpdCA9IEltZ2x5S2l0O1xuICB9XG59KSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciBTb21lUHJvbWlzZUFycmF5ID0gUHJvbWlzZS5fU29tZVByb21pc2VBcnJheTtcbmZ1bmN0aW9uIGFueShwcm9taXNlcykge1xuICAgIHZhciByZXQgPSBuZXcgU29tZVByb21pc2VBcnJheShwcm9taXNlcyk7XG4gICAgdmFyIHByb21pc2UgPSByZXQucHJvbWlzZSgpO1xuICAgIGlmIChwcm9taXNlLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcmV0LnNldEhvd01hbnkoMSk7XG4gICAgcmV0LnNldFVud3JhcCgpO1xuICAgIHJldC5pbml0KCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2UuYW55ID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIGFueShwcm9taXNlcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFueSh0aGlzKTtcbn07XG5cbn07XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZmlyc3RMaW5lRXJyb3I7XG50cnkge3Rocm93IG5ldyBFcnJvcigpOyB9IGNhdGNoIChlKSB7Zmlyc3RMaW5lRXJyb3IgPSBlO31cbnZhciBzY2hlZHVsZSA9IHJlcXVpcmUoXCIuL3NjaGVkdWxlLmpzXCIpO1xudmFyIFF1ZXVlID0gcmVxdWlyZShcIi4vcXVldWUuanNcIik7XG52YXIgX3Byb2Nlc3MgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiA/IHByb2Nlc3MgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIEFzeW5jKCkge1xuICAgIHRoaXMuX2lzVGlja1VzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXRlUXVldWUgPSBuZXcgUXVldWUoMTYpO1xuICAgIHRoaXMuX25vcm1hbFF1ZXVlID0gbmV3IFF1ZXVlKDE2KTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5kcmFpblF1ZXVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5fZHJhaW5RdWV1ZXMoKTtcbiAgICB9O1xuICAgIHRoaXMuX3NjaGVkdWxlID1cbiAgICAgICAgc2NoZWR1bGUuaXNTdGF0aWMgPyBzY2hlZHVsZSh0aGlzLmRyYWluUXVldWVzKSA6IHNjaGVkdWxlO1xufVxuXG5Bc3luYy5wcm90b3R5cGUuaGF2ZUl0ZW1zUXVldWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9ub3JtYWxRdWV1ZS5sZW5ndGgoKSA+IDA7XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuX3dpdGhEb21haW4gPSBmdW5jdGlvbihmbikge1xuICAgIGlmIChfcHJvY2VzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIF9wcm9jZXNzLmRvbWFpbiAhPSBudWxsICYmXG4gICAgICAgICFmbi5kb21haW4pIHtcbiAgICAgICAgZm4gPSBfcHJvY2Vzcy5kb21haW4uYmluZChmbik7XG4gICAgfVxuICAgIHJldHVybiBmbjtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS50aHJvd0xhdGVyID0gZnVuY3Rpb24oZm4sIGFyZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGFyZyA9IGZuO1xuICAgICAgICBmbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgYXJnOyB9O1xuICAgIH1cbiAgICBmbiA9IHRoaXMuX3dpdGhEb21haW4oZm4pO1xuICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4oYXJnKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfSBlbHNlIHRyeSB7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4oYXJnKTtcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhc3luYyBzY2hlZHVsZXIgYXZhaWxhYmxlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvbTNPVFhrXFx1MDAwYVwiKTtcbiAgICB9XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuaW52b2tlTGF0ZXIgPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICBmbiA9IHRoaXMuX3dpdGhEb21haW4oZm4pO1xuICAgIHRoaXMuX2xhdGVRdWV1ZS5wdXNoKGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5pbnZva2VGaXJzdCA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIGZuID0gdGhpcy5fd2l0aERvbWFpbihmbik7XG4gICAgdGhpcy5fbm9ybWFsUXVldWUudW5zaGlmdChmbiwgcmVjZWl2ZXIsIGFyZyk7XG4gICAgdGhpcy5fcXVldWVUaWNrKCk7XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgZm4gPSB0aGlzLl93aXRoRG9tYWluKGZuKTtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZS5wdXNoKGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5zZXR0bGVQcm9taXNlcyA9IGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZS5fcHVzaE9uZShwcm9taXNlKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fZHJhaW5RdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCgpID4gMCkge1xuICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZuLl9zZXR0bGVQcm9taXNlcygpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY2VpdmVyID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgdmFyIGFyZyA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLl9kcmFpblF1ZXVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9kcmFpblF1ZXVlKHRoaXMuX25vcm1hbFF1ZXVlKTtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuX2RyYWluUXVldWUodGhpcy5fbGF0ZVF1ZXVlKTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fcXVldWVUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5faXNUaWNrVXNlZCkge1xuICAgICAgICB0aGlzLl9pc1RpY2tVc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUodGhpcy5kcmFpblF1ZXVlcyk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pc1RpY2tVc2VkID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBBc3luYygpO1xubW9kdWxlLmV4cG9ydHMuZmlyc3RMaW5lRXJyb3IgPSBmaXJzdExpbmVFcnJvcjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgb2xkO1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSBvbGQgPSBQcm9taXNlO1xuZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICB0cnkgeyBpZiAoUHJvbWlzZSA9PT0gYmx1ZWJpcmQpIFByb21pc2UgPSBvbGQ7IH1cbiAgICBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gYmx1ZWJpcmQ7XG59XG52YXIgYmx1ZWJpcmQgPSByZXF1aXJlKFwiLi9wcm9taXNlLmpzXCIpKCk7XG5ibHVlYmlyZC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbm1vZHVsZS5leHBvcnRzID0gYmx1ZWJpcmQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjciA9IE9iamVjdC5jcmVhdGU7XG5pZiAoY3IpIHtcbiAgICB2YXIgY2FsbGVyQ2FjaGUgPSBjcihudWxsKTtcbiAgICB2YXIgZ2V0dGVyQ2FjaGUgPSBjcihudWxsKTtcbiAgICBjYWxsZXJDYWNoZVtcIiBzaXplXCJdID0gZ2V0dGVyQ2FjaGVbXCIgc2l6ZVwiXSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpO1xudmFyIGNhbkV2YWx1YXRlID0gdXRpbC5jYW5FdmFsdWF0ZTtcbnZhciBpc0lkZW50aWZpZXIgPSB1dGlsLmlzSWRlbnRpZmllcjtcblxuZnVuY3Rpb24gbWFrZU1ldGhvZENhbGxlciAobWV0aG9kTmFtZSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJvYmpcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAndXNlIHN0cmljdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBzd2l0Y2gobGVuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSk7ICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSwgdGhpc1sxXSk7ICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSwgdGhpc1sxXSwgdGhpc1syXSk7ICAgICAgICBcXG5cXFxuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIG9iai5tZXRob2ROYW1lLmFwcGx5KG9iaiwgdGhpcyk7ICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIi5yZXBsYWNlKC9tZXRob2ROYW1lL2csIG1ldGhvZE5hbWUpKTtcbn1cblxuZnVuY3Rpb24gbWFrZUdldHRlciAocHJvcGVydHlOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcIm9ialwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldHVybiBvYmoucHJvcGVydHlOYW1lOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiLnJlcGxhY2UoXCJwcm9wZXJ0eU5hbWVcIiwgcHJvcGVydHlOYW1lKSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBpbGVkKG5hbWUsIGNvbXBpbGVyLCBjYWNoZSkge1xuICAgIHZhciByZXQgPSBjYWNoZVtuYW1lXTtcbiAgICBpZiAodHlwZW9mIHJldCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXQgPSBjb21waWxlcihuYW1lKTtcbiAgICAgICAgY2FjaGVbbmFtZV0gPSByZXQ7XG4gICAgICAgIGNhY2hlW1wiIHNpemVcIl0rKztcbiAgICAgICAgaWYgKGNhY2hlW1wiIHNpemVcIl0gPiA1MTIpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY2FjaGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkgZGVsZXRlIGNhY2hlW2tleXNbaV1dO1xuICAgICAgICAgICAgY2FjaGVbXCIgc2l6ZVwiXSA9IGtleXMubGVuZ3RoIC0gMjU2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGdldE1ldGhvZENhbGxlcihuYW1lKSB7XG4gICAgcmV0dXJuIGdldENvbXBpbGVkKG5hbWUsIG1ha2VNZXRob2RDYWxsZXIsIGNhbGxlckNhY2hlKTtcbn1cblxuZnVuY3Rpb24gZ2V0R2V0dGVyKG5hbWUpIHtcbiAgICByZXR1cm4gZ2V0Q29tcGlsZWQobmFtZSwgbWFrZUdldHRlciwgZ2V0dGVyQ2FjaGUpO1xufVxuXG5mdW5jdGlvbiBjYWxsZXIob2JqKSB7XG4gICAgcmV0dXJuIG9ialt0aGlzLnBvcCgpXS5hcHBseShvYmosIHRoaXMpO1xufVxuUHJvbWlzZS5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgdmFyICRfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgYXJncyA9IG5ldyBBcnJheSgkX2xlbiAtIDEpOyBmb3IodmFyICRfaSA9IDE7ICRfaSA8ICRfbGVuOyArKyRfaSkge2FyZ3NbJF9pIC0gMV0gPSBhcmd1bWVudHNbJF9pXTt9XG4gICAgaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgICAgIHZhciBtYXliZUNhbGxlciA9IGdldE1ldGhvZENhbGxlcihtZXRob2ROYW1lKTtcbiAgICAgICAgaWYgKG1heWJlQ2FsbGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgICAgICBtYXliZUNhbGxlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyZ3MsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXJncy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgIHJldHVybiB0aGlzLl90aGVuKGNhbGxlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyZ3MsIHVuZGVmaW5lZCk7XG59O1xuXG5mdW5jdGlvbiBuYW1lZEdldHRlcihvYmopIHtcbiAgICByZXR1cm4gb2JqW3RoaXNdO1xufVxuZnVuY3Rpb24gaW5kZXhlZEdldHRlcihvYmopIHtcbiAgICB2YXIgaW5kZXggPSArdGhpcztcbiAgICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IE1hdGgubWF4KDAsIGluZGV4ICsgb2JqLmxlbmd0aCk7XG4gICAgcmV0dXJuIG9ialtpbmRleF07XG59XG5Qcm9taXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgdmFyIGlzSW5kZXggPSAodHlwZW9mIHByb3BlcnR5TmFtZSA9PT0gXCJudW1iZXJcIik7XG4gICAgdmFyIGdldHRlcjtcbiAgICBpZiAoIWlzSW5kZXgpIHtcbiAgICAgICAgaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgICAgICAgICB2YXIgbWF5YmVHZXR0ZXIgPSBnZXRHZXR0ZXIocHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIGdldHRlciA9IG1heWJlR2V0dGVyICE9PSBudWxsID8gbWF5YmVHZXR0ZXIgOiBuYW1lZEdldHRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldHRlciA9IG5hbWVkR2V0dGVyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0dGVyID0gaW5kZXhlZEdldHRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oZ2V0dGVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcHJvcGVydHlOYW1lLCB1bmRlZmluZWQpO1xufTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciBlcnJvcnMgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIik7XG52YXIgYXN5bmMgPSByZXF1aXJlKFwiLi9hc3luYy5qc1wiKTtcbnZhciBDYW5jZWxsYXRpb25FcnJvciA9IGVycm9ycy5DYW5jZWxsYXRpb25FcnJvcjtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NhbmNlbCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuaXNDYW5jZWxsYWJsZSgpKSByZXR1cm4gdGhpcztcbiAgICB2YXIgcGFyZW50O1xuICAgIHZhciBwcm9taXNlVG9SZWplY3QgPSB0aGlzO1xuICAgIHdoaWxlICgocGFyZW50ID0gcHJvbWlzZVRvUmVqZWN0Ll9jYW5jZWxsYXRpb25QYXJlbnQpICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgcGFyZW50LmlzQ2FuY2VsbGFibGUoKSkge1xuICAgICAgICBwcm9taXNlVG9SZWplY3QgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHRoaXMuX3Vuc2V0Q2FuY2VsbGFibGUoKTtcbiAgICB2YXIgdHJhY2UgPSBlcnJvcnMuZW5zdXJlRXJyb3JPYmplY3QocmVhc29uKTtcbiAgICBwcm9taXNlVG9SZWplY3QuX2F0dGFjaEV4dHJhVHJhY2UodHJhY2UpO1xuICAgIHByb21pc2VUb1JlamVjdC5fdGFyZ2V0KCkuX3JlamVjdFVuY2hlY2tlZChyZWFzb24sIHRyYWNlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuaXNDYW5jZWxsYWJsZSgpKSByZXR1cm4gdGhpcztcbiAgICBpZiAocmVhc29uID09PSB1bmRlZmluZWQpIHJlYXNvbiA9IG5ldyBDYW5jZWxsYXRpb25FcnJvcigpO1xuICAgIGFzeW5jLmludm9rZUxhdGVyKHRoaXMuX2NhbmNlbCwgdGhpcywgcmVhc29uKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblByb21pc2UucHJvdG90eXBlLmNhbmNlbGxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9jYW5jZWxsYWJsZSgpKSByZXR1cm4gdGhpcztcbiAgICB0aGlzLl9zZXRDYW5jZWxsYWJsZSgpO1xuICAgIHRoaXMuX2NhbmNlbGxhdGlvblBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblByb21pc2UucHJvdG90eXBlLnVuY2FuY2VsbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXQuX3Byb3BhZ2F0ZUZyb20odGhpcywgNCk7XG4gICAgcmV0Ll9mb2xsb3codGhpcyk7XG4gICAgcmV0Ll91bnNldENhbmNlbGxhYmxlKCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZvcmsgPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCBkaWRQcm9ncmVzcykge1xuICAgIHZhciByZXQgPSB0aGlzLl90aGVuKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgZGlkUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuXG4gICAgcmV0Ll9zZXRDYW5jZWxsYWJsZSgpO1xuICAgIHJldC5fY2FuY2VsbGF0aW9uUGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXQ7XG59O1xufTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG52YXIgYXN5bmMgPSByZXF1aXJlKFwiLi9hc3luYy5qc1wiKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIikuaW5oZXJpdHM7XG52YXIgYmx1ZWJpcmRGcmFtZVBhdHRlcm4gPSAvW1xcXFxcXC9dYmx1ZWJpcmRbXFxcXFxcL11qc1tcXFxcXFwvXShtYWlufGRlYnVnfHphbGdvKS87XG52YXIgc3RhY2tGcmFtZVBhdHRlcm4gPSBudWxsO1xudmFyIGZvcm1hdFN0YWNrID0gbnVsbDtcblxuZnVuY3Rpb24gQ2FwdHVyZWRUcmFjZShwYXJlbnQpIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuX2xlbmd0aCA9IDEgKyAocGFyZW50ID09PSB1bmRlZmluZWQgPyAwIDogcGFyZW50Ll9sZW5ndGgpO1xuICAgIGNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENhcHR1cmVkVHJhY2UpO1xuICAgIGlmIChsZW5ndGggPiAzMikgdGhpcy51bmN5Y2xlKCk7XG59XG5pbmhlcml0cyhDYXB0dXJlZFRyYWNlLCBFcnJvcik7XG5cbkNhcHR1cmVkVHJhY2UucHJvdG90eXBlLnVuY3ljbGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPCAyKSByZXR1cm47XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIHN0YWNrVG9JbmRleCA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIG5vZGUgPSB0aGlzOyBub2RlICE9PSB1bmRlZmluZWQ7ICsraSkge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5fcGFyZW50O1xuICAgIH1cbiAgICBsZW5ndGggPSB0aGlzLl9sZW5ndGggPSBpO1xuICAgIGZvciAodmFyIGkgPSBsZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgc3RhY2sgPSBub2Rlc1tpXS5zdGFjaztcbiAgICAgICAgaWYgKHN0YWNrVG9JbmRleFtzdGFja10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhY2tUb0luZGV4W3N0YWNrXSA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY3VycmVudFN0YWNrID0gbm9kZXNbaV0uc3RhY2s7XG4gICAgICAgIHZhciBpbmRleCA9IHN0YWNrVG9JbmRleFtjdXJyZW50U3RhY2tdO1xuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpbmRleCAhPT0gaSkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIG5vZGVzW2luZGV4IC0gMV0uX3BhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBub2Rlc1tpbmRleCAtIDFdLl9sZW5ndGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXNbaV0uX3BhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG5vZGVzW2ldLl9sZW5ndGggPSAxO1xuICAgICAgICAgICAgdmFyIGN5Y2xlRWRnZU5vZGUgPSBpID4gMCA/IG5vZGVzW2kgLSAxXSA6IHRoaXM7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9wYXJlbnQgPSBub2Rlc1tpbmRleCArIDFdO1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudC51bmN5Y2xlKCk7XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fbGVuZ3RoID1cbiAgICAgICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50Ll9sZW5ndGggKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fbGVuZ3RoID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjdXJyZW50Q2hpbGRMZW5ndGggPSBjeWNsZUVkZ2VOb2RlLl9sZW5ndGggKyAxO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgLSAyOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgICAgIG5vZGVzW2pdLl9sZW5ndGggPSBjdXJyZW50Q2hpbGRMZW5ndGg7XG4gICAgICAgICAgICAgICAgY3VycmVudENoaWxkTGVuZ3RoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5DYXB0dXJlZFRyYWNlLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xufTtcblxuQ2FwdHVyZWRUcmFjZS5wcm90b3R5cGUuaGFzUGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudCAhPT0gdW5kZWZpbmVkO1xufTtcblxuQ2FwdHVyZWRUcmFjZS5wcm90b3R5cGUuYXR0YWNoRXh0cmFUcmFjZSA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLl9fc3RhY2tDbGVhbmVkX18pIHJldHVybjtcbiAgICB0aGlzLnVuY3ljbGUoKTtcbiAgICB2YXIgdHJhY2UgPSB0aGlzO1xuICAgIHZhciBzdGFjayA9IENhcHR1cmVkVHJhY2UuY2xlYW5TdGFjayhlcnJvciwgZmFsc2UpO1xuICAgIHZhciBoZWFkZXJMaW5lQ291bnQgPSAxO1xuICAgIHZhciBjb21iaW5lZFRyYWNlcyA9IDE7XG4gICAgZG8ge1xuICAgICAgICBzdGFjayA9IHRyYWNlLmNvbWJpbmUoc3RhY2spO1xuICAgICAgICBjb21iaW5lZFRyYWNlcysrO1xuICAgIH0gd2hpbGUgKCh0cmFjZSA9IHRyYWNlLnBhcmVudCgpKSAhPSBudWxsKTtcblxuICAgIHN0YWNrID0gdW5Qcm90ZWN0TmV3bGluZXMoc3RhY2spO1xuXG4gICAgaWYgKHN0YWNrLmxlbmd0aCA8PSBoZWFkZXJMaW5lQ291bnQpIHtcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBcIihObyBzdGFjayB0cmFjZSlcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvci5zdGFjayA9IHN0YWNrLmpvaW4oXCJcXG5cIik7XG4gICAgfVxufTtcblxuQ2FwdHVyZWRUcmFjZS5wcm90b3R5cGUuY29tYmluZSA9IGZ1bmN0aW9uKGN1cnJlbnQpIHtcbiAgICB2YXIgcHJldiA9IGNsZWFuKHRoaXMuc3RhY2suc3BsaXQoXCJcXG5cIiksIDApO1xuICAgIHZhciBjdXJyZW50TGFzdEluZGV4ID0gY3VycmVudC5sZW5ndGggLSAxO1xuICAgIHZhciBjdXJyZW50TGFzdExpbmUgPSBjdXJyZW50W2N1cnJlbnRMYXN0SW5kZXhdO1xuICAgIHZhciBjb21tb25Sb290TWVldFBvaW50ID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IHByZXYubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKHByZXZbaV0gPT09IGN1cnJlbnRMYXN0TGluZSkge1xuICAgICAgICAgICAgY29tbW9uUm9vdE1lZXRQb2ludCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSBjb21tb25Sb290TWVldFBvaW50OyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgbGluZSA9IHByZXZbaV07XG4gICAgICAgIGlmIChjdXJyZW50W2N1cnJlbnRMYXN0SW5kZXhdID09PSBsaW5lKSB7XG4gICAgICAgICAgICBjdXJyZW50LnBvcCgpO1xuICAgICAgICAgICAgY3VycmVudExhc3RJbmRleC0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFtjdXJyZW50Lmxlbmd0aCAtIDFdICE9PSBcIkZyb20gcHJldmlvdXMgZXZlbnQ6XCIpIHtcbiAgICAgICAgY3VycmVudC5wdXNoKFwiRnJvbSBwcmV2aW91cyBldmVudDpcIik7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50LmNvbmNhdChwcmV2KTtcbn07XG5cbmZ1bmN0aW9uIHByb3RlY3RFcnJvck1lc3NhZ2VOZXdsaW5lcyAoc3RhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gc3RhY2tbaV07XG4gICAgICAgIGlmIChcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCIgPT09IGxpbmUgfHwgc3RhY2tGcmFtZVBhdHRlcm4udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA8PSAxKSByZXR1cm4gMTtcblxuICAgIHZhciBlcnJvck1lc3NhZ2VMaW5lcyA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaTsgKytqKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZUxpbmVzLnB1c2goc3RhY2suc2hpZnQoKSk7XG4gICAgfVxuICAgIHN0YWNrLnVuc2hpZnQoZXJyb3JNZXNzYWdlTGluZXMuam9pbihcIlxcdTAwMDJcXHUwMDAwXFx1MDAwMVwiKSk7XG4gICAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIHVuUHJvdGVjdE5ld2xpbmVzKHN0YWNrKSB7XG4gICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RhY2tbMF0gPSBzdGFja1swXS5zcGxpdChcIlxcdTAwMDJcXHUwMDAwXFx1MDAwMVwiKS5qb2luKFwiXFxuXCIpO1xuICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiRnJvbSBwcmV2aW91cyBldmVudDpcIikge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuXG5mdW5jdGlvbiBjbGVhbihzdGFjaywgaW5pdGlhbEluZGV4KSB7XG4gICAgdmFyIHJldCA9IHN0YWNrLnNsaWNlKDAsIGluaXRpYWxJbmRleCk7XG4gICAgZm9yICh2YXIgaSA9IGluaXRpYWxJbmRleDsgaSA8IHN0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gc3RhY2tbaV07XG4gICAgICAgIHZhciBpc1RyYWNlTGluZSA9IHN0YWNrRnJhbWVQYXR0ZXJuLnRlc3QobGluZSkgfHxcbiAgICAgICAgICAgIFwiICAgIChObyBzdGFjayB0cmFjZSlcIiA9PT0gbGluZTtcbiAgICAgICAgdmFyIGlzSW50ZXJuYWxGcmFtZSA9IGlzVHJhY2VMaW5lICYmIHNob3VsZElnbm9yZShsaW5lKTtcbiAgICAgICAgaWYgKGlzVHJhY2VMaW5lICYmICFpc0ludGVybmFsRnJhbWUpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbkNhcHR1cmVkVHJhY2UuY2xlYW5TdGFjayA9IGZ1bmN0aW9uKGVycm9yLCBzaG91bGRVblByb3RlY3ROZXdsaW5lcykge1xuICAgIGlmIChlcnJvci5fX3N0YWNrQ2xlYW5lZF9fKSByZXR1cm47XG4gICAgZXJyb3IuX19zdGFja0NsZWFuZWRfXyA9IHRydWU7XG4gICAgdmFyIHN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgc3RhY2sgPSB0eXBlb2Ygc3RhY2sgPT09IFwic3RyaW5nXCJcbiAgICAgICAgPyBzdGFjay5zcGxpdChcIlxcblwiKVxuICAgICAgICA6IFtlcnJvci50b1N0cmluZygpLCBcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCJdO1xuICAgIHZhciBpbml0aWFsSW5kZXggPSBwcm90ZWN0RXJyb3JNZXNzYWdlTmV3bGluZXMoc3RhY2spO1xuICAgIHN0YWNrID0gY2xlYW4oc3RhY2ssIGluaXRpYWxJbmRleCk7XG4gICAgaWYgKHNob3VsZFVuUHJvdGVjdE5ld2xpbmVzKSBzdGFjayA9IHVuUHJvdGVjdE5ld2xpbmVzKHN0YWNrKTtcbiAgICBlcnJvci5zdGFjayA9IHN0YWNrLmpvaW4oXCJcXG5cIik7XG4gICAgcmV0dXJuIHN0YWNrO1xufTtcblxuQ2FwdHVyZWRUcmFjZS5mb3JtYXRBbmRMb2dFcnJvciA9IGZ1bmN0aW9uKGVycm9yLCB0aXRsZSkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgbWVzc2FnZTtcbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgICAgICAgICBtZXNzYWdlID0gdGl0bGUgKyBmb3JtYXRTdGFjayhzdGFjaywgZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRpdGxlICsgU3RyaW5nKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUud2FybiA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS53YXJuID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnNvbGUubG9nID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5DYXB0dXJlZFRyYWNlLnVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICBDYXB0dXJlZFRyYWNlLmZvcm1hdEFuZExvZ0Vycm9yKHJlYXNvbiwgXCJeLS0tIFdpdGggYWRkaXRpb25hbCBzdGFjayB0cmFjZTogXCIpO1xufTtcblxuQ2FwdHVyZWRUcmFjZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG5DYXB0dXJlZFRyYWNlLmZpcmVSZWplY3Rpb25FdmVudCA9XG5mdW5jdGlvbihuYW1lLCBsb2NhbEhhbmRsZXIsIHJlYXNvbiwgcHJvbWlzZSkge1xuICAgIHZhciBsb2NhbEV2ZW50RmlyZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBsb2NhbEV2ZW50RmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwicmVqZWN0aW9uSGFuZGxlZFwiKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxIYW5kbGVyKHByb21pc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhbEhhbmRsZXIocmVhc29uLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICB9XG5cbiAgICB2YXIgZ2xvYmFsRXZlbnRGaXJlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGdsb2JhbEV2ZW50RmlyZWQgPSBmaXJlR2xvYmFsRXZlbnQobmFtZSwgcmVhc29uLCBwcm9taXNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGdsb2JhbEV2ZW50RmlyZWQgPSB0cnVlO1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKGUpO1xuICAgIH1cblxuICAgIGlmICghZ2xvYmFsRXZlbnRGaXJlZCAmJiAhbG9jYWxFdmVudEZpcmVkICYmXG4gICAgICAgIG5hbWUgPT09IFwidW5oYW5kbGVkUmVqZWN0aW9uXCIpIHtcbiAgICAgICAgQ2FwdHVyZWRUcmFjZS5mb3JtYXRBbmRMb2dFcnJvcihyZWFzb24sIFwiUG9zc2libHkgdW5oYW5kbGVkIFwiKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBmb3JtYXROb25FcnJvcihvYmopIHtcbiAgICB2YXIgc3RyO1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgc3RyID0gXCJbZnVuY3Rpb24gXCIgK1xuICAgICAgICAgICAgKG9iai5uYW1lIHx8IFwiYW5vbnltb3VzXCIpICtcbiAgICAgICAgICAgIFwiXVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IG9iai50b1N0cmluZygpO1xuICAgICAgICB2YXIgcnVzZWxlc3NUb1N0cmluZyA9IC9cXFtvYmplY3QgW2EtekEtWjAtOSRfXStcXF0vO1xuICAgICAgICBpZiAocnVzZWxlc3NUb1N0cmluZy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1N0ciA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgICAgICAgICAgICAgc3RyID0gbmV3U3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2goZSkge1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN0ciA9IFwiKGVtcHR5IGFycmF5KVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoXCIoPFwiICsgc25pcChzdHIpICsgXCI+LCBubyBzdGFjayB0cmFjZSlcIik7XG59XG5cbmZ1bmN0aW9uIHNuaXAoc3RyKSB7XG4gICAgdmFyIG1heENoYXJzID0gNDE7XG4gICAgaWYgKHN0ci5sZW5ndGggPCBtYXhDaGFycykge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBtYXhDaGFycyAtIDMpICsgXCIuLi5cIjtcbn1cblxudmFyIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG52YXIgcGFyc2VMaW5lSW5mb1JlZ2V4ID0gL1tcXC88XFwoXShbXjpcXC9dKyk6KFxcZCspOig/OlxcZCspXFwpP1xccyokLztcbmZ1bmN0aW9uIHBhcnNlTGluZUluZm8obGluZSkge1xuICAgIHZhciBtYXRjaGVzID0gbGluZS5tYXRjaChwYXJzZUxpbmVJbmZvUmVnZXgpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWxlTmFtZTogbWF0Y2hlc1sxXSxcbiAgICAgICAgICAgIGxpbmU6IHBhcnNlSW50KG1hdGNoZXNbMl0sIDEwKVxuICAgICAgICB9O1xuICAgIH1cbn1cbkNhcHR1cmVkVHJhY2Uuc2V0Qm91bmRzID0gZnVuY3Rpb24oZmlyc3RMaW5lRXJyb3IsIGxhc3RMaW5lRXJyb3IpIHtcbiAgICBpZiAoIUNhcHR1cmVkVHJhY2UuaXNTdXBwb3J0ZWQoKSkgcmV0dXJuO1xuICAgIHZhciBmaXJzdFN0YWNrTGluZXMgPSBmaXJzdExpbmVFcnJvci5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICB2YXIgbGFzdFN0YWNrTGluZXMgPSBsYXN0TGluZUVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBmaXJzdEluZGV4ID0gLTE7XG4gICAgdmFyIGxhc3RJbmRleCA9IC0xO1xuICAgIHZhciBmaXJzdEZpbGVOYW1lO1xuICAgIHZhciBsYXN0RmlsZU5hbWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaXJzdFN0YWNrTGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlTGluZUluZm8oZmlyc3RTdGFja0xpbmVzW2ldKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgZmlyc3RGaWxlTmFtZSA9IHJlc3VsdC5maWxlTmFtZTtcbiAgICAgICAgICAgIGZpcnN0SW5kZXggPSByZXN1bHQubGluZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdFN0YWNrTGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlTGluZUluZm8obGFzdFN0YWNrTGluZXNbaV0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBsYXN0RmlsZU5hbWUgPSByZXN1bHQuZmlsZU5hbWU7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSByZXN1bHQubGluZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmaXJzdEluZGV4IDwgMCB8fCBsYXN0SW5kZXggPCAwIHx8ICFmaXJzdEZpbGVOYW1lIHx8ICFsYXN0RmlsZU5hbWUgfHxcbiAgICAgICAgZmlyc3RGaWxlTmFtZSAhPT0gbGFzdEZpbGVOYW1lIHx8IGZpcnN0SW5kZXggPj0gbGFzdEluZGV4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIGlmIChibHVlYmlyZEZyYW1lUGF0dGVybi50ZXN0KGxpbmUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIGluZm8gPSBwYXJzZUxpbmVJbmZvKGxpbmUpO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgaWYgKGluZm8uZmlsZU5hbWUgPT09IGZpcnN0RmlsZU5hbWUgJiZcbiAgICAgICAgICAgICAgICAoZmlyc3RJbmRleCA8PSBpbmZvLmxpbmUgJiYgaW5mby5saW5lIDw9IGxhc3RJbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn07XG5cbnZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IChmdW5jdGlvbiBzdGFja0RldGVjdGlvbigpIHtcbiAgICB2YXIgdjhzdGFja0ZyYW1lUGF0dGVybiA9IC9eXFxzKmF0XFxzKi87XG4gICAgdmFyIHY4c3RhY2tGb3JtYXR0ZXIgPSBmdW5jdGlvbihzdGFjaywgZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHN0YWNrO1xuXG4gICAgICAgIGlmIChlcnJvci5uYW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yLm5hbWUgKyBcIi4gXCIgKyBlcnJvci5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXROb25FcnJvcihlcnJvcik7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuID0gdjhzdGFja0ZyYW1lUGF0dGVybjtcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICB2YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZTtcblxuICAgICAgICBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gYmx1ZWJpcmRGcmFtZVBhdHRlcm4udGVzdChsaW5lKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlY2VpdmVyLCBpZ25vcmVVbnRpbCkge1xuICAgICAgICAgICAgY2FwdHVyZVN0YWNrVHJhY2UocmVjZWl2ZXIsIGlnbm9yZVVudGlsKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuXG4gICAgaWYgKHR5cGVvZiBlcnIuc3RhY2sgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgdHlwZW9mIFwiXCIuc3RhcnRzV2l0aCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIChlcnIuc3RhY2suc3RhcnRzV2l0aChcInN0YWNrRGV0ZWN0aW9uQFwiKSkgJiZcbiAgICAgICAgc3RhY2tEZXRlY3Rpb24ubmFtZSA9PT0gXCJzdGFja0RldGVjdGlvblwiKSB7XG5cbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSAvQC87XG4gICAgICAgIHZhciBybGluZSA9IC9bQFxcbl0vO1xuXG4gICAgICAgIGZvcm1hdFN0YWNrID0gZnVuY3Rpb24oc3RhY2ssIGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YWNrID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChlcnJvci5uYW1lICsgXCIuIFwiICsgZXJyb3IubWVzc2FnZSArIFwiXFxuXCIgKyBzdGFjayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlcnJvci5uYW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IubmFtZSArIFwiLiBcIiArIGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0Tm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShvKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICAgICAgICAgIHZhciBzcGxpdCA9IHN0YWNrLnNwbGl0KHJsaW5lKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgcmV0ID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICByZXQgKz0gc3BsaXRbaV07XG4gICAgICAgICAgICAgICAgcmV0ICs9IFwiQFwiO1xuICAgICAgICAgICAgICAgIHJldCArPSBzcGxpdFtpICsgMV07XG4gICAgICAgICAgICAgICAgcmV0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvLnN0YWNrID0gcmV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBoYXNTdGFja0FmdGVyVGhyb3c7XG4gICAgdHJ5IHsgdGhyb3cgbmV3IEVycm9yKCk7IH1cbiAgICBjYXRjaChlKSB7XG4gICAgICAgIGhhc1N0YWNrQWZ0ZXJUaHJvdyA9IChcInN0YWNrXCIgaW4gZSk7XG4gICAgfVxuICAgIGlmICghKFwic3RhY2tcIiBpbiBlcnIpICYmIGhhc1N0YWNrQWZ0ZXJUaHJvdykge1xuICAgICAgICBzdGFja0ZyYW1lUGF0dGVybiA9IHY4c3RhY2tGcmFtZVBhdHRlcm47XG4gICAgICAgIGZvcm1hdFN0YWNrID0gdjhzdGFja0Zvcm1hdHRlcjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNhcHR1cmVTdGFja1RyYWNlKG8pIHtcbiAgICAgICAgICAgIHRyeSB7IHRocm93IG5ldyBFcnJvcigpOyB9XG4gICAgICAgICAgICBjYXRjaChlKSB7IG8uc3RhY2sgPSBlLnN0YWNrOyB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9ybWF0U3RhY2sgPSBmdW5jdGlvbihzdGFjaywgZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHN0YWNrO1xuXG4gICAgICAgIGlmICgodHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgZXJyb3IgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgICAgIGVycm9yLm5hbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IubmFtZSArIFwiLiBcIiArIGVycm9yLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE5vbkVycm9yKGVycm9yKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIG51bGw7XG5cbn0pKCk7XG5cbnZhciBmaXJlR2xvYmFsRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb24gPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSwgcmVhc29uLCBwcm9taXNlKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJyZWplY3Rpb25IYW5kbGVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbWl0KG5hbWUsIHByb21pc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbWl0KG5hbWUsIHJlYXNvbiwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRvV2luZG93TWV0aG9kTmFtZU1hcCA9IHt9O1xuICAgICAgICB0b1dpbmRvd01ldGhvZE5hbWVNYXBbXCJ1bmhhbmRsZWRSZWplY3Rpb25cIl0gPSAoXCJvblwiICtcbiAgICAgICAgICAgIFwidW5oYW5kbGVkUmVqZWN0aW9uXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRvV2luZG93TWV0aG9kTmFtZU1hcFtcInJlamVjdGlvbkhhbmRsZWRcIl0gPSAoXCJvblwiICtcbiAgICAgICAgICAgIFwicmVqZWN0aW9uSGFuZGxlZFwiKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCByZWFzb24sIHByb21pc2UpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gdG9XaW5kb3dNZXRob2ROYW1lTWFwW25hbWVdO1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IHdpbmRvd1ttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIGlmICghbWV0aG9kKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJyZWplY3Rpb25IYW5kbGVkXCIpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuY2FsbCh3aW5kb3csIHByb21pc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuY2FsbCh3aW5kb3csIHJlYXNvbiwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9XG59KSgpO1xuXG5yZXR1cm4gQ2FwdHVyZWRUcmFjZTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihORVhUX0ZJTFRFUikge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbnZhciB0cnlDYXRjaDEgPSB1dGlsLnRyeUNhdGNoMTtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIga2V5cyA9IHJlcXVpcmUoXCIuL2VzNS5qc1wiKS5rZXlzO1xudmFyIFR5cGVFcnJvciA9IGVycm9ycy5UeXBlRXJyb3I7XG5cbmZ1bmN0aW9uIENhdGNoRmlsdGVyKGluc3RhbmNlcywgY2FsbGJhY2ssIHByb21pc2UpIHtcbiAgICB0aGlzLl9pbnN0YW5jZXMgPSBpbnN0YW5jZXM7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLl9wcm9taXNlID0gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gc2FmZVByZWRpY2F0ZShwcmVkaWNhdGUsIGUpIHtcbiAgICB2YXIgc2FmZU9iamVjdCA9IHt9O1xuICAgIHZhciByZXRmaWx0ZXIgPSB0cnlDYXRjaDEocHJlZGljYXRlLCBzYWZlT2JqZWN0LCBlKTtcblxuICAgIGlmIChyZXRmaWx0ZXIgPT09IGVycm9yT2JqKSByZXR1cm4gcmV0ZmlsdGVyO1xuXG4gICAgdmFyIHNhZmVLZXlzID0ga2V5cyhzYWZlT2JqZWN0KTtcbiAgICBpZiAoc2FmZUtleXMubGVuZ3RoKSB7XG4gICAgICAgIGVycm9yT2JqLmUgPSBuZXcgVHlwZUVycm9yKFwiQ2F0Y2ggZmlsdGVyIG11c3QgaW5oZXJpdCBmcm9tIEVycm9yIG9yIGJlIGEgc2ltcGxlIHByZWRpY2F0ZSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL284NG82OFxcdTAwMGFcIik7XG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICB9XG4gICAgcmV0dXJuIHJldGZpbHRlcjtcbn1cblxuQ2F0Y2hGaWx0ZXIucHJvdG90eXBlLmRvRmlsdGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgY2IgPSB0aGlzLl9jYWxsYmFjaztcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2U7XG4gICAgdmFyIGJvdW5kVG8gPSBwcm9taXNlLl9ib3VuZFRvO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9pbnN0YW5jZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9pbnN0YW5jZXNbaV07XG4gICAgICAgIHZhciBpdGVtSXNFcnJvclR5cGUgPSBpdGVtID09PSBFcnJvciB8fFxuICAgICAgICAgICAgKGl0ZW0gIT0gbnVsbCAmJiBpdGVtLnByb3RvdHlwZSBpbnN0YW5jZW9mIEVycm9yKTtcblxuICAgICAgICBpZiAoaXRlbUlzRXJyb3JUeXBlICYmIGUgaW5zdGFuY2VvZiBpdGVtKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gdHJ5Q2F0Y2gxKGNiLCBib3VuZFRvLCBlKTtcbiAgICAgICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgTkVYVF9GSUxURVIuZSA9IHJldC5lO1xuICAgICAgICAgICAgICAgIHJldHVybiBORVhUX0ZJTFRFUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIiAmJiAhaXRlbUlzRXJyb3JUeXBlKSB7XG4gICAgICAgICAgICB2YXIgc2hvdWxkSGFuZGxlID0gc2FmZVByZWRpY2F0ZShpdGVtLCBlKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRIYW5kbGUgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWNlID0gZXJyb3JzLmNhbkF0dGFjaFRyYWNlKGVycm9yT2JqLmUpXG4gICAgICAgICAgICAgICAgICAgID8gZXJyb3JPYmouZVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBFcnJvcih1dGlsLnRvU3RyaW5nKGVycm9yT2JqLmUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHRyYWNlKTtcbiAgICAgICAgICAgICAgICBlID0gZXJyb3JPYmouZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoMShjYiwgYm91bmRUbywgZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgTkVYVF9GSUxURVIuZSA9IHJldC5lO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTkVYVF9GSUxURVI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgTkVYVF9GSUxURVIuZSA9IGU7XG4gICAgcmV0dXJuIE5FWFRfRklMVEVSO1xufTtcblxucmV0dXJuIENhdGNoRmlsdGVyO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpO1xudmFyIGlzUHJpbWl0aXZlID0gdXRpbC5pc1ByaW1pdGl2ZTtcbnZhciB3cmFwc1ByaW1pdGl2ZVJlY2VpdmVyID0gdXRpbC53cmFwc1ByaW1pdGl2ZVJlY2VpdmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciByZXR1cm5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbn07XG52YXIgdGhyb3dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyB0aGlzO1xufTtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAodmFsdWUsIGFjdGlvbikge1xuICAgIGlmIChhY3Rpb24gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IHZhbHVlO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSAyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuXG5Qcm9taXNlLnByb3RvdHlwZVtcInJldHVyblwiXSA9XG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHdyYXBzUHJpbWl0aXZlUmVjZWl2ZXIgJiYgaXNQcmltaXRpdmUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICAgICAgd3JhcHBlcih2YWx1ZSwgMiksXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGhlbihyZXR1cm5lciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHZhbHVlLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGVbXCJ0aHJvd1wiXSA9XG5Qcm9taXNlLnByb3RvdHlwZS50aGVuVGhyb3cgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKHdyYXBzUHJpbWl0aXZlUmVjZWl2ZXIgJiYgaXNQcmltaXRpdmUocmVhc29uKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgIHdyYXBwZXIocmVhc29uLCAxKSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZFxuICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90aGVuKHRocm93ZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCByZWFzb24sIHVuZGVmaW5lZCk7XG59O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFByb21pc2VSZWR1Y2UgPSBQcm9taXNlLnJlZHVjZTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHRoaXMsIGZuLCBudWxsLCBJTlRFUk5BTCk7XG59O1xuXG5Qcm9taXNlLmVhY2ggPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuKSB7XG4gICAgcmV0dXJuIFByb21pc2VSZWR1Y2UocHJvbWlzZXMsIGZuLCBudWxsLCBJTlRFUk5BTCk7XG59O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9iamVjdGZyZWV6ZSA9IHJlcXVpcmUoXCIuL2VzNS5qc1wiKS5mcmVlemU7XG52YXIgcHJvcGVydHlJc1dyaXRhYmxlID0gcmVxdWlyZShcIi4vZXM1LmpzXCIpLnByb3BlcnR5SXNXcml0YWJsZTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC5qc1wiKTtcbnZhciBpbmhlcml0cyA9IHV0aWwuaW5oZXJpdHM7XG52YXIgbm90RW51bWVyYWJsZVByb3AgPSB1dGlsLm5vdEVudW1lcmFibGVQcm9wO1xuXG5mdW5jdGlvbiBtYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24oZSkge1xuICAgIHRyeSB7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKGUsIFwiaXNPcGVyYXRpb25hbFwiLCB0cnVlKTtcbiAgICB9XG4gICAgY2F0Y2goaWdub3JlKSB7fVxufVxuXG5mdW5jdGlvbiBvcmlnaW5hdGVzRnJvbVJlamVjdGlvbihlKSB7XG4gICAgaWYgKGUgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAoKGUgaW5zdGFuY2VvZiBPcGVyYXRpb25hbEVycm9yKSB8fFxuICAgICAgICBlW1wiaXNPcGVyYXRpb25hbFwiXSA9PT0gdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEVycm9yO1xufVxuXG5mdW5jdGlvbiBjYW5BdHRhY2hUcmFjZShvYmopIHtcbiAgICByZXR1cm4gaXNFcnJvcihvYmopICYmIHByb3BlcnR5SXNXcml0YWJsZShvYmosIFwic3RhY2tcIik7XG59XG5cbmZ1bmN0aW9uIHN1YkVycm9yKG5hbWVQcm9wZXJ0eSwgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICBmdW5jdGlvbiBTdWJFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdWJFcnJvcikpIHJldHVybiBuZXcgU3ViRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogZGVmYXVsdE1lc3NhZ2UpO1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm5hbWVcIiwgbmFtZVByb3BlcnR5KTtcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmhlcml0cyhTdWJFcnJvciwgRXJyb3IpO1xuICAgIHJldHVybiBTdWJFcnJvcjtcbn1cblxudmFyIF9UeXBlRXJyb3IsIF9SYW5nZUVycm9yO1xudmFyIENhbmNlbGxhdGlvbkVycm9yID0gc3ViRXJyb3IoXCJDYW5jZWxsYXRpb25FcnJvclwiLCBcImNhbmNlbGxhdGlvbiBlcnJvclwiKTtcbnZhciBUaW1lb3V0RXJyb3IgPSBzdWJFcnJvcihcIlRpbWVvdXRFcnJvclwiLCBcInRpbWVvdXQgZXJyb3JcIik7XG52YXIgQWdncmVnYXRlRXJyb3IgPSBzdWJFcnJvcihcIkFnZ3JlZ2F0ZUVycm9yXCIsIFwiYWdncmVnYXRlIGVycm9yXCIpO1xudHJ5IHtcbiAgICBfVHlwZUVycm9yID0gVHlwZUVycm9yO1xuICAgIF9SYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcbn0gY2F0Y2goZSkge1xuICAgIF9UeXBlRXJyb3IgPSBzdWJFcnJvcihcIlR5cGVFcnJvclwiLCBcInR5cGUgZXJyb3JcIik7XG4gICAgX1JhbmdlRXJyb3IgPSBzdWJFcnJvcihcIlJhbmdlRXJyb3JcIiwgXCJyYW5nZSBlcnJvclwiKTtcbn1cblxudmFyIG1ldGhvZHMgPSAoXCJqb2luIHBvcCBwdXNoIHNoaWZ0IHVuc2hpZnQgc2xpY2UgZmlsdGVyIGZvckVhY2ggc29tZSBcIiArXG4gICAgXCJldmVyeSBtYXAgaW5kZXhPZiBsYXN0SW5kZXhPZiByZWR1Y2UgcmVkdWNlUmlnaHQgc29ydCByZXZlcnNlXCIpLnNwbGl0KFwiIFwiKTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiBBcnJheS5wcm90b3R5cGVbbWV0aG9kc1tpXV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBBZ2dyZWdhdGVFcnJvci5wcm90b3R5cGVbbWV0aG9kc1tpXV0gPSBBcnJheS5wcm90b3R5cGVbbWV0aG9kc1tpXV07XG4gICAgfVxufVxuXG5BZ2dyZWdhdGVFcnJvci5wcm90b3R5cGUubGVuZ3RoID0gMDtcbkFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZVtcImlzT3BlcmF0aW9uYWxcIl0gPSB0cnVlO1xudmFyIGxldmVsID0gMDtcbkFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmRlbnQgPSBBcnJheShsZXZlbCAqIDQgKyAxKS5qb2luKFwiIFwiKTtcbiAgICB2YXIgcmV0ID0gXCJcXG5cIiArIGluZGVudCArIFwiQWdncmVnYXRlRXJyb3Igb2Y6XCIgKyBcIlxcblwiO1xuICAgIGxldmVsKys7XG4gICAgaW5kZW50ID0gQXJyYXkobGV2ZWwgKiA0ICsgMSkuam9pbihcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzdHIgPSB0aGlzW2ldID09PSB0aGlzID8gXCJbQ2lyY3VsYXIgQWdncmVnYXRlRXJyb3JdXCIgOiB0aGlzW2ldICsgXCJcIjtcbiAgICAgICAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBsaW5lc1tqXSA9IGluZGVudCArIGxpbmVzW2pdO1xuICAgICAgICB9XG4gICAgICAgIHN0ciA9IGxpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIHJldCArPSBzdHIgKyBcIlxcblwiO1xuICAgIH1cbiAgICBsZXZlbC0tO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBPcGVyYXRpb25hbEVycm9yKG1lc3NhZ2UpIHtcbiAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm5hbWVcIiwgXCJPcGVyYXRpb25hbEVycm9yXCIpO1xuICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibWVzc2FnZVwiLCBtZXNzYWdlKTtcbiAgICB0aGlzLmNhdXNlID0gbWVzc2FnZTtcbiAgICB0aGlzW1wiaXNPcGVyYXRpb25hbFwiXSA9IHRydWU7XG5cbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibWVzc2FnZVwiLCBtZXNzYWdlLm1lc3NhZ2UpO1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcInN0YWNrXCIsIG1lc3NhZ2Uuc3RhY2spO1xuICAgIH0gZWxzZSBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG59XG5pbmhlcml0cyhPcGVyYXRpb25hbEVycm9yLCBFcnJvcik7XG5cbnZhciBrZXkgPSBcIl9fQmx1ZWJpcmRFcnJvclR5cGVzX19cIjtcbnZhciBlcnJvclR5cGVzID0gRXJyb3Jba2V5XTtcbmlmICghZXJyb3JUeXBlcykge1xuICAgIGVycm9yVHlwZXMgPSBPYmplY3RmcmVlemUoe1xuICAgICAgICBDYW5jZWxsYXRpb25FcnJvcjogQ2FuY2VsbGF0aW9uRXJyb3IsXG4gICAgICAgIFRpbWVvdXRFcnJvcjogVGltZW91dEVycm9yLFxuICAgICAgICBPcGVyYXRpb25hbEVycm9yOiBPcGVyYXRpb25hbEVycm9yLFxuICAgICAgICBSZWplY3Rpb25FcnJvcjogT3BlcmF0aW9uYWxFcnJvcixcbiAgICAgICAgQWdncmVnYXRlRXJyb3I6IEFnZ3JlZ2F0ZUVycm9yXG4gICAgfSk7XG4gICAgbm90RW51bWVyYWJsZVByb3AoRXJyb3IsIGtleSwgZXJyb3JUeXBlcyk7XG59XG5cbnZhciBlbnN1cmVFcnJvck9iamVjdCA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAoIShcInN0YWNrXCIgaW4gbmV3IEVycm9yKCkpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGNhbkF0dGFjaFRyYWNlKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHt0aHJvdyBuZXcgRXJyb3IodXRpbC50b1N0cmluZyh2YWx1ZSkpO31cbiAgICAgICAgICAgIGNhdGNoKGVycikge3JldHVybiBlcnI7fVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGNhbkF0dGFjaFRyYWNlKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcih1dGlsLnRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH07XG4gICAgfVxufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRXJyb3I6IEVycm9yLFxuICAgIFR5cGVFcnJvcjogX1R5cGVFcnJvcixcbiAgICBSYW5nZUVycm9yOiBfUmFuZ2VFcnJvcixcbiAgICBDYW5jZWxsYXRpb25FcnJvcjogZXJyb3JUeXBlcy5DYW5jZWxsYXRpb25FcnJvcixcbiAgICBPcGVyYXRpb25hbEVycm9yOiBlcnJvclR5cGVzLk9wZXJhdGlvbmFsRXJyb3IsXG4gICAgVGltZW91dEVycm9yOiBlcnJvclR5cGVzLlRpbWVvdXRFcnJvcixcbiAgICBBZ2dyZWdhdGVFcnJvcjogZXJyb3JUeXBlcy5BZ2dyZWdhdGVFcnJvcixcbiAgICBvcmlnaW5hdGVzRnJvbVJlamVjdGlvbjogb3JpZ2luYXRlc0Zyb21SZWplY3Rpb24sXG4gICAgbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uOiBtYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24sXG4gICAgY2FuQXR0YWNoVHJhY2U6IGNhbkF0dGFjaFRyYWNlLFxuICAgIGVuc3VyZUVycm9yT2JqZWN0OiBlbnN1cmVFcnJvck9iamVjdFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgVHlwZUVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLlR5cGVFcnJvcjtcblxuZnVuY3Rpb24gYXBpUmVqZWN0aW9uKG1zZykge1xuICAgIHZhciBlcnJvciA9IG5ldyBUeXBlRXJyb3IobXNnKTtcbiAgICB2YXIgcmV0ID0gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIHZhciBwYXJlbnQgPSByZXQuX3BlZWtDb250ZXh0KCk7XG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudC5hdHRhY2hFeHRyYVRyYWNlKGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxucmV0dXJuIGFwaVJlamVjdGlvbjtcbn07XG4iLCJ2YXIgaXNFUzUgPSAoZnVuY3Rpb24oKXtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcyA9PT0gdW5kZWZpbmVkO1xufSkoKTtcblxuaWYgKGlzRVM1KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGZyZWV6ZTogT2JqZWN0LmZyZWV6ZSxcbiAgICAgICAgZGVmaW5lUHJvcGVydHk6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAga2V5czogT2JqZWN0LmtleXMsXG4gICAgICAgIGdldFByb3RvdHlwZU9mOiBPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gICAgICAgIGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXG4gICAgICAgIGlzRVM1OiBpc0VTNSxcbiAgICAgICAgcHJvcGVydHlJc1dyaXRhYmxlOiBmdW5jdGlvbihvYmosIHByb3ApIHtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApO1xuICAgICAgICAgICAgcmV0dXJuICEhKCFkZXNjcmlwdG9yIHx8IGRlc2NyaXB0b3Iud3JpdGFibGUgfHwgZGVzY3JpcHRvci5zZXQpO1xuICAgICAgICB9XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgdmFyIGhhcyA9IHt9Lmhhc093blByb3BlcnR5O1xuICAgIHZhciBzdHIgPSB7fS50b1N0cmluZztcbiAgICB2YXIgcHJvdG8gPSB7fS5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgICB2YXIgT2JqZWN0S2V5cyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG8pIHtcbiAgICAgICAgICAgIGlmIChoYXMuY2FsbChvLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICB2YXIgT2JqZWN0RGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAobywga2V5LCBkZXNjKSB7XG4gICAgICAgIG9ba2V5XSA9IGRlc2MudmFsdWU7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG5cbiAgICB2YXIgT2JqZWN0RnJlZXplID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICB2YXIgT2JqZWN0R2V0UHJvdG90eXBlT2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0KG9iaikuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvdG87XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIEFycmF5SXNBcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBpc0FycmF5OiBBcnJheUlzQXJyYXksXG4gICAgICAgIGtleXM6IE9iamVjdEtleXMsXG4gICAgICAgIGRlZmluZVByb3BlcnR5OiBPYmplY3REZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgZnJlZXplOiBPYmplY3RGcmVlemUsXG4gICAgICAgIGdldFByb3RvdHlwZU9mOiBPYmplY3RHZXRQcm90b3R5cGVPZixcbiAgICAgICAgaXNFUzU6IGlzRVM1LFxuICAgICAgICBwcm9wZXJ0eUlzV3JpdGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgUHJvbWlzZU1hcCA9IFByb21pc2UubWFwO1xuXG5Qcm9taXNlLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUHJvbWlzZU1hcCh0aGlzLCBmbiwgb3B0aW9ucywgSU5URVJOQUwpO1xufTtcblxuUHJvbWlzZS5maWx0ZXIgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFByb21pc2VNYXAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBJTlRFUk5BTCk7XG59O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBORVhUX0ZJTFRFUiwgdHJ5Q29udmVydFRvUHJvbWlzZSkge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpO1xudmFyIHdyYXBzUHJpbWl0aXZlUmVjZWl2ZXIgPSB1dGlsLndyYXBzUHJpbWl0aXZlUmVjZWl2ZXI7XG52YXIgaXNQcmltaXRpdmUgPSB1dGlsLmlzUHJpbWl0aXZlO1xudmFyIHRocm93ZXIgPSB1dGlsLnRocm93ZXI7XG5cbmZ1bmN0aW9uIHJldHVyblRoaXMoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiB0aHJvd1RoaXMoKSB7XG4gICAgdGhyb3cgdGhpcztcbn1cbmZ1bmN0aW9uIHJldHVybiQocikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRocm93JChyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyByO1xuICAgIH07XG59XG5mdW5jdGlvbiBwcm9taXNlZEZpbmFsbHkocmV0LCByZWFzb25PclZhbHVlLCBpc0Z1bGZpbGxlZCkge1xuICAgIHZhciB0aGVuO1xuICAgIGlmICh3cmFwc1ByaW1pdGl2ZVJlY2VpdmVyICYmIGlzUHJpbWl0aXZlKHJlYXNvbk9yVmFsdWUpKSB7XG4gICAgICAgIHRoZW4gPSBpc0Z1bGZpbGxlZCA/IHJldHVybiQocmVhc29uT3JWYWx1ZSkgOiB0aHJvdyQocmVhc29uT3JWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhlbiA9IGlzRnVsZmlsbGVkID8gcmV0dXJuVGhpcyA6IHRocm93VGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHJldC5fdGhlbih0aGVuLCB0aHJvd2VyLCB1bmRlZmluZWQsIHJlYXNvbk9yVmFsdWUsIHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIGZpbmFsbHlIYW5kbGVyKHJlYXNvbk9yVmFsdWUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcbiAgICB2YXIgaGFuZGxlciA9IHRoaXMuaGFuZGxlcjtcblxuICAgIHZhciByZXQgPSBwcm9taXNlLl9pc0JvdW5kKClcbiAgICAgICAgICAgICAgICAgICAgPyBoYW5kbGVyLmNhbGwocHJvbWlzZS5fYm91bmRUbylcbiAgICAgICAgICAgICAgICAgICAgOiBoYW5kbGVyKCk7XG5cbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmV0LCB1bmRlZmluZWQpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlZEZpbmFsbHkobWF5YmVQcm9taXNlLCByZWFzb25PclZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5pc0Z1bGZpbGxlZCgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9taXNlLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICBORVhUX0ZJTFRFUi5lID0gcmVhc29uT3JWYWx1ZTtcbiAgICAgICAgcmV0dXJuIE5FWFRfRklMVEVSO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZWFzb25PclZhbHVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdGFwSGFuZGxlcih2YWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuICAgIHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyO1xuXG4gICAgdmFyIHJldCA9IHByb21pc2UuX2lzQm91bmQoKVxuICAgICAgICAgICAgICAgICAgICA/IGhhbmRsZXIuY2FsbChwcm9taXNlLl9ib3VuZFRvLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgOiBoYW5kbGVyKHZhbHVlKTtcblxuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShyZXQsIHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VkRmluYWxseShtYXliZVByb21pc2UsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cblByb21pc2UucHJvdG90eXBlLl9wYXNzVGhyb3VnaEhhbmRsZXIgPSBmdW5jdGlvbiAoaGFuZGxlciwgaXNGaW5hbGx5KSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0aGlzLnRoZW4oKTtcblxuICAgIHZhciBwcm9taXNlQW5kSGFuZGxlciA9IHtcbiAgICAgICAgcHJvbWlzZTogdGhpcyxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgIGlzRmluYWxseSA/IGZpbmFsbHlIYW5kbGVyIDogdGFwSGFuZGxlcixcbiAgICAgICAgICAgIGlzRmluYWxseSA/IGZpbmFsbHlIYW5kbGVyIDogdW5kZWZpbmVkLCB1bmRlZmluZWQsXG4gICAgICAgICAgICBwcm9taXNlQW5kSGFuZGxlciwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmxhc3RseSA9XG5Qcm9taXNlLnByb3RvdHlwZVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaEhhbmRsZXIoaGFuZGxlciwgdHJ1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaEhhbmRsZXIoaGFuZGxlciwgZmFsc2UpO1xufTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVqZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSkge1xudmFyIGVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbnZhciBUeXBlRXJyb3IgPSBlcnJvcnMuVHlwZUVycm9yO1xudmFyIGRlcHJlY2F0ZWQgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpLmRlcHJlY2F0ZWQ7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIik7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIHRyeUNhdGNoMSA9IHV0aWwudHJ5Q2F0Y2gxO1xudmFyIHlpZWxkSGFuZGxlcnMgPSBbXTtcblxuZnVuY3Rpb24gcHJvbWlzZUZyb21ZaWVsZEhhbmRsZXIodmFsdWUsIHlpZWxkSGFuZGxlcnMsIHRyYWNlUGFyZW50KSB7XG4gICAgdmFyIF9lcnJvck9iaiA9IGVycm9yT2JqO1xuICAgIHZhciBfUHJvbWlzZSA9IFByb21pc2U7XG4gICAgdmFyIGxlbiA9IHlpZWxkSGFuZGxlcnMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdHJhY2VQYXJlbnQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaDEoeWllbGRIYW5kbGVyc1tpXSwgdW5kZWZpbmVkLCB2YWx1ZSk7XG4gICAgICAgIHRyYWNlUGFyZW50Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IF9lcnJvck9iaikge1xuICAgICAgICAgICAgcmV0dXJuIF9Qcm9taXNlLnJlamVjdChfZXJyb3JPYmouZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmVzdWx0LCB0cmFjZVBhcmVudCk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBfUHJvbWlzZSkgcmV0dXJuIG1heWJlUHJvbWlzZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb21pc2VTcGF3bihnZW5lcmF0b3JGdW5jdGlvbiwgcmVjZWl2ZXIsIHlpZWxkSGFuZGxlciwgc3RhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB0aGlzLl9zdGFjayA9IHN0YWNrO1xuICAgIHRoaXMuX2dlbmVyYXRvckZ1bmN0aW9uID0gZ2VuZXJhdG9yRnVuY3Rpb247XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICB0aGlzLl9nZW5lcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5feWllbGRIYW5kbGVycyA9IHR5cGVvZiB5aWVsZEhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IFt5aWVsZEhhbmRsZXJdLmNvbmNhdCh5aWVsZEhhbmRsZXJzKVxuICAgICAgICA6IHlpZWxkSGFuZGxlcnM7XG59XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3J1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9nZW5lcmF0b3IgPSB0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbi5jYWxsKHRoaXMuX3JlY2VpdmVyKTtcbiAgICB0aGlzLl9yZWNlaXZlciA9XG4gICAgICAgIHRoaXMuX2dlbmVyYXRvckZ1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX25leHQodW5kZWZpbmVkKTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX2NvbnRpbnVlID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHRoaXMuX2dlbmVyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHRyYWNlID0gZXJyb3JzLmNhbkF0dGFjaFRyYWNlKHJlc3VsdC5lKVxuICAgICAgICAgICAgPyByZXN1bHQuZSA6IG5ldyBFcnJvcih1dGlsLnRvU3RyaW5nKHJlc3VsdC5lKSk7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UodHJhY2UpO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9yZWplY3QocmVzdWx0LmUsIHRyYWNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICBpZiAocmVzdWx0LmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fZ2VuZXJhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIXRoaXMuX3Byb21pc2UuX3RyeUZvbGxvdyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb21pc2UuX2Z1bGZpbGwodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodmFsdWUsIHRoaXMuX3Byb21pc2UpO1xuICAgICAgICBpZiAoIShtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlID1cbiAgICAgICAgICAgICAgICBwcm9taXNlRnJvbVlpZWxkSGFuZGxlcihtYXliZVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5feWllbGRIYW5kbGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvdyhcbiAgICAgICAgICAgICAgICAgICAgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQSB2YWx1ZSAlcyB3YXMgeWllbGRlZCB0aGF0IGNvdWxkIG5vdCBiZSB0cmVhdGVkIGFzIGEgcHJvbWlzZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzRZNHBEa1xcdTAwMGFcXHUwMDBhXCIucmVwbGFjZShcIiVzXCIsIHZhbHVlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkZyb20gY29yb3V0aW5lOlxcdTAwMGFcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgxLCAtNykuam9pbihcIlxcblwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKFxuICAgICAgICAgICAgdGhpcy5fbmV4dCxcbiAgICAgICAgICAgIHRoaXMuX3Rocm93LFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICApO1xuICAgIH1cbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Rocm93ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmIChlcnJvcnMuY2FuQXR0YWNoVHJhY2UocmVhc29uKSlcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoMSh0aGlzLl9nZW5lcmF0b3JbXCJ0aHJvd1wiXSwgdGhpcy5fZ2VuZXJhdG9yLCByZWFzb24pO1xuICAgIHRoaXMuX3Byb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICB0aGlzLl9jb250aW51ZShyZXN1bHQpO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoMSh0aGlzLl9nZW5lcmF0b3IubmV4dCwgdGhpcy5fZ2VuZXJhdG9yLCB2YWx1ZSk7XG4gICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIHRoaXMuX2NvbnRpbnVlKHJlc3VsdCk7XG59O1xuXG5Qcm9taXNlLmNvcm91dGluZSA9IGZ1bmN0aW9uIChnZW5lcmF0b3JGdW5jdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZ2VuZXJhdG9yRnVuY3Rpb24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZ2VuZXJhdG9yRnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvNlZxaG0wXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdmFyIHlpZWxkSGFuZGxlciA9IE9iamVjdChvcHRpb25zKS55aWVsZEhhbmRsZXI7XG4gICAgdmFyIFByb21pc2VTcGF3biQgPSBQcm9taXNlU3Bhd247XG4gICAgdmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IGdlbmVyYXRvckZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBzcGF3biA9IG5ldyBQcm9taXNlU3Bhd24kKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB5aWVsZEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrKTtcbiAgICAgICAgc3Bhd24uX2dlbmVyYXRvciA9IGdlbmVyYXRvcjtcbiAgICAgICAgc3Bhd24uX25leHQodW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHNwYXduLnByb21pc2UoKTtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5jb3JvdXRpbmUuYWRkWWllbGRIYW5kbGVyID0gZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJmbiBtdXN0IGJlIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC85MTZsSkpcXHUwMDBhXCIpO1xuICAgIHlpZWxkSGFuZGxlcnMucHVzaChmbik7XG59O1xuXG5Qcm9taXNlLnNwYXduID0gZnVuY3Rpb24gKGdlbmVyYXRvckZ1bmN0aW9uKSB7XG4gICAgZGVwcmVjYXRlZChcIlByb21pc2Uuc3Bhd24gaXMgZGVwcmVjYXRlZC4gVXNlIFByb21pc2UuY29yb3V0aW5lIGluc3RlYWQuXCIpO1xuICAgIGlmICh0eXBlb2YgZ2VuZXJhdG9yRnVuY3Rpb24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZ2VuZXJhdG9yRnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvNlZxaG0wXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdmFyIHNwYXduID0gbmV3IFByb21pc2VTcGF3bihnZW5lcmF0b3JGdW5jdGlvbiwgdGhpcyk7XG4gICAgdmFyIHJldCA9IHNwYXduLnByb21pc2UoKTtcbiAgICBzcGF3bi5fcnVuKFByb21pc2Uuc3Bhd24pO1xuICAgIHJldHVybiByZXQ7XG59O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5LCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpO1xudmFyIGNhbkV2YWx1YXRlID0gdXRpbC5jYW5FdmFsdWF0ZTtcbnZhciB0cnlDYXRjaDEgPSB1dGlsLnRyeUNhdGNoMTtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgZXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpO1xuXG5pZiAoY2FuRXZhbHVhdGUpIHtcbiAgICB2YXIgdGhlbkNhbGxiYWNrID0gZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwidmFsdWVcIiwgXCJob2xkZXJcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBob2xkZXIucEluZGV4ID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBob2xkZXIuY2hlY2tGdWxmaWxsbWVudCh0aGlzKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIi5yZXBsYWNlKC9JbmRleC9nLCBpKSk7XG4gICAgfTtcblxuICAgIHZhciBjYWxsZXIgPSBmdW5jdGlvbihjb3VudCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGNvdW50OyArK2kpIHZhbHVlcy5wdXNoKFwiaG9sZGVyLnBcIiArIGkpO1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiaG9sZGVyXCIsIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gaG9sZGVyLmZuOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlcyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCIucmVwbGFjZSgvdmFsdWVzL2csIHZhbHVlcy5qb2luKFwiLCBcIikpKTtcbiAgICB9O1xuICAgIHZhciB0aGVuQ2FsbGJhY2tzID0gW107XG4gICAgdmFyIGNhbGxlcnMgPSBbdW5kZWZpbmVkXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSA1OyArK2kpIHtcbiAgICAgICAgdGhlbkNhbGxiYWNrcy5wdXNoKHRoZW5DYWxsYmFjayhpKSk7XG4gICAgICAgIGNhbGxlcnMucHVzaChjYWxsZXIoaSkpO1xuICAgIH1cblxuICAgIHZhciBIb2xkZXIgPSBmdW5jdGlvbih0b3RhbCwgZm4pIHtcbiAgICAgICAgdGhpcy5wMSA9IHRoaXMucDIgPSB0aGlzLnAzID0gdGhpcy5wNCA9IHRoaXMucDUgPSBudWxsO1xuICAgICAgICB0aGlzLmZuID0gZm47XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5ub3cgPSAwO1xuICAgIH07XG5cbiAgICBIb2xkZXIucHJvdG90eXBlLmNhbGxlcnMgPSBjYWxsZXJzO1xuICAgIEhvbGRlci5wcm90b3R5cGUuY2hlY2tGdWxmaWxsbWVudCA9IGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93O1xuICAgICAgICBub3crKztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy50b3RhbDtcbiAgICAgICAgaWYgKG5vdyA+PSB0b3RhbCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLmNhbGxlcnNbdG90YWxdO1xuICAgICAgICAgICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgICAgIHZhciByZXQgPSB0cnlDYXRjaDEoaGFuZGxlciwgdW5kZWZpbmVkLCB0aGlzKTtcbiAgICAgICAgICAgIHByb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHJldC5lO1xuICAgICAgICAgICAgICAgIHZhciB0cmFjZSA9IGVycm9ycy5lbnN1cmVFcnJvck9iamVjdChyZWFzb24pO1xuICAgICAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UodHJhY2UpO1xuICAgICAgICAgICAgICAgIHByb21pc2UuX3JlamVjdFVuY2hlY2tlZChyZWFzb24sXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlID09PSByZWFzb24gPyB1bmRlZmluZWQgOiB0cmFjZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFwcm9taXNlLl90cnlGb2xsb3cocmV0KSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGxVbmNoZWNrZWQocmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubm93ID0gbm93O1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgIHRoaXMuX3JlamVjdChyZWFzb24pO1xufVxuXG5Qcm9taXNlLmpvaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhc3QgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgZm47XG4gICAgaWYgKGxhc3QgPiAwICYmIHR5cGVvZiBhcmd1bWVudHNbbGFzdF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBmbiA9IGFyZ3VtZW50c1tsYXN0XTtcbiAgICAgICAgaWYgKGxhc3QgPCA2ICYmIGNhbkV2YWx1YXRlKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgdmFyIGhvbGRlciA9IG5ldyBIb2xkZXIobGFzdCwgZm4pO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoZW5DYWxsYmFja3M7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3Q7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKGFyZ3VtZW50c1tpXSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlLl9pc1BlbmRpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKGNhbGxiYWNrc1tpXSwgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgcmV0LCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1heWJlUHJvbWlzZS5faXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwocmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl92YWx1ZSgpLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9yZWplY3QobWF5YmVQcm9taXNlLl9yZWFzb24oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHJldCwgbWF5YmVQcm9taXNlLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyICRfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgYXJncyA9IG5ldyBBcnJheSgkX2xlbik7IGZvcih2YXIgJF9pID0gMDsgJF9pIDwgJF9sZW47ICsrJF9pKSB7YXJnc1skX2ldID0gYXJndW1lbnRzWyRfaV07fVxuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZUFycmF5KGFyZ3MpLnByb21pc2UoKTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IHJldC5zcHJlYWQoZm4pIDogcmV0O1xufTtcblxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlQXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlamVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSU5URVJOQUwpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC5qc1wiKTtcbnZhciB0cnlDYXRjaDMgPSB1dGlsLnRyeUNhdGNoMztcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgUEVORElORyA9IHt9O1xudmFyIEVNUFRZX0FSUkFZID0gW107XG5cbmZ1bmN0aW9uIE1hcHBpbmdQcm9taXNlQXJyYXkocHJvbWlzZXMsIGZuLCBsaW1pdCwgX2ZpbHRlcikge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHByb21pc2VzKTtcbiAgICB0aGlzLl9wcm9taXNlLl9zZXRJc1NwcmVhZGFibGUoKTtcbiAgICB0aGlzLl9wcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gZm47XG4gICAgdGhpcy5fcHJlc2VydmVkVmFsdWVzID0gX2ZpbHRlciA9PT0gSU5URVJOQUxcbiAgICAgICAgPyBuZXcgQXJyYXkodGhpcy5sZW5ndGgoKSlcbiAgICAgICAgOiBudWxsO1xuICAgIHRoaXMuX2xpbWl0ID0gbGltaXQ7XG4gICAgdGhpcy5faW5GbGlnaHQgPSAwO1xuICAgIHRoaXMuX3F1ZXVlID0gbGltaXQgPj0gMSA/IFtdIDogRU1QVFlfQVJSQVk7XG4gICAgdGhpcy5faW5pdCQodW5kZWZpbmVkLCAtMik7XG59XG51dGlsLmluaGVyaXRzKE1hcHBpbmdQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge307XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgdmFyIHByZXNlcnZlZFZhbHVlcyA9IHRoaXMuX3ByZXNlcnZlZFZhbHVlcztcbiAgICB2YXIgbGltaXQgPSB0aGlzLl9saW1pdDtcbiAgICBpZiAodmFsdWVzW2luZGV4XSA9PT0gUEVORElORykge1xuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIGlmIChsaW1pdCA+PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9pbkZsaWdodC0tO1xuICAgICAgICAgICAgdGhpcy5fZHJhaW5RdWV1ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxpbWl0ID49IDEgJiYgdGhpcy5faW5GbGlnaHQgPj0gbGltaXQpIHtcbiAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVzZXJ2ZWRWYWx1ZXMgIT09IG51bGwpIHByZXNlcnZlZFZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjaztcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcHJvbWlzZS5fYm91bmRUbztcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoMyhjYWxsYmFjaywgcmVjZWl2ZXIsIHZhbHVlLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgICAgICBpZiAocmV0ID09PSBlcnJvck9iaikgcmV0dXJuIHRoaXMuX3JlamVjdChyZXQuZSk7XG5cbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmV0LCB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlLl9pc1BlbmRpbmcoKSkge1xuICAgICAgICAgICAgICAgIGlmIChsaW1pdCA+PSAxKSB0aGlzLl9pbkZsaWdodCsrO1xuICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSBQRU5ESU5HO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXliZVByb21pc2UuX3Byb3h5UHJvbWlzZUFycmF5KHRoaXMsIGluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF5YmVQcm9taXNlLl9pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbWF5YmVQcm9taXNlLl92YWx1ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0KG1heWJlUHJvbWlzZS5fcmVhc29uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSByZXQ7XG4gICAgfVxuICAgIHZhciB0b3RhbFJlc29sdmVkID0gKyt0aGlzLl90b3RhbFJlc29sdmVkO1xuICAgIGlmICh0b3RhbFJlc29sdmVkID49IGxlbmd0aCkge1xuICAgICAgICBpZiAocHJlc2VydmVkVmFsdWVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXIodmFsdWVzLCBwcmVzZXJ2ZWRWYWx1ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICB9XG59O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZHJhaW5RdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcXVldWUgPSB0aGlzLl9xdWV1ZTtcbiAgICB2YXIgbGltaXQgPSB0aGlzLl9saW1pdDtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5fdmFsdWVzO1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwICYmIHRoaXMuX2luRmxpZ2h0IDwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSkgcmV0dXJuO1xuICAgICAgICB2YXIgaW5kZXggPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZCh2YWx1ZXNbaW5kZXhdLCBpbmRleCk7XG4gICAgfVxufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2ZpbHRlciA9IGZ1bmN0aW9uIChib29sZWFucywgdmFsdWVzKSB7XG4gICAgdmFyIGxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShsZW4pO1xuICAgIHZhciBqID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmIChib29sZWFuc1tpXSkgcmV0W2orK10gPSB2YWx1ZXNbaV07XG4gICAgfVxuICAgIHJldC5sZW5ndGggPSBqO1xuICAgIHRoaXMuX3Jlc29sdmUocmV0KTtcbn07XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLnByZXNlcnZlZFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlc2VydmVkVmFsdWVzO1xufTtcblxuZnVuY3Rpb24gbWFwKHByb21pc2VzLCBmbiwgb3B0aW9ucywgX2ZpbHRlcikge1xuICAgIHZhciBsaW1pdCA9IHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMgIT09IG51bGxcbiAgICAgICAgPyBvcHRpb25zLmNvbmN1cnJlbmN5XG4gICAgICAgIDogMDtcbiAgICBsaW1pdCA9IHR5cGVvZiBsaW1pdCA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICBpc0Zpbml0ZShsaW1pdCkgJiYgbGltaXQgPj0gMSA/IGxpbWl0IDogMDtcbiAgICByZXR1cm4gbmV3IE1hcHBpbmdQcm9taXNlQXJyYXkocHJvbWlzZXMsIGZuLCBsaW1pdCwgX2ZpbHRlcik7XG59XG5cblByb21pc2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGFwaVJlamVjdGlvbihcImZuIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzkxNmxKSlxcdTAwMGFcIik7XG5cbiAgICByZXR1cm4gbWFwKHRoaXMsIGZuLCBvcHRpb25zLCBudWxsKS5wcm9taXNlKCk7XG59O1xuXG5Qcm9taXNlLm1hcCA9IGZ1bmN0aW9uIChwcm9taXNlcywgZm4sIG9wdGlvbnMsIF9maWx0ZXIpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBhcGlSZWplY3Rpb24oXCJmbiBtdXN0IGJlIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC85MTZsSkpcXHUwMDBhXCIpO1xuICAgIHJldHVybiBtYXAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBfZmlsdGVyKS5wcm9taXNlKCk7XG59O1xuXG5cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpO1xudmFyIGFzeW5jID0gcmVxdWlyZShcIi4vYXN5bmMuanNcIik7XG52YXIgdHJ5Q2F0Y2gyID0gdXRpbC50cnlDYXRjaDI7XG52YXIgdHJ5Q2F0Y2gxID0gdXRpbC50cnlDYXRjaDE7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xuXG5mdW5jdGlvbiBzcHJlYWRBZGFwdGVyKHZhbCwgbm9kZWJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgaWYgKCF1dGlsLmlzQXJyYXkodmFsKSkgcmV0dXJuIHN1Y2Nlc3NBZGFwdGVyLmNhbGwocHJvbWlzZSwgdmFsLCBub2RlYmFjayk7XG4gICAgdmFyIHJldCA9IHV0aWwudHJ5Q2F0Y2hBcHBseShub2RlYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtudWxsXS5jb25jYXQodmFsKSwgcHJvbWlzZS5fYm91bmRUbyk7XG4gICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihyZXQuZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzdWNjZXNzQWRhcHRlcih2YWwsIG5vZGViYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciByZWNlaXZlciA9IHByb21pc2UuX2JvdW5kVG87XG4gICAgdmFyIHJldCA9IHZhbCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gdHJ5Q2F0Y2gxKG5vZGViYWNrLCByZWNlaXZlciwgbnVsbClcbiAgICAgICAgOiB0cnlDYXRjaDIobm9kZWJhY2ssIHJlY2VpdmVyLCBudWxsLCB2YWwpO1xuICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIocmV0LmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVycm9yQWRhcHRlcihyZWFzb24sIG5vZGViYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBwcm9taXNlLl90YXJnZXQoKTtcbiAgICAgICAgdmFyIG5ld1JlYXNvbiA9IHRhcmdldC5fZ2V0Q2FycmllZFN0YWNrVHJhY2UoKTtcbiAgICAgICAgbmV3UmVhc29uLmNhdXNlID0gcmVhc29uO1xuICAgICAgICByZWFzb24gPSBuZXdSZWFzb247XG4gICAgfVxuICAgIHZhciByZXQgPSB0cnlDYXRjaDEobm9kZWJhY2ssIHByb21pc2UuX2JvdW5kVG8sIHJlYXNvbik7XG4gICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihyZXQuZSk7XG4gICAgfVxufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKG5vZGViYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBub2RlYmFjayA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIGFkYXB0ZXIgPSBzdWNjZXNzQWRhcHRlcjtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBPYmplY3Qob3B0aW9ucykuc3ByZWFkKSB7XG4gICAgICAgICAgICBhZGFwdGVyID0gc3ByZWFkQWRhcHRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90aGVuKFxuICAgICAgICAgICAgYWRhcHRlcixcbiAgICAgICAgICAgIGVycm9yQWRhcHRlcixcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBub2RlYmFja1xuICAgICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSkge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpO1xudmFyIGFzeW5jID0gcmVxdWlyZShcIi4vYXN5bmMuanNcIik7XG52YXIgZXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpO1xudmFyIHRyeUNhdGNoMSA9IHV0aWwudHJ5Q2F0Y2gxO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcblxuUHJvbWlzZS5wcm90b3R5cGUucHJvZ3Jlc3NlZCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4odW5kZWZpbmVkLCB1bmRlZmluZWQsIGhhbmRsZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm9ncmVzcyA9IGZ1bmN0aW9uIChwcm9ncmVzc1ZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2lzRm9sbG93aW5nT3JGdWxmaWxsZWRPclJlamVjdGVkKCkpIHJldHVybjtcbiAgICB0aGlzLl90YXJnZXQoKS5fcHJvZ3Jlc3NVbmNoZWNrZWQocHJvZ3Jlc3NWYWx1ZSk7XG5cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm9ncmVzc0hhbmRsZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA9PT0gMFxuICAgICAgICA/IHRoaXMuX3Byb2dyZXNzSGFuZGxlcjBcbiAgICAgICAgOiB0aGlzWyhpbmRleCA8PCAyKSArIGluZGV4IC0gNSArIDJdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2RvUHJvZ3Jlc3NXaXRoID0gZnVuY3Rpb24gKHByb2dyZXNzaW9uKSB7XG4gICAgdmFyIHByb2dyZXNzVmFsdWUgPSBwcm9ncmVzc2lvbi52YWx1ZTtcbiAgICB2YXIgaGFuZGxlciA9IHByb2dyZXNzaW9uLmhhbmRsZXI7XG4gICAgdmFyIHByb21pc2UgPSBwcm9ncmVzc2lvbi5wcm9taXNlO1xuICAgIHZhciByZWNlaXZlciA9IHByb2dyZXNzaW9uLnJlY2VpdmVyO1xuXG4gICAgdmFyIHJldCA9IHRyeUNhdGNoMShoYW5kbGVyLCByZWNlaXZlciwgcHJvZ3Jlc3NWYWx1ZSk7XG4gICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgaWYgKHJldC5lICE9IG51bGwgJiZcbiAgICAgICAgICAgIHJldC5lLm5hbWUgIT09IFwiU3RvcFByb2dyZXNzUHJvcGFnYXRpb25cIikge1xuICAgICAgICAgICAgdmFyIHRyYWNlID0gZXJyb3JzLmNhbkF0dGFjaFRyYWNlKHJldC5lKVxuICAgICAgICAgICAgICAgID8gcmV0LmUgOiBuZXcgRXJyb3IodXRpbC50b1N0cmluZyhyZXQuZSkpO1xuICAgICAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZSh0cmFjZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9wcm9ncmVzcyhyZXQuZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0Ll90aGVuKHByb21pc2UuX3Byb2dyZXNzLCBudWxsLCBudWxsLCBwcm9taXNlLCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UuX3Byb2dyZXNzKHJldCk7XG4gICAgfVxufTtcblxuXG5Qcm9taXNlLnByb3RvdHlwZS5fcHJvZ3Jlc3NVbmNoZWNrZWQgPSBmdW5jdGlvbiAocHJvZ3Jlc3NWYWx1ZSkge1xuICAgIHZhciBsZW4gPSB0aGlzLl9sZW5ndGgoKTtcbiAgICB2YXIgcHJvZ3Jlc3MgPSB0aGlzLl9wcm9ncmVzcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5fcHJvZ3Jlc3NIYW5kbGVyQXQoaSk7XG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZUF0KGkpO1xuICAgICAgICBpZiAoIShwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoaSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbChyZWNlaXZlciwgcHJvZ3Jlc3NWYWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyIGluc3RhbmNlb2YgUHJvbWlzZUFycmF5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICFyZWNlaXZlci5faXNSZXNvbHZlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIuX3Byb21pc2VQcm9ncmVzc2VkKHByb2dyZXNzVmFsdWUsIHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgYXN5bmMuaW52b2tlKHRoaXMuX2RvUHJvZ3Jlc3NXaXRoLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVyOiB0aGlzLl9yZWNlaXZlckF0KGkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9ncmVzc1ZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLmludm9rZShwcm9ncmVzcywgcHJvbWlzZSwgcHJvZ3Jlc3NWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xufTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG52YXIgbWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJjaXJjdWxhciBwcm9taXNlIHJlc29sdXRpb24gY2hhaW5cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9MaEZwbzBcXHUwMDBhXCIpO1xufTtcbnZhciByZWZsZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uKHRoaXMuX3RhcmdldCgpKTtcbn07XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIik7XG52YXIgYXN5bmMgPSByZXF1aXJlKFwiLi9hc3luYy5qc1wiKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIik7XG52YXIgSU5URVJOQUwgPSBmdW5jdGlvbigpe307XG52YXIgQVBQTFkgPSB7fTtcbnZhciBORVhUX0ZJTFRFUiA9IHtlOiBudWxsfTtcbnZhciBhcGlSZWplY3Rpb24gPSByZXF1aXJlKFwiLi9lcnJvcnNfYXBpX3JlamVjdGlvblwiKShQcm9taXNlKTtcbnZhciB0cnlDb252ZXJ0VG9Qcm9taXNlID0gcmVxdWlyZShcIi4vdGhlbmFibGVzLmpzXCIpKFByb21pc2UsIElOVEVSTkFMKTtcbnZhciBQcm9taXNlQXJyYXkgPVxuICAgIHJlcXVpcmUoXCIuL3Byb21pc2VfYXJyYXkuanNcIikoUHJvbWlzZSwgSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pO1xudmFyIENhcHR1cmVkVHJhY2UgPSByZXF1aXJlKFwiLi9jYXB0dXJlZF90cmFjZS5qc1wiKSgpO1xudmFyIENhdGNoRmlsdGVyID0gcmVxdWlyZShcIi4vY2F0Y2hfZmlsdGVyLmpzXCIpKE5FWFRfRklMVEVSKTtcbnZhciBQcm9taXNlUmVzb2x2ZXIgPSByZXF1aXJlKFwiLi9wcm9taXNlX3Jlc29sdmVyLmpzXCIpO1xudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIHRyeUNhdGNoMCA9IHV0aWwudHJ5Q2F0Y2gwO1xudmFyIHRyeUNhdGNoMSA9IHV0aWwudHJ5Q2F0Y2gxO1xudmFyIHRyeUNhdGNoMiA9IHV0aWwudHJ5Q2F0Y2gyO1xudmFyIHRyeUNhdGNoQXBwbHkgPSB1dGlsLnRyeUNhdGNoQXBwbHk7XG52YXIgUmFuZ2VFcnJvciA9IGVycm9ycy5SYW5nZUVycm9yO1xudmFyIFR5cGVFcnJvciA9IGVycm9ycy5UeXBlRXJyb3I7XG52YXIgQ2FuY2VsbGF0aW9uRXJyb3IgPSBlcnJvcnMuQ2FuY2VsbGF0aW9uRXJyb3I7XG52YXIgVGltZW91dEVycm9yID0gZXJyb3JzLlRpbWVvdXRFcnJvcjtcbnZhciBPcGVyYXRpb25hbEVycm9yID0gZXJyb3JzLk9wZXJhdGlvbmFsRXJyb3I7XG52YXIgb3JpZ2luYXRlc0Zyb21SZWplY3Rpb24gPSBlcnJvcnMub3JpZ2luYXRlc0Zyb21SZWplY3Rpb247XG52YXIgbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uID0gZXJyb3JzLm1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbjtcbnZhciBjYW5BdHRhY2hUcmFjZSA9IGVycm9ycy5jYW5BdHRhY2hUcmFjZTtcbnZhciB1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkO1xudmFyIHBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uO1xuXG52YXIgZGVidWdnaW5nID0gZmFsc2UgfHwgISEoXG4gICAgdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy5leGVjUGF0aCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLmVudiA9PT0gXCJvYmplY3RcIiAmJlxuICAgIChwcm9jZXNzLmVudltcIkJMVUVCSVJEX0RFQlVHXCJdIHx8XG4gICAgICAgIHByb2Nlc3MuZW52W1wiTk9ERV9FTlZcIl0gPT09IFwiZGV2ZWxvcG1lbnRcIilcbik7XG5mdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvciByZXF1aXJlcyBhIHJlc29sdmVyIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvRUMyMlluXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgIT09IFByb21pc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoZSBwcm9taXNlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBpbnZva2VkIGRpcmVjdGx5XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvS3NJbGdlXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdGhpcy5fYml0RmllbGQgPSAwO1xuICAgIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcHJvZ3Jlc3NIYW5kbGVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wcm9taXNlMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZWNlaXZlcjAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2V0dGxlZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2JvdW5kVG8gPSB1bmRlZmluZWQ7XG4gICAgaWYgKHJlc29sdmVyICE9PSBJTlRFUk5BTCkgdGhpcy5fcmVzb2x2ZUZyb21SZXNvbHZlcihyZXNvbHZlcik7XG59XG5cblByb21pc2UucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAodGhpc0FyZykge1xuICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXNBcmcsIHRoaXMpO1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9wcm9wYWdhdGVGcm9tKHRoaXMsIDEpO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB0YXJnZXQuX3RoZW4oSU5URVJOQUwsIHJldC5fcmVqZWN0LCByZXQuX3Byb2dyZXNzLCByZXQsIG51bGwpO1xuICAgICAgICBtYXliZVByb21pc2UuX3RoZW4oZnVuY3Rpb24odGhpc0FyZykge1xuICAgICAgICAgICAgaWYgKHJldC5faXNQZW5kaW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXQuX3NldEJvdW5kVG8odGhpc0FyZyk7XG4gICAgICAgICAgICAgICAgcmV0Ll9mb2xsb3codGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgcmV0Ll9yZWplY3QsIHJldC5fcHJvZ3Jlc3MsIHJldCwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0Ll9zZXRCb3VuZFRvKHRoaXNBcmcpO1xuICAgICAgICByZXQuX2ZvbGxvdyh0YXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5jYXVnaHQgPSBQcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgdmFyIGNhdGNoSW5zdGFuY2VzID0gbmV3IEFycmF5KGxlbiAtIDEpLFxuICAgICAgICAgICAgaiA9IDAsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjYXRjaEluc3RhbmNlc1tqKytdID0gaXRlbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IFR5cGVFcnJvcihcIkNhdGNoIGZpbHRlciBtdXN0IGluaGVyaXQgZnJvbSBFcnJvciBvciBiZSBhIHNpbXBsZSBwcmVkaWNhdGUgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9vODRvNjhcXHUwMDBhXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2hJbnN0YW5jZXMubGVuZ3RoID0gajtcbiAgICAgICAgZm4gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHZhciBjYXRjaEZpbHRlciA9IG5ldyBDYXRjaEZpbHRlcihjYXRjaEluc3RhbmNlcywgZm4sIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhlbih1bmRlZmluZWQsIGNhdGNoRmlsdGVyLmRvRmlsdGVyLCB1bmRlZmluZWQsXG4gICAgICAgICAgICBjYXRjaEZpbHRlciwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4odW5kZWZpbmVkLCBmbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yZWZsZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl90aGVuKHJlZmxlY3QsIHJlZmxlY3QsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCBkaWRQcm9ncmVzcykge1xuICAgIHJldHVybiB0aGlzLl90aGVuKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgZGlkUHJvZ3Jlc3MsXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn07XG5cblxuUHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChkaWRGdWxmaWxsLCBkaWRSZWplY3QsIGRpZFByb2dyZXNzKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLl90aGVuKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgZGlkUHJvZ3Jlc3MsXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICBwcm9taXNlLl9zZXRJc0ZpbmFsKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zcHJlYWQgPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0KSB7XG4gICAgdmFyIGZvbGxvd2VlID0gdGhpcy5fdGFyZ2V0KCk7XG4gICAgdmFyIHRhcmdldCA9IGZvbGxvd2VlLl9pc1NwcmVhZGFibGUoKVxuICAgICAgICA/IChmb2xsb3dlZSA9PT0gdGhpcyA/IHRoaXMgOiB0aGlzLnRoZW4oKSlcbiAgICAgICAgOiB0aGlzLmFsbCgpO1xuICAgIHJldHVybiB0YXJnZXQuX3RoZW4oZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCB1bmRlZmluZWQsIEFQUExZLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNDYW5jZWxsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNSZXNvbHZlZCgpICYmXG4gICAgICAgIHRoaXMuX2NhbmNlbGxhYmxlKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJldCA9IHtcbiAgICAgICAgaXNGdWxmaWxsZWQ6IGZhbHNlLFxuICAgICAgICBpc1JlamVjdGVkOiBmYWxzZSxcbiAgICAgICAgZnVsZmlsbG1lbnRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICByZWplY3Rpb25SZWFzb246IHVuZGVmaW5lZFxuICAgIH07XG4gICAgaWYgKHRoaXMuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICByZXQuZnVsZmlsbG1lbnRWYWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgcmV0LmlzRnVsZmlsbGVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgIHJldC5yZWplY3Rpb25SZWFzb24gPSB0aGlzLnJlYXNvbigpO1xuICAgICAgICByZXQuaXNSZWplY3RlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlQXJyYXkodGhpcykucHJvbWlzZSgpO1xuICAgIHJldC5fc2V0SXNTcHJlYWRhYmxlKCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuY2F1Z2h0KG9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uLCBmbik7XG59O1xuXG5Qcm9taXNlLmlzID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBQcm9taXNlO1xufTtcblxuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VBcnJheShwcm9taXNlcykucHJvbWlzZSgpO1xuICAgIHJldC5fc2V0SXNTcHJlYWRhYmxlKCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UubWV0aG9kID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJmbiBtdXN0IGJlIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC85MTZsSkpcXHUwMDBhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcmV0Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6IHZhbHVlID0gdHJ5Q2F0Y2gwKGZuLCB0aGlzKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMTogdmFsdWUgPSB0cnlDYXRjaDEoZm4sIHRoaXMsIGFyZ3VtZW50c1swXSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IHZhbHVlID0gdHJ5Q2F0Y2gyKGZuLCB0aGlzLCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICRfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgYXJncyA9IG5ldyBBcnJheSgkX2xlbik7IGZvcih2YXIgJF9pID0gMDsgJF9pIDwgJF9sZW47ICsrJF9pKSB7YXJnc1skX2ldID0gYXJndW1lbnRzWyRfaV07fVxuICAgICAgICAgICAgdmFsdWUgPSB0cnlDYXRjaEFwcGx5KGZuLCBhcmdzLCB0aGlzKTsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgIHJldC5fcmVzb2x2ZUZyb21TeW5jVmFsdWUodmFsdWUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59O1xuXG5Qcm9taXNlLmF0dGVtcHQgPSBQcm9taXNlW1widHJ5XCJdID0gZnVuY3Rpb24gKGZuLCBhcmdzLCBjdHgpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImZuIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzkxNmxKSlxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHJldC5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgdmFsdWUgPSBpc0FycmF5KGFyZ3MpXG4gICAgICAgID8gdHJ5Q2F0Y2hBcHBseShmbiwgYXJncywgY3R4KVxuICAgICAgICA6IHRyeUNhdGNoMShmbiwgY3R4LCBhcmdzKTtcbiAgICByZXQuX3BvcENvbnRleHQoKTtcbiAgICByZXQuX3Jlc29sdmVGcm9tU3luY1ZhbHVlKHZhbHVlKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5kZWZlciA9IFByb21pc2UucGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2VSZXNvbHZlcihwcm9taXNlKTtcbn07XG5cblByb21pc2UuYmluZCA9IGZ1bmN0aW9uICh0aGlzQXJnKSB7XG4gICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodGhpc0FyZywgdW5kZWZpbmVkKTtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuXG4gICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKGZ1bmN0aW9uKHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHJldC5fc2V0Qm91bmRUbyh0aGlzQXJnKTtcbiAgICAgICAgICAgIHJldC5fZnVsZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICB9LCByZXQuX3JlamVjdCwgcmV0Ll9wcm9ncmVzcywgcmV0LCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQuX3NldEJvdW5kVG8odGhpc0FyZyk7XG4gICAgICAgIHJldC5fc2V0RnVsZmlsbGVkKCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLmNhc3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJldCA9IHRyeUNvbnZlcnRUb1Byb21pc2Uob2JqLCB1bmRlZmluZWQpO1xuICAgIGlmICghKHJldCBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgIHZhciB2YWwgPSByZXQ7XG4gICAgICAgIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcmV0Ll9zZXRGdWxmaWxsZWQoKTtcbiAgICAgICAgcmV0Ll9zZXR0bGVkVmFsdWUgPSB2YWw7XG4gICAgICAgIHJldC5fY2xlYW5WYWx1ZXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucmVzb2x2ZSA9IFByb21pc2UuZnVsZmlsbGVkID0gUHJvbWlzZS5jYXN0O1xuXG5Qcm9taXNlLnJlamVjdCA9IFByb21pc2UucmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKHJlYXNvbik7XG4gICAgdmFyIGhhc1N0YWNrID0gY2FuQXR0YWNoVHJhY2UocmVhc29uKSAmJiB0eXBlb2YgcmVhc29uLnN0YWNrID09PSBcInN0cmluZ1wiO1xuICAgIHZhciB0cmFjZSA9IGVycm9ycy5lbnN1cmVFcnJvck9iamVjdChyZWFzb24pO1xuICAgIHJldC5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24sIGhhc1N0YWNrKTtcbiAgICByZXQuX3JlamVjdFVuY2hlY2tlZChyZWFzb24sIHRyYWNlID09PSByZWFzb24gPyB1bmRlZmluZWQgOiB0cmFjZSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2Uub25Qb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuICAgIHBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uID0gdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIgPyBmbiA6IHVuZGVmaW5lZDtcbn07XG5cblByb21pc2Uub25VbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCA9IHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiID8gZm4gOiB1bmRlZmluZWQ7XG59O1xuXG5Qcm9taXNlLmxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXN5bmMuaGF2ZUl0ZW1zUXVldWVkKCkgJiZcbiAgICAgICAgZGVidWdnaW5nID09PSBmYWxzZVxuICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmFibGUgbG9uZyBzdGFjayB0cmFjZXMgYWZ0ZXIgcHJvbWlzZXMgaGF2ZSBiZWVuIGNyZWF0ZWRcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9EVDFxeUdcXHUwMDBhXCIpO1xuICAgIH1cbiAgICBkZWJ1Z2dpbmcgPSBDYXB0dXJlZFRyYWNlLmlzU3VwcG9ydGVkKCk7XG59O1xuXG5Qcm9taXNlLmhhc0xvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGVidWdnaW5nICYmIENhcHR1cmVkVHJhY2UuaXNTdXBwb3J0ZWQoKTtcbn07XG5cblByb21pc2Uuc2V0U2NoZWR1bGVyID0gZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJmbiBtdXN0IGJlIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC85MTZsSkpcXHUwMDBhXCIpO1xuICAgIGFzeW5jLl9zY2hlZHVsZSA9IGZuO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3RoZW4gPSBmdW5jdGlvbiAoXG4gICAgZGlkRnVsZmlsbCxcbiAgICBkaWRSZWplY3QsXG4gICAgZGlkUHJvZ3Jlc3MsXG4gICAgcmVjZWl2ZXIsXG4gICAgaW50ZXJuYWxEYXRhXG4pIHtcbiAgICB2YXIgaGF2ZUludGVybmFsRGF0YSA9IGludGVybmFsRGF0YSAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciByZXQgPSBoYXZlSW50ZXJuYWxEYXRhID8gaW50ZXJuYWxEYXRhIDogbmV3IFByb21pc2UoSU5URVJOQUwpO1xuXG4gICAgaWYgKCFoYXZlSW50ZXJuYWxEYXRhKSB7XG4gICAgICAgIHJldC5fcHJvcGFnYXRlRnJvbSh0aGlzLCA0IHwgMSk7XG4gICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0KCk7XG4gICAgaWYgKHRhcmdldCAhPT0gdGhpcykge1xuICAgICAgICBpZiAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCkgcmVjZWl2ZXIgPSB0aGlzLl9ib3VuZFRvO1xuICAgICAgICBpZiAoIWhhdmVJbnRlcm5hbERhdGEpIHJldC5fc2V0SXNNaWdyYXRlZCgpO1xuICAgIH1cblxuICAgIHZhciBjYWxsYmFja0luZGV4ID1cbiAgICAgICAgdGFyZ2V0Ll9hZGRDYWxsYmFja3MoZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCBkaWRQcm9ncmVzcywgcmV0LCByZWNlaXZlcik7XG5cbiAgICBpZiAodGFyZ2V0Ll9pc1Jlc29sdmVkKCkgJiYgIXRhcmdldC5faXNTZXR0bGVQcm9taXNlc1F1ZXVlZCgpKSB7XG4gICAgICAgIGFzeW5jLmludm9rZShcbiAgICAgICAgICAgIHRhcmdldC5fc2V0dGxlUHJvbWlzZUF0UG9zdFJlc29sdXRpb24sIHRhcmdldCwgY2FsbGJhY2tJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlQXRQb3N0UmVzb2x1dGlvbiA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIGlmICh0aGlzLl9pc1JlamVjdGlvblVuaGFuZGxlZCgpKSB0aGlzLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgdGhpcy5fc2V0dGxlUHJvbWlzZUF0KGluZGV4KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpdEZpZWxkICYgMTMxMDcxO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzRm9sbG93aW5nT3JGdWxmaWxsZWRPclJlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA5Mzk1MjQwOTYpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0ZvbGxvd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNTM2ODcwOTEyKSA9PT0gNTM2ODcwOTEyO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9ICh0aGlzLl9iaXRGaWVsZCAmIC0xMzEwNzIpIHxcbiAgICAgICAgKGxlbiAmIDEzMTA3MSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0RnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAyNjg0MzU0NTY7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0UmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDEzNDIxNzcyODtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRGb2xsb3dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDUzNjg3MDkxMjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRJc0ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAzMzU1NDQzMjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAzMzU1NDQzMikgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NhbmNlbGxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA2NzEwODg2NCkgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldENhbmNlbGxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA2NzEwODg2NDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldENhbmNlbGxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjY3MTA4ODY0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMjA5NzE1Mjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjIwOTcxNTIpO1xuICAgIGlmICh0aGlzLl9pc1VuaGFuZGxlZFJlamVjdGlvbk5vdGlmaWVkKCkpIHtcbiAgICAgICAgdGhpcy5fdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkKCk7XG4gICAgICAgIHRoaXMuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbklzSGFuZGxlZCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc1JlamVjdGlvblVuaGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMjA5NzE1MikgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzU3ByZWFkYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTMxMDcyKSA+IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0SXNTcHJlYWRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxMzEwNzI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0SXNNaWdyYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgNDE5NDMwNDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldElzTWlncmF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+NDE5NDMwNCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNNaWdyYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNDE5NDMwNCkgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDUyNDI4ODtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+NTI0Mjg4KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc1VuaGFuZGxlZFJlamVjdGlvbk5vdGlmaWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA1MjQyODgpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRDYXJyaWVkU3RhY2tUcmFjZSA9IGZ1bmN0aW9uIChjYXB0dXJlZFRyYWNlKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDEwNDg1NzY7XG4gICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9IGNhcHR1cmVkVHJhY2U7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNDYXJyeWluZ1N0YWNrVHJhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDEwNDg1NzYpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9nZXRDYXJyaWVkU3RhY2tUcmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNDYXJyeWluZ1N0YWNrVHJhY2UoKVxuICAgICAgICA/IHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjBcbiAgICAgICAgOiB1bmRlZmluZWQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVjZWl2ZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciByZXQgPSBpbmRleCA9PT0gMFxuICAgICAgICA/IHRoaXMuX3JlY2VpdmVyMFxuICAgICAgICA6IHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDUgLSA1ICsgNF07XG4gICAgaWYgKHRoaXMuX2lzQm91bmQoKSAmJiByZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRUbztcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPT09IDBcbiAgICAgICAgPyB0aGlzLl9wcm9taXNlMFxuICAgICAgICA6IHRoaXNbaW5kZXggKiA1IC0gNSArIDNdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGxtZW50SGFuZGxlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID09PSAwXG4gICAgICAgID8gdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMFxuICAgICAgICA6IHRoaXNbaW5kZXggKiA1IC0gNSArIDBdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdGlvbkhhbmRsZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA9PT0gMFxuICAgICAgICA/IHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwXG4gICAgICAgIDogdGhpc1tpbmRleCAqIDUgLSA1ICsgMV07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbWlncmF0ZUNhbGxiYWNrcyA9IGZ1bmN0aW9uIChcbiAgICBmdWxmaWxsLFxuICAgIHJlamVjdCxcbiAgICBwcm9ncmVzcyxcbiAgICBwcm9taXNlLFxuICAgIHJlY2VpdmVyXG4pIHtcbiAgICBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHByb21pc2UuX3NldElzTWlncmF0ZWQoKTtcbiAgICB0aGlzLl9hZGRDYWxsYmFja3MoZnVsZmlsbCwgcmVqZWN0LCBwcm9ncmVzcywgcHJvbWlzZSwgcmVjZWl2ZXIpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2FkZENhbGxiYWNrcyA9IGZ1bmN0aW9uIChcbiAgICBmdWxmaWxsLFxuICAgIHJlamVjdCxcbiAgICBwcm9ncmVzcyxcbiAgICBwcm9taXNlLFxuICAgIHJlY2VpdmVyXG4pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9sZW5ndGgoKTtcblxuICAgIGlmIChpbmRleCA+PSAxMzEwNzEgLSA1KSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9wcm9taXNlMCA9IHByb21pc2U7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gdW5kZWZpbmVkKSB0aGlzLl9yZWNlaXZlcjAgPSByZWNlaXZlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmdWxmaWxsID09PSBcImZ1bmN0aW9uXCIgJiYgIXRoaXMuX2lzQ2FycnlpbmdTdGFja1RyYWNlKCkpXG4gICAgICAgICAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gZnVsZmlsbDtcbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPSByZWplY3Q7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvZ3Jlc3MgPT09IFwiZnVuY3Rpb25cIikgdGhpcy5fcHJvZ3Jlc3NIYW5kbGVyMCA9IHByb2dyZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBiYXNlID0gaW5kZXggKiA1IC0gNTtcbiAgICAgICAgdGhpc1tiYXNlICsgM10gPSBwcm9taXNlO1xuICAgICAgICB0aGlzW2Jhc2UgKyA0XSA9IHJlY2VpdmVyO1xuICAgICAgICBpZiAodHlwZW9mIGZ1bGZpbGwgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHRoaXNbYmFzZSArIDBdID0gZnVsZmlsbDtcbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHRoaXNbYmFzZSArIDFdID0gcmVqZWN0O1xuICAgICAgICBpZiAodHlwZW9mIHByb2dyZXNzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICB0aGlzW2Jhc2UgKyAyXSA9IHByb2dyZXNzO1xuICAgIH1cbiAgICB0aGlzLl9zZXRMZW5ndGgoaW5kZXggKyAxKTtcbiAgICByZXR1cm4gaW5kZXg7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0UHJveHlIYW5kbGVycyA9IGZ1bmN0aW9uIChyZWNlaXZlciwgcHJvbWlzZVNsb3RWYWx1ZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX2xlbmd0aCgpO1xuXG4gICAgaWYgKGluZGV4ID49IDEzMTA3MSAtIDUpIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgfVxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9wcm9taXNlMCA9IHByb21pc2VTbG90VmFsdWU7XG4gICAgICAgIHRoaXMuX3JlY2VpdmVyMCA9IHJlY2VpdmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBiYXNlID0gaW5kZXggKiA1IC0gNTtcbiAgICAgICAgdGhpc1tiYXNlICsgM10gPSBwcm9taXNlU2xvdFZhbHVlO1xuICAgICAgICB0aGlzW2Jhc2UgKyA0XSA9IHJlY2VpdmVyO1xuICAgIH1cbiAgICB0aGlzLl9zZXRMZW5ndGgoaW5kZXggKyAxKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm94eVByb21pc2VBcnJheSA9IGZ1bmN0aW9uIChwcm9taXNlQXJyYXksIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0UHJveHlIYW5kbGVycyhwcm9taXNlQXJyYXksIGluZGV4KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRCb3VuZFRvID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgODM4ODYwODtcbiAgICAgICAgdGhpcy5fYm91bmRUbyA9IG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH44Mzg4NjA4KTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNCb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgODM4ODYwOCkgPT09IDgzODg2MDg7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUZyb21SZXNvbHZlciA9IGZ1bmN0aW9uIChyZXNvbHZlcikge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgc3luY2hyb25vdXMgPSB0cnVlO1xuXG4gICAgdGhpcy5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB0aGlzLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciByID0gdHJ5Q2F0Y2gyKHJlc29sdmVyLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9taXNlLl90cnlGb2xsb3codmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlzZS5fZnVsZmlsbCh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBtYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24ocmVhc29uKTtcbiAgICAgICAgdmFyIHRyYWNlID0gZXJyb3JzLmVuc3VyZUVycm9yT2JqZWN0KHJlYXNvbik7XG4gICAgICAgIHZhciBoYXNTdGFjayA9IGNhbkF0dGFjaFRyYWNlKHJlYXNvbikgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0cmFjZS5zdGFjayA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZSh0cmFjZSwgc3luY2hyb25vdXMgPyBoYXNTdGFjayA6IGZhbHNlKTtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHJlYXNvbiwgdHJhY2UgPT09IHJlYXNvbiA/IHVuZGVmaW5lZCA6IHRyYWNlKTtcbiAgICB9KTtcbiAgICBzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgIHRoaXMuX3BvcENvbnRleHQoKTtcblxuICAgIGlmIChyICE9PSB1bmRlZmluZWQgJiYgciA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgdmFyIHJlYXNvbiA9IHIuZTtcbiAgICAgICAgdmFyIGhhc1N0YWNrID0gY2FuQXR0YWNoVHJhY2UocmVhc29uKSAmJlxuICAgICAgICAgICAgdHlwZW9mIHJlYXNvbi5zdGFjayA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgdmFyIHRyYWNlID0gZXJyb3JzLmVuc3VyZUVycm9yT2JqZWN0KHJlYXNvbik7XG4gICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UocmVhc29uLCBoYXNTdGFjayk7XG4gICAgICAgIHByb21pc2UuX3JlamVjdChyZWFzb24sIHRyYWNlID09PSByZWFzb24gPyB1bmRlZmluZWQgOiB0cmFjZSk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlciA9IGZ1bmN0aW9uIChcbiAgICBoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUsIHByb21pc2Vcbikge1xuICAgIGlmIChwcm9taXNlLl9pc1JlamVjdGVkKCkpIHJldHVybjtcbiAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciB4O1xuICAgIGlmIChyZWNlaXZlciA9PT0gQVBQTFkgJiYgIXRoaXMuX2lzUmVqZWN0ZWQoKSkge1xuICAgICAgICB4ID0gdHJ5Q2F0Y2hBcHBseShoYW5kbGVyLCB2YWx1ZSwgdGhpcy5fYm91bmRUbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRyeUNhdGNoMShoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUpO1xuICAgIH1cbiAgICBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG5cbiAgICBpZiAoeCA9PT0gZXJyb3JPYmogfHwgeCA9PT0gcHJvbWlzZSB8fCB4ID09PSBORVhUX0ZJTFRFUikge1xuICAgICAgICB2YXIgZXJyID0geCA9PT0gcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICA/IG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKClcbiAgICAgICAgICAgICAgICAgICAgOiB4LmU7XG4gICAgICAgIHZhciB0cmFjZSA9IGNhbkF0dGFjaFRyYWNlKGVycikgPyBlcnIgOiBuZXcgRXJyb3IodXRpbC50b1N0cmluZyhlcnIpKTtcbiAgICAgICAgaWYgKHggIT09IE5FWFRfRklMVEVSKSBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHRyYWNlKTtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0VW5jaGVja2VkKGVyciwgdHJhY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHgsIHByb21pc2UpO1xuICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHggPSB4Ll90YXJnZXQoKTtcbiAgICAgICAgICAgIGlmICh4Ll9pc1JlamVjdGVkKCkgJiZcbiAgICAgICAgICAgICAgICAheC5faXNDYXJyeWluZ1N0YWNrVHJhY2UoKSAmJlxuICAgICAgICAgICAgICAgICFjYW5BdHRhY2hUcmFjZSh4Ll9yZWFzb24oKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2UgPSBuZXcgRXJyb3IodXRpbC50b1N0cmluZyh4Ll9yZWFzb24oKSkpO1xuICAgICAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UodHJhY2UpO1xuICAgICAgICAgICAgICAgIHguX3NldENhcnJpZWRTdGFja1RyYWNlKHRyYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2UuX2ZvbGxvdyh4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGxVbmNoZWNrZWQoeCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdGFyZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJldCA9IHRoaXM7XG4gICAgd2hpbGUgKHJldC5faXNGb2xsb3dpbmcoKSkgcmV0ID0gcmV0Ll9mb2xsb3dlZSgpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZm9sbG93ZWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0Rm9sbG93ZWUgPSBmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPSBwcm9taXNlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ZvbGxvdyA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgaWYgKHByb21pc2UuX2lzUGVuZGluZygpKSB7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLl9sZW5ndGgoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fbWlncmF0ZUNhbGxiYWNrcyhcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXJBdChpKSxcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3Rpb25IYW5kbGVyQXQoaSksXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NIYW5kbGVyQXQoaSksXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZUF0KGkpLFxuICAgICAgICAgICAgICAgIHRoaXMuX3JlY2VpdmVyQXQoaSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0Rm9sbG93aW5nKCk7XG4gICAgICAgIHRoaXMuX3NldExlbmd0aCgwKTtcbiAgICAgICAgdGhpcy5fc2V0Rm9sbG93ZWUocHJvbWlzZSk7XG4gICAgICAgIHRoaXMuX3Byb3BhZ2F0ZUZyb20ocHJvbWlzZSwgMSk7XG4gICAgfSBlbHNlIGlmIChwcm9taXNlLl9pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgIHRoaXMuX2Z1bGZpbGxVbmNoZWNrZWQocHJvbWlzZS5fdmFsdWUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0VW5jaGVja2VkKHByb21pc2UuX3JlYXNvbigpLFxuICAgICAgICAgICAgcHJvbWlzZS5fZ2V0Q2FycmllZFN0YWNrVHJhY2UoKSk7XG4gICAgfVxuICAgIGlmIChwcm9taXNlLl9pc1JlamVjdGlvblVuaGFuZGxlZCgpKSBwcm9taXNlLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdHJ5Rm9sbG93ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2lzRm9sbG93aW5nT3JGdWxmaWxsZWRPclJlamVjdGVkKCkgfHxcbiAgICAgICAgdmFsdWUgPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZSwgdGhpcyk7XG4gICAgaWYgKCEobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9mb2xsb3cobWF5YmVQcm9taXNlLl90YXJnZXQoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGRlYnVnZ2luZykge1xuICAgICAgICB0aGlzLl90cmFjZSA9IG5ldyBDYXB0dXJlZFRyYWNlKHRoaXMuX3BlZWtDb250ZXh0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5BdHRhY2hUcmFjZSA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgcmV0dXJuIGRlYnVnZ2luZyAmJiBjYW5BdHRhY2hUcmFjZShlcnJvcik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZUlnbm9yZVNlbGYgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5fY2FuQXR0YWNoVHJhY2UoZXJyb3IpICYmIHRoaXMuX3RyYWNlLl9wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl90cmFjZS5fcGFyZW50LmF0dGFjaEV4dHJhVHJhY2UoZXJyb3IpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlID0gZnVuY3Rpb24gKGVycm9yLCBpZ25vcmVTZWxmKSB7XG4gICAgaWYgKGRlYnVnZ2luZyAmJiBjYW5BdHRhY2hUcmFjZShlcnJvcikpIHtcbiAgICAgICAgdmFyIHRyYWNlID0gdGhpcy5fdHJhY2U7XG4gICAgICAgIGlmICh0cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlU2VsZikgdHJhY2UgPSB0cmFjZS5fcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cmFjZS5hdHRhY2hFeHRyYVRyYWNlKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIENhcHR1cmVkVHJhY2UuY2xlYW5TdGFjayhlcnJvciwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2xlYW5WYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsbGF0aW9uUGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm9wYWdhdGVGcm9tID0gZnVuY3Rpb24gKHBhcmVudCwgZmxhZ3MpIHtcbiAgICBpZiAoKGZsYWdzICYgMSkgPiAwICYmIHBhcmVudC5fY2FuY2VsbGFibGUoKSkge1xuICAgICAgICB0aGlzLl9zZXRDYW5jZWxsYWJsZSgpO1xuICAgICAgICB0aGlzLl9jYW5jZWxsYXRpb25QYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGlmICgoZmxhZ3MgJiA0KSA+IDApIHtcbiAgICAgICAgdGhpcy5fc2V0Qm91bmRUbyhwYXJlbnQuX2JvdW5kVG8pO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2lzRm9sbG93aW5nT3JGdWxmaWxsZWRPclJlamVjdGVkKCkpIHJldHVybjtcbiAgICB0aGlzLl9mdWxmaWxsVW5jaGVja2VkKHZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uLCBjYXJyaWVkU3RhY2tUcmFjZSkge1xuICAgIGlmICh0aGlzLl9pc0ZvbGxvd2luZ09yRnVsZmlsbGVkT3JSZWplY3RlZCgpKSByZXR1cm47XG4gICAgdGhpcy5fcmVqZWN0VW5jaGVja2VkKHJlYXNvbiwgY2FycmllZFN0YWNrVHJhY2UpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZVByb21pc2VBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZUF0KGluZGV4KTtcbiAgICB2YXIgaXNQcm9taXNlID0gcHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2U7XG5cbiAgICBpZiAoaXNQcm9taXNlICYmIHByb21pc2UuX2lzTWlncmF0ZWQoKSkge1xuICAgICAgICBwcm9taXNlLl91bnNldElzTWlncmF0ZWQoKTtcbiAgICAgICAgcmV0dXJuIGFzeW5jLmludm9rZSh0aGlzLl9zZXR0bGVQcm9taXNlQXQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9pc0Z1bGZpbGxlZCgpXG4gICAgICAgID8gdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyQXQoaW5kZXgpXG4gICAgICAgIDogdGhpcy5fcmVqZWN0aW9uSGFuZGxlckF0KGluZGV4KTtcblxuICAgIHZhciBjYXJyaWVkU3RhY2tUcmFjZSA9XG4gICAgICAgIHRoaXMuX2lzQ2FycnlpbmdTdGFja1RyYWNlKCkgPyB0aGlzLl9nZXRDYXJyaWVkU3RhY2tUcmFjZSgpIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuX3NldHRsZWRWYWx1ZTtcbiAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzLl9yZWNlaXZlckF0KGluZGV4KTtcblxuXG4gICAgdGhpcy5fY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4KGluZGV4KTtcblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghaXNQcm9taXNlKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwocmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlcihoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWNlaXZlciBpbnN0YW5jZW9mIFByb21pc2VBcnJheSkge1xuICAgICAgICBpZiAoIXJlY2VpdmVyLl9pc1Jlc29sdmVkKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIuX3Byb21pc2VGdWxmaWxsZWQodmFsdWUsIHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIuX3Byb21pc2VSZWplY3RlZCh2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZSkge1xuICAgICAgICBpZiAodGhpcy5faXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fZnVsZmlsbCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlLl9yZWplY3QodmFsdWUsIGNhcnJpZWRTdGFja1RyYWNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbmRleCA+PSA0ICYmIChpbmRleCAmIDMxKSA9PT0gNClcbiAgICAgICAgYXN5bmMuaW52b2tlTGF0ZXIodGhpcy5fc2V0TGVuZ3RoLCB0aGlzLCAwKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jbGVhckNhbGxiYWNrRGF0YUF0SW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzQ2FycnlpbmdTdGFja1RyYWNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjAgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPVxuICAgICAgICB0aGlzLl9wcm9ncmVzc0hhbmRsZXIwID1cbiAgICAgICAgdGhpcy5fcmVjZWl2ZXIwID1cbiAgICAgICAgdGhpcy5fcHJvbWlzZTAgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJhc2UgPSBpbmRleCAqIDUgLSA1O1xuICAgICAgICB0aGlzW2Jhc2UgKyAzXSA9XG4gICAgICAgIHRoaXNbYmFzZSArIDRdID1cbiAgICAgICAgdGhpc1tiYXNlICsgMF0gPVxuICAgICAgICB0aGlzW2Jhc2UgKyAxXSA9XG4gICAgICAgIHRoaXNbYmFzZSArIDJdID0gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc1NldHRsZVByb21pc2VzUXVldWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJlxuICAgICAgICAgICAgLTEwNzM3NDE4MjQpID09PSAtMTA3Mzc0MTgyNDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRTZXR0bGVQcm9taXNlc1F1ZXVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgLTEwNzM3NDE4MjQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdW5zZXRTZXR0bGVQcm9taXNlc1F1ZXVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH4tMTA3Mzc0MTgyNCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcXVldWVTZXR0bGVQcm9taXNlcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5faXNTZXR0bGVQcm9taXNlc1F1ZXVlZCgpKSB7XG4gICAgICAgIGFzeW5jLnNldHRsZVByb21pc2VzKHRoaXMpO1xuICAgICAgICB0aGlzLl9zZXRTZXR0bGVQcm9taXNlc1F1ZXVlZCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9mdWxmaWxsVW5jaGVja2VkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0aGlzKSB7XG4gICAgICAgIHZhciBlcnIgPSBtYWtlU2VsZlJlc29sdXRpb25FcnJvcigpO1xuICAgICAgICB0aGlzLl9hdHRhY2hFeHRyYVRyYWNlKGVycik7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWplY3RVbmNoZWNrZWQoZXJyLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRGdWxmaWxsZWQoKTtcbiAgICB0aGlzLl9zZXR0bGVkVmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLl9jbGVhblZhbHVlcygpO1xuXG4gICAgaWYgKHRoaXMuX2xlbmd0aCgpID4gMCkge1xuICAgICAgICB0aGlzLl9xdWV1ZVNldHRsZVByb21pc2VzKCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdFVuY2hlY2tlZENoZWNrRXJyb3IgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdmFyIHRyYWNlID0gZXJyb3JzLmVuc3VyZUVycm9yT2JqZWN0KHJlYXNvbik7XG4gICAgdGhpcy5fcmVqZWN0VW5jaGVja2VkKHJlYXNvbiwgdHJhY2UgPT09IHJlYXNvbiA/IHVuZGVmaW5lZCA6IHRyYWNlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWplY3RVbmNoZWNrZWQgPSBmdW5jdGlvbiAocmVhc29uLCB0cmFjZSkge1xuICAgIGlmIChyZWFzb24gPT09IHRoaXMpIHtcbiAgICAgICAgdmFyIGVyciA9IG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCk7XG4gICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdFVuY2hlY2tlZChlcnIpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRSZWplY3RlZCgpO1xuICAgIHRoaXMuX3NldHRsZWRWYWx1ZSA9IHJlYXNvbjtcbiAgICB0aGlzLl9jbGVhblZhbHVlcygpO1xuXG4gICAgaWYgKHRoaXMuX2lzRmluYWwoKSkge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChcInN0YWNrXCIgaW4gZSkge1xuICAgICAgICAgICAgICAgIGFzeW5jLmludm9rZUZpcnN0KFxuICAgICAgICAgICAgICAgICAgICBDYXB0dXJlZFRyYWNlLnVuaGFuZGxlZFJlamVjdGlvbiwgdW5kZWZpbmVkLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sIHRyYWNlID09PSB1bmRlZmluZWQgPyByZWFzb24gOiB0cmFjZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHJhY2UgIT09IHVuZGVmaW5lZCAmJiB0cmFjZSAhPT0gcmVhc29uKSB7XG4gICAgICAgIHRoaXMuX3NldENhcnJpZWRTdGFja1RyYWNlKHRyYWNlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlU2V0dGxlUHJvbWlzZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lbnN1cmVQb3NzaWJsZVJlamVjdGlvbkhhbmRsZWQoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdW5zZXRTZXR0bGVQcm9taXNlc1F1ZXVlZCgpO1xuICAgIHZhciBsZW4gPSB0aGlzLl9sZW5ndGgoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3NldHRsZVByb21pc2VBdChpKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZW5zdXJlUG9zc2libGVSZWplY3Rpb25IYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3NldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgYXN5bmMuaW52b2tlTGF0ZXIodGhpcy5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uLCB0aGlzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbklzSGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBDYXB0dXJlZFRyYWNlLmZpcmVSZWplY3Rpb25FdmVudChcInJlamVjdGlvbkhhbmRsZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkLCB1bmRlZmluZWQsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5faXNSZWplY3Rpb25VbmhhbmRsZWQoKSkge1xuICAgICAgICB2YXIgcmVhc29uID0gdGhpcy5fZ2V0Q2FycmllZFN0YWNrVHJhY2UoKSB8fCB0aGlzLl9zZXR0bGVkVmFsdWU7XG4gICAgICAgIHRoaXMuX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQoKTtcbiAgICAgICAgQ2FwdHVyZWRUcmFjZS5maXJlUmVqZWN0aW9uRXZlbnQoXCJ1bmhhbmRsZWRSZWplY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24sIHJlYXNvbiwgdGhpcyk7XG4gICAgfVxufTtcblxudmFyIGNvbnRleHRTdGFjayA9IFtdO1xuZnVuY3Rpb24gQ29udGV4dCgpIHtcbiAgICB0aGlzLl90cmFjZSA9IG5ldyBDYXB0dXJlZFRyYWNlKHBlZWtDb250ZXh0KCkpO1xufVxuQ29udGV4dC5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghZGVidWdnaW5nKSByZXR1cm47XG4gICAgY29udGV4dFN0YWNrLnB1c2godGhpcy5fdHJhY2UpO1xufTtcblxuQ29udGV4dC5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFkZWJ1Z2dpbmcpIHJldHVybjtcbiAgICBjb250ZXh0U3RhY2sucG9wKCk7XG59O1xuXG4gLypqc2hpbnQgdW51c2VkOmZhbHNlKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoKSB7XG4gICAgaWYgKGRlYnVnZ2luZykgcmV0dXJuIG5ldyBDb250ZXh0KCk7XG59XG5cbmZ1bmN0aW9uIHBlZWtDb250ZXh0KCkge1xuICAgIHZhciBsYXN0SW5kZXggPSBjb250ZXh0U3RhY2subGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdEluZGV4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRTdGFja1tsYXN0SW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5fcGVla0NvbnRleHQgPSBwZWVrQ29udGV4dDtcblByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IENvbnRleHQucHJvdG90eXBlLl9wdXNoQ29udGV4dDtcblByb21pc2UucHJvdG90eXBlLl9wb3BDb250ZXh0ID0gQ29udGV4dC5wcm90b3R5cGUuX3BvcENvbnRleHQ7XG5cblByb21pc2UucHJvdG90eXBlLl9yZXNvbHZlRnJvbVN5bmNWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgdGhpcy5fc2V0UmVqZWN0ZWQoKTtcbiAgICAgICAgdmFyIHJlYXNvbiA9IHZhbHVlLmU7XG4gICAgICAgIHRoaXMuX3NldHRsZWRWYWx1ZSA9IHJlYXNvbjtcbiAgICAgICAgdGhpcy5fY2xlYW5WYWx1ZXMoKTtcbiAgICAgICAgdGhpcy5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgICAgICB0aGlzLl9lbnN1cmVQb3NzaWJsZVJlamVjdGlvbkhhbmRsZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZSwgdGhpcyk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgdGhpcy5fZm9sbG93KG1heWJlUHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRGdWxmaWxsZWQoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW5WYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG5pZiAoIUNhcHR1cmVkVHJhY2UuaXNTdXBwb3J0ZWQoKSkge1xuICAgIFByb21pc2UubG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKXt9O1xuICAgIGRlYnVnZ2luZyA9IGZhbHNlO1xufVxuXG5Qcm9taXNlLl9tYWtlU2VsZlJlc29sdXRpb25FcnJvciA9IG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yO1xucmVxdWlyZShcIi4vZmluYWxseS5qc1wiKShQcm9taXNlLCBORVhUX0ZJTFRFUiwgdHJ5Q29udmVydFRvUHJvbWlzZSk7XG5yZXF1aXJlKFwiLi9kaXJlY3RfcmVzb2x2ZS5qc1wiKShQcm9taXNlKTtcbnJlcXVpcmUoXCIuL3N5bmNocm9ub3VzX2luc3BlY3Rpb24uanNcIikoUHJvbWlzZSk7XG5yZXF1aXJlKFwiLi9qb2luLmpzXCIpKFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwpO1xuUHJvbWlzZS5SYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcblByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IgPSBDYW5jZWxsYXRpb25FcnJvcjtcblByb21pc2UuVGltZW91dEVycm9yID0gVGltZW91dEVycm9yO1xuUHJvbWlzZS5UeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5Qcm9taXNlLk9wZXJhdGlvbmFsRXJyb3IgPSBPcGVyYXRpb25hbEVycm9yO1xuUHJvbWlzZS5SZWplY3Rpb25FcnJvciA9IE9wZXJhdGlvbmFsRXJyb3I7XG5Qcm9taXNlLkFnZ3JlZ2F0ZUVycm9yID0gZXJyb3JzLkFnZ3JlZ2F0ZUVycm9yO1xuXG51dGlsLnRvRmFzdFByb3BlcnRpZXMoUHJvbWlzZSk7XG51dGlsLnRvRmFzdFByb3BlcnRpZXMoUHJvbWlzZS5wcm90b3R5cGUpO1xuUHJvbWlzZS5Qcm9taXNlID0gUHJvbWlzZTtcbkNhcHR1cmVkVHJhY2Uuc2V0Qm91bmRzKGFzeW5jLmZpcnN0TGluZUVycm9yLCB1dGlsLmxhc3RMaW5lRXJyb3IpO1xucmVxdWlyZSgnLi9ub2RlaWZ5LmpzJykoUHJvbWlzZSk7XG5yZXF1aXJlKCcuL3VzaW5nLmpzJykoUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBjcmVhdGVDb250ZXh0KTtcbnJlcXVpcmUoJy4vZ2VuZXJhdG9ycy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UpO1xucmVxdWlyZSgnLi9tYXAuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwpO1xucmVxdWlyZSgnLi9jYW5jZWwuanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5yZXF1aXJlKCcuL3Byb21pc2lmeS5qcycpKFByb21pc2UsIElOVEVSTkFMKTtcbnJlcXVpcmUoJy4vcHJvcHMuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UpO1xucmVxdWlyZSgnLi9yYWNlLmpzJykoUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UpO1xucmVxdWlyZSgnLi9yZWR1Y2UuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwpO1xucmVxdWlyZSgnLi9zZXR0bGUuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXkpO1xucmVxdWlyZSgnLi9jYWxsX2dldC5qcycpKFByb21pc2UpO1xucmVxdWlyZSgnLi9zb21lLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24pO1xucmVxdWlyZSgnLi9wcm9ncmVzcy5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSk7XG5yZXF1aXJlKCcuL2FueS5qcycpKFByb21pc2UpO1xucmVxdWlyZSgnLi9lYWNoLmpzJykoUHJvbWlzZSwgSU5URVJOQUwpO1xucmVxdWlyZSgnLi90aW1lcnMuanMnKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSk7XG5yZXF1aXJlKCcuL2ZpbHRlci5qcycpKFByb21pc2UsIElOVEVSTkFMKTtcblxuUHJvbWlzZS5wcm90b3R5cGUgPSBQcm9taXNlLnByb3RvdHlwZTtcbnJldHVybiBQcm9taXNlO1xuXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgYXBpUmVqZWN0aW9uKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIik7XG52YXIgZXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpO1xudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG5cbmZ1bmN0aW9uIHRvUmVzb2x1dGlvblZhbHVlKHZhbCkge1xuICAgIHN3aXRjaCh2YWwpIHtcbiAgICBjYXNlIC0xOiByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNhc2UgLTI6IHJldHVybiBbXTtcbiAgICBjYXNlIC0zOiByZXR1cm4ge307XG4gICAgfVxufVxuXG5mdW5jdGlvbiBQcm9taXNlQXJyYXkodmFsdWVzKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHZhciBwYXJlbnQ7XG4gICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcGFyZW50ID0gdmFsdWVzO1xuICAgICAgICBwcm9taXNlLl9wcm9wYWdhdGVGcm9tKHBhcmVudCwgMSB8IDQpO1xuICAgIH1cbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl90b3RhbFJlc29sdmVkID0gMDtcbiAgICB0aGlzLl9pbml0KHVuZGVmaW5lZCwgLTIpO1xufVxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KF8sIHJlc29sdmVWYWx1ZUlmRW1wdHkpIHtcblxuICAgIHZhciB2YWx1ZXMgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXMuX3ZhbHVlcywgdW5kZWZpbmVkKTtcbiAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB2YWx1ZXMuX3NldEJvdW5kVG8odGhpcy5fcHJvbWlzZS5fYm91bmRUbyk7XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlcy5fdGFyZ2V0KCk7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgaWYgKHZhbHVlcy5faXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLl92YWx1ZSgpO1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IFByb21pc2UuVHlwZUVycm9yKFwiZXhwZWN0aW5nIGFuIGFycmF5LCBhIHByb21pc2Ugb3IgYSB0aGVuYWJsZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL3M4TU1oY1xcdTAwMGFcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2hhcmRSZWplY3RfXyhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZXMuX2lzUGVuZGluZygpKSB7XG4gICAgICAgICAgICB2YWx1ZXMuX3RoZW4oXG4gICAgICAgICAgICAgICAgaW5pdCxcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3QsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZVZhbHVlSWZFbXB0eVxuICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QodmFsdWVzLl9yZWFzb24oKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fZm9sbG93KGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhbiBhcnJheSwgYSBwcm9taXNlIG9yIGEgdGhlbmFibGVcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9zOE1NaGNcXHUwMDBhXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChyZXNvbHZlVmFsdWVJZkVtcHR5ID09PSAtNSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5QXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodG9SZXNvbHV0aW9uVmFsdWUocmVzb2x2ZVZhbHVlSWZFbXB0eSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxlbiA9IHRoaXMuZ2V0QWN0dWFsTGVuZ3RoKHZhbHVlcy5sZW5ndGgpO1xuICAgIHRoaXMuX2xlbmd0aCA9IGxlbjtcbiAgICB0aGlzLl92YWx1ZXMgPSB0aGlzLnNob3VsZENvcHlWYWx1ZXMoKSA/IG5ldyBBcnJheShsZW4pIDogdGhpcy5fdmFsdWVzO1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBpc1Jlc29sdmVkID0gdGhpcy5faXNSZXNvbHZlZCgpO1xuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZXNbaV0sIHByb21pc2UpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcbiAgICAgICAgICAgIGlmIChpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1heWJlUHJvbWlzZS5faXNQZW5kaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3Byb3h5UHJvbWlzZUFycmF5KHRoaXMsIGkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXliZVByb21pc2UuX2lzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKG1heWJlUHJvbWlzZS5fdmFsdWUoKSwgaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2VSZWplY3RlZChtYXliZVByb21pc2UuX3JlYXNvbigpLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZChtYXliZVByb21pc2UsIGkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faXNSZXNvbHZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVzID09PSBudWxsO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fZnVsZmlsbCh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9faGFyZFJlamVjdF9fID1cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3JlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgIHZhciB0cmFjZSA9IGVycm9ycy5lbnN1cmVFcnJvck9iamVjdChyZWFzb24pO1xuICAgIHRoaXMuX3Byb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UodHJhY2UpO1xuICAgIHRoaXMuX3Byb21pc2UuX3JlamVjdChyZWFzb24sIHRyYWNlKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VQcm9ncmVzc2VkID0gZnVuY3Rpb24gKHByb2dyZXNzVmFsdWUsIGluZGV4KSB7XG4gICAgdGhpcy5fcHJvbWlzZS5fcHJvZ3Jlc3Moe1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHZhbHVlOiBwcm9ncmVzc1ZhbHVlXG4gICAgfSk7XG59O1xuXG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgIHZhciB0b3RhbFJlc29sdmVkID0gKyt0aGlzLl90b3RhbFJlc29sdmVkO1xuICAgIGlmICh0b3RhbFJlc29sdmVkID49IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyk7XG4gICAgfVxufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbiwgaW5kZXgpIHtcbiAgICB0aGlzLl90b3RhbFJlc29sdmVkKys7XG4gICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLmdldEFjdHVhbExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICByZXR1cm4gbGVuO1xufTtcblxucmV0dXJuIFByb21pc2VBcnJheTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC5qc1wiKTtcbnZhciBtYXliZVdyYXBBc0Vycm9yID0gdXRpbC5tYXliZVdyYXBBc0Vycm9yO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbnZhciBUaW1lb3V0RXJyb3IgPSBlcnJvcnMuVGltZW91dEVycm9yO1xudmFyIE9wZXJhdGlvbmFsRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcbnZhciBhc3luYyA9IHJlcXVpcmUoXCIuL2FzeW5jLmpzXCIpO1xudmFyIGhhdmVHZXR0ZXJzID0gdXRpbC5oYXZlR2V0dGVycztcbnZhciBlczUgPSByZXF1aXJlKFwiLi9lczUuanNcIik7XG5cbmZ1bmN0aW9uIGlzVW50eXBlZEVycm9yKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICBlczUuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gRXJyb3IucHJvdG90eXBlO1xufVxuXG52YXIgckVycm9yS2V5ID0gL14oPzpuYW1lfG1lc3NhZ2V8c3RhY2t8Y2F1c2UpJC87XG5mdW5jdGlvbiB3cmFwQXNPcGVyYXRpb25hbEVycm9yKG9iaikge1xuICAgIHZhciByZXQ7XG4gICAgaWYgKGlzVW50eXBlZEVycm9yKG9iaikpIHtcbiAgICAgICAgcmV0ID0gbmV3IE9wZXJhdGlvbmFsRXJyb3Iob2JqKTtcbiAgICAgICAgcmV0Lm5hbWUgPSBvYmoubmFtZTtcbiAgICAgICAgcmV0Lm1lc3NhZ2UgPSBvYmoubWVzc2FnZTtcbiAgICAgICAgcmV0LnN0YWNrID0gb2JqLnN0YWNrO1xuICAgICAgICB2YXIga2V5cyA9IGVzNS5rZXlzKG9iaik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIXJFcnJvcktleS50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGVycm9ycy5tYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24ob2JqKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBub2RlYmFja0ZvclByb21pc2UocHJvbWlzZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihlcnIsIHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9taXNlID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdmFyIHdyYXBwZWQgPSB3cmFwQXNPcGVyYXRpb25hbEVycm9yKG1heWJlV3JhcEFzRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHdyYXBwZWQpO1xuICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHdyYXBwZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgJF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBhcmdzID0gbmV3IEFycmF5KCRfbGVuIC0gMSk7IGZvcih2YXIgJF9pID0gMTsgJF9pIDwgJF9sZW47ICsrJF9pKSB7YXJnc1skX2kgLSAxXSA9IGFyZ3VtZW50c1skX2ldO31cbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwoYXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgIH07XG59XG5cblxudmFyIFByb21pc2VSZXNvbHZlcjtcbmlmICghaGF2ZUdldHRlcnMpIHtcbiAgICBQcm9taXNlUmVzb2x2ZXIgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICB0aGlzLmFzQ2FsbGJhY2sgPSBub2RlYmFja0ZvclByb21pc2UocHJvbWlzZSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSB0aGlzLmFzQ2FsbGJhY2s7XG4gICAgfTtcbn1cbmVsc2Uge1xuICAgIFByb21pc2VSZXNvbHZlciA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgfTtcbn1cbmlmIChoYXZlR2V0dGVycykge1xuICAgIHZhciBwcm9wID0ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGViYWNrRm9yUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBlczUuZGVmaW5lUHJvcGVydHkoUHJvbWlzZVJlc29sdmVyLnByb3RvdHlwZSwgXCJhc0NhbGxiYWNrXCIsIHByb3ApO1xuICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShQcm9taXNlUmVzb2x2ZXIucHJvdG90eXBlLCBcImNhbGxiYWNrXCIsIHByb3ApO1xufVxuXG5Qcm9taXNlUmVzb2x2ZXIuX25vZGViYWNrRm9yUHJvbWlzZSA9IG5vZGViYWNrRm9yUHJvbWlzZTtcblxuUHJvbWlzZVJlc29sdmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VSZXNvbHZlcl1cIjtcbn07XG5cblByb21pc2VSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9XG5Qcm9taXNlUmVzb2x2ZXIucHJvdG90eXBlLmZ1bGZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZVJlc29sdmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uLCByZXNvbHZlciByZXNvbHZlL3JlamVjdCBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gYSByZXNvbHZlciBjb250ZXh0LiBDb25zaWRlciB1c2luZyB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvciBpbnN0ZWFkLlxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL3Nka1hMOVxcdTAwMGFcIik7XG4gICAgfVxuXG4gICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG4gICAgaWYgKHByb21pc2UuX3RyeUZvbGxvdyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3luYy5pbnZva2UocHJvbWlzZS5fZnVsZmlsbCwgcHJvbWlzZSwgdmFsdWUpO1xufTtcblxuUHJvbWlzZVJlc29sdmVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VSZXNvbHZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgaW52b2NhdGlvbiwgcmVzb2x2ZXIgcmVzb2x2ZS9yZWplY3QgbXVzdCBiZSBjYWxsZWQgd2l0aGluIGEgcmVzb2x2ZXIgY29udGV4dC4gQ29uc2lkZXIgdXNpbmcgdGhlIHByb21pc2UgY29uc3RydWN0b3IgaW5zdGVhZC5cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9zZGtYTDlcXHUwMDBhXCIpO1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuICAgIGVycm9ycy5tYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24ocmVhc29uKTtcbiAgICB2YXIgdHJhY2UgPSBlcnJvcnMuZW5zdXJlRXJyb3JPYmplY3QocmVhc29uKTtcbiAgICBhc3luYy5pbnZva2UocHJvbWlzZS5fcmVqZWN0LCBwcm9taXNlLCByZWFzb24pO1xuICAgIGlmICh0cmFjZSAhPT0gcmVhc29uKSB7XG4gICAgICAgIGFzeW5jLmludm9rZSh0aGlzLl9zZXRDYXJyaWVkU3RhY2tUcmFjZSwgdGhpcywgdHJhY2UpO1xuICAgIH1cbn07XG5cblByb21pc2VSZXNvbHZlci5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZVJlc29sdmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uLCByZXNvbHZlciByZXNvbHZlL3JlamVjdCBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gYSByZXNvbHZlciBjb250ZXh0LiBDb25zaWRlciB1c2luZyB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvciBpbnN0ZWFkLlxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL3Nka1hMOVxcdTAwMGFcIik7XG4gICAgfVxuICAgIGFzeW5jLmludm9rZSh0aGlzLnByb21pc2UuX3Byb2dyZXNzLCB0aGlzLnByb21pc2UsIHZhbHVlKTtcbn07XG5cblByb21pc2VSZXNvbHZlci5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgIGFzeW5jLmludm9rZSh0aGlzLnByb21pc2UuY2FuY2VsLCB0aGlzLnByb21pc2UsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlUmVzb2x2ZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWplY3QobmV3IFRpbWVvdXRFcnJvcihcInRpbWVvdXRcIikpO1xufTtcblxuUHJvbWlzZVJlc29sdmVyLnByb3RvdHlwZS5pc1Jlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnByb21pc2UuaXNSZXNvbHZlZCgpO1xufTtcblxuUHJvbWlzZVJlc29sdmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZS50b0pTT04oKTtcbn07XG5cblByb21pc2VSZXNvbHZlci5wcm90b3R5cGUuX3NldENhcnJpZWRTdGFja1RyYWNlID0gZnVuY3Rpb24gKHRyYWNlKSB7XG4gICAgaWYgKHRoaXMucHJvbWlzZS5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlLl9zZXRDYXJyaWVkU3RhY2tUcmFjZSh0cmFjZSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlUmVzb2x2ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciBUSElTID0ge307XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIik7XG52YXIgbm9kZWJhY2tGb3JQcm9taXNlID0gcmVxdWlyZShcIi4vcHJvbWlzZV9yZXNvbHZlci5qc1wiKVxuICAgIC5fbm9kZWJhY2tGb3JQcm9taXNlO1xudmFyIHdpdGhBcHBlbmRlZCA9IHV0aWwud2l0aEFwcGVuZGVkO1xudmFyIG1heWJlV3JhcEFzRXJyb3IgPSB1dGlsLm1heWJlV3JhcEFzRXJyb3I7XG52YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xudmFyIFR5cGVFcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKS5UeXBlRXJyb3I7XG52YXIgZGVmYXVsdFN1ZmZpeCA9IFwiQXN5bmNcIjtcbnZhciBkZWZhdWx0RmlsdGVyID0gZnVuY3Rpb24obmFtZSwgZnVuYykge1xuICAgIHJldHVybiB1dGlsLmlzSWRlbnRpZmllcihuYW1lKSAmJlxuICAgICAgICBuYW1lLmNoYXJBdCgwKSAhPT0gXCJfXCIgJiZcbiAgICAgICAgIXV0aWwuaXNDbGFzcyhmdW5jKTtcbn07XG52YXIgZGVmYXVsdFByb21pc2lmaWVkID0ge19faXNQcm9taXNpZmllZF9fOiB0cnVlfTtcblxuXG5mdW5jdGlvbiBlc2NhcGVJZGVudFJlZ2V4KHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFskXSkvLCBcIlxcXFwkXCIpO1xufVxuXG5mdW5jdGlvbiBpc1Byb21pc2lmaWVkKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuLl9faXNQcm9taXNpZmllZF9fID09PSB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNQcm9taXNpZmllZChvYmosIGtleSwgc3VmZml4KSB7XG4gICAgdmFyIHZhbCA9IHV0aWwuZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0KG9iaiwga2V5ICsgc3VmZml4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UHJvbWlzaWZpZWQpO1xuICAgIHJldHVybiB2YWwgPyBpc1Byb21pc2lmaWVkKHZhbCkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFsaWQocmV0LCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXRbaV07XG4gICAgICAgIGlmIChzdWZmaXhSZWdleHAudGVzdChrZXkpKSB7XG4gICAgICAgICAgICB2YXIga2V5V2l0aG91dEFzeW5jU3VmZml4ID0ga2V5LnJlcGxhY2Uoc3VmZml4UmVnZXhwLCBcIlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmV0Lmxlbmd0aDsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldFtqXSA9PT0ga2V5V2l0aG91dEFzeW5jU3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcHJvbWlzaWZ5IGFuIEFQSSB0aGF0IGhhcyBub3JtYWwgbWV0aG9kcyB3aXRoICclcyctc3VmZml4XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvaVdyWmJ3XFx1MDAwYVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIiVzXCIsIHN1ZmZpeCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZpYWJsZU1ldGhvZHMob2JqLCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCwgZmlsdGVyKSB7XG4gICAgdmFyIGtleXMgPSB1dGlsLmluaGVyaXRlZERhdGFLZXlzKG9iaik7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIHZhciBwYXNzZXNEZWZhdWx0RmlsdGVyID0gZmlsdGVyID09PSBkZWZhdWx0RmlsdGVyXG4gICAgICAgICAgICA/IHRydWUgOiBkZWZhdWx0RmlsdGVyKGtleSwgdmFsdWUsIG9iaik7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgIWlzUHJvbWlzaWZpZWQodmFsdWUpICYmXG4gICAgICAgICAgICAhaGFzUHJvbWlzaWZpZWQob2JqLCBrZXksIHN1ZmZpeCkgJiZcbiAgICAgICAgICAgIGZpbHRlcihrZXksIHZhbHVlLCBvYmosIHBhc3Nlc0RlZmF1bHRGaWx0ZXIpKSB7XG4gICAgICAgICAgICByZXQucHVzaChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja1ZhbGlkKHJldCwgc3VmZml4LCBzdWZmaXhSZWdleHApO1xuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHN3aXRjaENhc2VBcmd1bWVudE9yZGVyKGxpa2VseUFyZ3VtZW50Q291bnQpIHtcbiAgICB2YXIgcmV0ID0gW2xpa2VseUFyZ3VtZW50Q291bnRdO1xuICAgIHZhciBtaW4gPSBNYXRoLm1heCgwLCBsaWtlbHlBcmd1bWVudENvdW50IC0gMSAtIDUpO1xuICAgIGZvcih2YXIgaSA9IGxpa2VseUFyZ3VtZW50Q291bnQgLSAxOyBpID49IG1pbjsgLS1pKSB7XG4gICAgICAgIGlmIChpID09PSBsaWtlbHlBcmd1bWVudENvdW50KSBjb250aW51ZTtcbiAgICAgICAgcmV0LnB1c2goaSk7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IGxpa2VseUFyZ3VtZW50Q291bnQgKyAxOyBpIDw9IDU7ICsraSkge1xuICAgICAgICByZXQucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gYXJndW1lbnRTZXF1ZW5jZShhcmd1bWVudENvdW50KSB7XG4gICAgcmV0dXJuIHV0aWwuZmlsbGVkUmFuZ2UoYXJndW1lbnRDb3VudCwgXCJhcmd1bWVudHNbXCIsIFwiXVwiKTtcbn1cblxuZnVuY3Rpb24gcGFyYW1ldGVyRGVjbGFyYXRpb24ocGFyYW1ldGVyQ291bnQpIHtcbiAgICByZXR1cm4gdXRpbC5maWxsZWRSYW5nZShwYXJhbWV0ZXJDb3VudCwgXCJfYXJnXCIsIFwiXCIpO1xufVxuXG5mdW5jdGlvbiBwYXJhbWV0ZXJDb3VudChmbikge1xuICAgIGlmICh0eXBlb2YgZm4ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihmbi5sZW5ndGgsIDEwMjMgKyAxKSwgMCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVByb3BlcnR5QWNjZXNzKGtleSkge1xuICAgIGlmICh1dGlsLmlzSWRlbnRpZmllcihrZXkpKSB7XG4gICAgICAgIHJldHVybiBcIi5cIiArIGtleTtcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gXCJbJ1wiICsga2V5LnJlcGxhY2UoLyhbJ1xcXFxdKS9nLCBcIlxcXFwkMVwiKSArIFwiJ11cIjtcbn1cblxuZnVuY3Rpb24gbWFrZU5vZGVQcm9taXNpZmllZEV2YWwoY2FsbGJhY2ssIHJlY2VpdmVyLCBvcmlnaW5hbE5hbWUsIGZuLCBzdWZmaXgpIHtcbiAgICB2YXIgbmV3UGFyYW1ldGVyQ291bnQgPSBNYXRoLm1heCgwLCBwYXJhbWV0ZXJDb3VudChmbikgLSAxKTtcbiAgICB2YXIgYXJndW1lbnRPcmRlciA9IHN3aXRjaENhc2VBcmd1bWVudE9yZGVyKG5ld1BhcmFtZXRlckNvdW50KTtcbiAgICB2YXIgY2FsbGJhY2tOYW1lID1cbiAgICAgICAgKHR5cGVvZiBvcmlnaW5hbE5hbWUgPT09IFwic3RyaW5nXCIgJiYgdXRpbC5pc0lkZW50aWZpZXIob3JpZ2luYWxOYW1lKVxuICAgICAgICAgICAgPyBvcmlnaW5hbE5hbWUgKyBzdWZmaXhcbiAgICAgICAgICAgIDogXCJwcm9taXNpZmllZFwiKTtcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQ2FsbEZvckFyZ3VtZW50Q291bnQoY291bnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudFNlcXVlbmNlKGNvdW50KS5qb2luKFwiLCBcIik7XG4gICAgICAgIHZhciBjb21tYSA9IGNvdW50ID4gMCA/IFwiLCBcIiA6IFwiXCI7XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldCA9IFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2Qoe3thcmdzfX0sIGZuKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgYnJlYWs7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIi5yZXBsYWNlKFwiLm1ldGhvZFwiLCBnZW5lcmF0ZVByb3BlcnR5QWNjZXNzKGNhbGxiYWNrKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVjZWl2ZXIgPT09IFRISVMpIHtcbiAgICAgICAgICAgIHJldCA9ICBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB7e2FyZ3N9fSwgZm4pOyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgYnJlYWs7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIjtcbiAgICAgICAgfSBlbHNlIGlmIChyZWNlaXZlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXQgPSAgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwocmVjZWl2ZXIsIHt7YXJnc319LCBmbik7ICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGJyZWFrOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSAgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHt7YXJnc319LCBmbik7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGJyZWFrOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldC5yZXBsYWNlKFwie3thcmdzfX1cIiwgYXJncykucmVwbGFjZShcIiwgXCIsIGNvbW1hKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUFyZ3VtZW50U3dpdGNoQ2FzZSgpIHtcbiAgICAgICAgdmFyIHJldCA9IFwiXCI7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmd1bWVudE9yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXQgKz0gXCJjYXNlIFwiICsgYXJndW1lbnRPcmRlcltpXSArXCI6XCIgK1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlQ2FsbEZvckFyZ3VtZW50Q291bnQoYXJndW1lbnRPcmRlcltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvZGVGb3JDYWxsO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb2RlRm9yQ2FsbCA9IFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHkuYXBwbHkodGhpcywgYXJncyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcIi5wcm9wZXJ0eVwiLCBnZW5lcmF0ZVByb3BlcnR5QWNjZXNzKGNhbGxiYWNrKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVjZWl2ZXIgPT09IFRISVMpIHtcbiAgICAgICAgICAgIGNvZGVGb3JDYWxsID0gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGVGb3JDYWxsID0gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkocmVjZWl2ZXIsIGFyZ3MpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCArPSBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBkZWZhdWx0OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGkgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgYXJnc1tpXSA9IGZuOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW0NvZGVGb3JDYWxsXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgYnJlYWs7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIi5yZXBsYWNlKFwiW0NvZGVGb3JDYWxsXVwiLCBjb2RlRm9yQ2FsbCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcIlByb21pc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY2FsbGJhY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVjZWl2ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2l0aEFwcGVuZGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1heWJlV3JhcEFzRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibm9kZWJhY2tGb3JQcm9taXNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIklOVEVSTkFMXCIsXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHZhciByZXQgPSBmdW5jdGlvbiAoUGFyYW1ldGVycykgeyAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBwcm9taXNlLl9zZXRJc1NwcmVhZGFibGUoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgZm4gPSBub2RlYmFja0ZvclByb21pc2UocHJvbWlzZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB0cnkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgc3dpdGNoKGxlbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIFtDb2RlRm9yU3dpdGNoQ2FzZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdmFyIHdyYXBwZWQgPSBtYXliZVdyYXBBc0Vycm9yKGUpOyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZSh3cmFwcGVkKTsgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHdyYXBwZWQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldC5fX2lzUHJvbWlzaWZpZWRfXyA9IHRydWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldHVybiByZXQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiXG4gICAgICAgIC5yZXBsYWNlKFwiRnVuY3Rpb25OYW1lXCIsIGNhbGxiYWNrTmFtZSlcbiAgICAgICAgLnJlcGxhY2UoXCJQYXJhbWV0ZXJzXCIsIHBhcmFtZXRlckRlY2xhcmF0aW9uKG5ld1BhcmFtZXRlckNvdW50KSlcbiAgICAgICAgLnJlcGxhY2UoXCJbQ29kZUZvclN3aXRjaENhc2VdXCIsIGdlbmVyYXRlQXJndW1lbnRTd2l0Y2hDYXNlKCkpKShcbiAgICAgICAgICAgIFByb21pc2UsXG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIHJlY2VpdmVyLFxuICAgICAgICAgICAgd2l0aEFwcGVuZGVkLFxuICAgICAgICAgICAgbWF5YmVXcmFwQXNFcnJvcixcbiAgICAgICAgICAgIG5vZGViYWNrRm9yUHJvbWlzZSxcbiAgICAgICAgICAgIElOVEVSTkFMXG4gICAgICAgICk7XG59XG5cbmZ1bmN0aW9uIG1ha2VOb2RlUHJvbWlzaWZpZWRDbG9zdXJlKGNhbGxiYWNrLCByZWNlaXZlcikge1xuICAgIGZ1bmN0aW9uIHByb21pc2lmaWVkKCkge1xuICAgICAgICB2YXIgX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gVEhJUykgX3JlY2VpdmVyID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBfcmVjZWl2ZXJbY2FsbGJhY2tdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICBwcm9taXNlLl9zZXRJc1NwcmVhZGFibGUoKTtcbiAgICAgICAgdmFyIGZuID0gbm9kZWJhY2tGb3JQcm9taXNlKHByb21pc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoX3JlY2VpdmVyLCB3aXRoQXBwZW5kZWQoYXJndW1lbnRzLCBmbikpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkID0gbWF5YmVXcmFwQXNFcnJvcihlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2Uod3JhcHBlZCk7XG4gICAgICAgICAgICBwcm9taXNlLl9yZWplY3Qod3JhcHBlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2lmaWVkLl9faXNQcm9taXNpZmllZF9fID0gdHJ1ZTtcbiAgICByZXR1cm4gcHJvbWlzaWZpZWQ7XG59XG5cbnZhciBtYWtlTm9kZVByb21pc2lmaWVkID0gY2FuRXZhbHVhdGVcbiAgICA/IG1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsXG4gICAgOiBtYWtlTm9kZVByb21pc2lmaWVkQ2xvc3VyZTtcblxuZnVuY3Rpb24gcHJvbWlzaWZ5QWxsKG9iaiwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyKSB7XG4gICAgdmFyIHN1ZmZpeFJlZ2V4cCA9IG5ldyBSZWdFeHAoZXNjYXBlSWRlbnRSZWdleChzdWZmaXgpICsgXCIkXCIpO1xuICAgIHZhciBtZXRob2RzID1cbiAgICAgICAgcHJvbWlzaWZpYWJsZU1ldGhvZHMob2JqLCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCwgZmlsdGVyKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtZXRob2RzLmxlbmd0aDsgaSA8IGxlbjsgaSs9IDIpIHtcbiAgICAgICAgdmFyIGtleSA9IG1ldGhvZHNbaV07XG4gICAgICAgIHZhciBmbiA9IG1ldGhvZHNbaSsxXTtcbiAgICAgICAgdmFyIHByb21pc2lmaWVkS2V5ID0ga2V5ICsgc3VmZml4O1xuICAgICAgICBvYmpbcHJvbWlzaWZpZWRLZXldID0gcHJvbWlzaWZpZXIgPT09IG1ha2VOb2RlUHJvbWlzaWZpZWRcbiAgICAgICAgICAgICAgICA/IG1ha2VOb2RlUHJvbWlzaWZpZWQoa2V5LCBUSElTLCBrZXksIGZuLCBzdWZmaXgpXG4gICAgICAgICAgICAgICAgOiBwcm9taXNpZmllcihmbiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTm9kZVByb21pc2lmaWVkKGtleSwgVEhJUywga2V5LCBmbiwgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZ5KGNhbGxiYWNrLCByZWNlaXZlcikge1xuICAgIHJldHVybiBtYWtlTm9kZVByb21pc2lmaWVkKGNhbGxiYWNrLCByZWNlaXZlciwgdW5kZWZpbmVkLCBjYWxsYmFjayk7XG59XG5cblByb21pc2UucHJvbWlzaWZ5ID0gZnVuY3Rpb24gKGZuLCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZm4gbXVzdCBiZSBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvOTE2bEpKXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgaWYgKGlzUHJvbWlzaWZpZWQoZm4pKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2lmeShmbiwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBUSElTIDogcmVjZWl2ZXIpO1xufTtcblxuUHJvbWlzZS5wcm9taXNpZnlBbGwgPSBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0aGUgdGFyZ2V0IG9mIHByb21pc2lmeUFsbCBtdXN0IGJlIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvOUlUbFYwXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IE9iamVjdChvcHRpb25zKTtcbiAgICB2YXIgc3VmZml4ID0gb3B0aW9ucy5zdWZmaXg7XG4gICAgaWYgKHR5cGVvZiBzdWZmaXggIT09IFwic3RyaW5nXCIpIHN1ZmZpeCA9IGRlZmF1bHRTdWZmaXg7XG4gICAgdmFyIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgIGlmICh0eXBlb2YgZmlsdGVyICE9PSBcImZ1bmN0aW9uXCIpIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgdmFyIHByb21pc2lmaWVyID0gb3B0aW9ucy5wcm9taXNpZmllcjtcbiAgICBpZiAodHlwZW9mIHByb21pc2lmaWVyICE9PSBcImZ1bmN0aW9uXCIpIHByb21pc2lmaWVyID0gbWFrZU5vZGVQcm9taXNpZmllZDtcblxuICAgIGlmICghdXRpbC5pc0lkZW50aWZpZXIoc3VmZml4KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInN1ZmZpeCBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzhGWm81VlxcdTAwMGFcIik7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSB1dGlsLmluaGVyaXRlZERhdGFLZXlzKHRhcmdldCwge2luY2x1ZGVIaWRkZW46IHRydWV9KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGFyZ2V0W2tleXNbaV1dO1xuICAgICAgICBpZiAoa2V5c1tpXSAhPT0gXCJjb25zdHJ1Y3RvclwiICYmXG4gICAgICAgICAgICB1dGlsLmlzQ2xhc3ModmFsdWUpKSB7XG4gICAgICAgICAgICBwcm9taXNpZnlBbGwodmFsdWUucHJvdG90eXBlLCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIpO1xuICAgICAgICAgICAgcHJvbWlzaWZ5QWxsKHZhbHVlLCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2lmeUFsbCh0YXJnZXQsIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllcik7XG59O1xufTtcblxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSkge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpO1xudmFyIGFwaVJlamVjdGlvbiA9IHJlcXVpcmUoXCIuL2Vycm9yc19hcGlfcmVqZWN0aW9uXCIpKFByb21pc2UpO1xudmFyIGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdDtcbnZhciBlczUgPSByZXF1aXJlKFwiLi9lczUuanNcIik7XG5cbmZ1bmN0aW9uIFByb3BlcnRpZXNQcm9taXNlQXJyYXkob2JqKSB7XG4gICAgdmFyIGtleXMgPSBlczUua2V5cyhvYmopO1xuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXldO1xuICAgICAgICB2YWx1ZXNbaSArIGxlbl0gPSBrZXk7XG4gICAgfVxuICAgIHRoaXMuY29uc3RydWN0b3IkKHZhbHVlcyk7XG59XG51dGlsLmluaGVyaXRzKFByb3BlcnRpZXNQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTMpIDtcbn07XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbCA9IHt9O1xuICAgICAgICB2YXIga2V5T2Zmc2V0ID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoKCk7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdmFsW3RoaXMuX3ZhbHVlc1tpICsga2V5T2Zmc2V0XV0gPSB0aGlzLl92YWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh2YWwpO1xuICAgIH1cbn07XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUHJvZ3Jlc3NlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB0aGlzLl9wcm9taXNlLl9wcm9ncmVzcyh7XG4gICAgICAgIGtleTogdGhpcy5fdmFsdWVzW2luZGV4ICsgdGhpcy5sZW5ndGgoKV0sXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xufTtcblxuUHJvcGVydGllc1Byb21pc2VBcnJheS5wcm90b3R5cGUuc2hvdWxkQ29weVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5nZXRBY3R1YWxMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgcmV0dXJuIGxlbiA+PiAxO1xufTtcblxuZnVuY3Rpb24gcHJvcHMocHJvbWlzZXMpIHtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBjYXN0VmFsdWUgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHByb21pc2VzLCB1bmRlZmluZWQpO1xuXG4gICAgaWYgKCFpc09iamVjdChjYXN0VmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJjYW5ub3QgYXdhaXQgcHJvcGVydGllcyBvZiBhIG5vbi1vYmplY3RcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9Pc0ZLQzhcXHUwMDBhXCIpO1xuICAgIH0gZWxzZSBpZiAoY2FzdFZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXQgPSBjYXN0VmFsdWUuX3RoZW4oXG4gICAgICAgICAgICBQcm9taXNlLnByb3BzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IG5ldyBQcm9wZXJ0aWVzUHJvbWlzZUFycmF5KGNhc3RWYWx1ZSkucHJvbWlzZSgpO1xuICAgIH1cblxuICAgIGlmIChjYXN0VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldC5fcHJvcGFnYXRlRnJvbShjYXN0VmFsdWUsIDQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5wcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvcHModGhpcyk7XG59O1xuXG5Qcm9taXNlLnByb3BzID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHByb3BzKHByb21pc2VzKTtcbn07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBhcnJheU1vdmUoc3JjLCBzcmNJbmRleCwgZHN0LCBkc3RJbmRleCwgbGVuKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47ICsraikge1xuICAgICAgICBkc3RbaiArIGRzdEluZGV4XSA9IHNyY1tqICsgc3JjSW5kZXhdO1xuICAgICAgICBzcmNbaiArIHNyY0luZGV4XSA9IHZvaWQgMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIFF1ZXVlKGNhcGFjaXR5KSB7XG4gICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX2Zyb250ID0gMDtcbn1cblxuUXVldWUucHJvdG90eXBlLl93aWxsQmVPdmVyQ2FwYWNpdHkgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLl9jYXBhY2l0eSA8IHNpemU7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX3B1c2hPbmUgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGggKyAxKTtcbiAgICB2YXIgaSA9ICh0aGlzLl9mcm9udCArIGxlbmd0aCkgJiAodGhpcy5fY2FwYWNpdHkgLSAxKTtcbiAgICB0aGlzW2ldID0gYXJnO1xuICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aCArIDE7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX3Vuc2hpZnRPbmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBjYXBhY2l0eSA9IHRoaXMuX2NhcGFjaXR5O1xuICAgIHRoaXMuX2NoZWNrQ2FwYWNpdHkodGhpcy5sZW5ndGgoKSArIDEpO1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgIHZhciBpID0gKCgoKCBmcm9udCAtIDEgKSAmXG4gICAgICAgICAgICAgICAgICAgICggY2FwYWNpdHkgLSAxKSApIF4gY2FwYWNpdHkgKSAtIGNhcGFjaXR5ICk7XG4gICAgdGhpc1tpXSA9IHZhbHVlO1xuICAgIHRoaXMuX2Zyb250ID0gaTtcbiAgICB0aGlzLl9sZW5ndGggPSB0aGlzLmxlbmd0aCgpICsgMTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICB0aGlzLl91bnNoaWZ0T25lKGFyZyk7XG4gICAgdGhpcy5fdW5zaGlmdE9uZShyZWNlaXZlcik7XG4gICAgdGhpcy5fdW5zaGlmdE9uZShmbik7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpICsgMztcbiAgICBpZiAodGhpcy5fd2lsbEJlT3ZlckNhcGFjaXR5KGxlbmd0aCkpIHtcbiAgICAgICAgdGhpcy5fcHVzaE9uZShmbik7XG4gICAgICAgIHRoaXMuX3B1c2hPbmUocmVjZWl2ZXIpO1xuICAgICAgICB0aGlzLl9wdXNoT25lKGFyZyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGogPSB0aGlzLl9mcm9udCArIGxlbmd0aCAtIDM7XG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGgpO1xuICAgIHZhciB3cmFwTWFzayA9IHRoaXMuX2NhcGFjaXR5IC0gMTtcbiAgICB0aGlzWyhqICsgMCkgJiB3cmFwTWFza10gPSBmbjtcbiAgICB0aGlzWyhqICsgMSkgJiB3cmFwTWFza10gPSByZWNlaXZlcjtcbiAgICB0aGlzWyhqICsgMikgJiB3cmFwTWFza10gPSBhcmc7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xufTtcblxuUXVldWUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250LFxuICAgICAgICByZXQgPSB0aGlzW2Zyb250XTtcblxuICAgIHRoaXNbZnJvbnRdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Zyb250ID0gKGZyb250ICsgMSkgJiAodGhpcy5fY2FwYWNpdHkgLSAxKTtcbiAgICB0aGlzLl9sZW5ndGgtLTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUXVldWUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xufTtcblxuUXVldWUucHJvdG90eXBlLl9jaGVja0NhcGFjaXR5ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICBpZiAodGhpcy5fY2FwYWNpdHkgPCBzaXplKSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVRvKHRoaXMuX2NhcGFjaXR5IDw8IDEpO1xuICAgIH1cbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fcmVzaXplVG8gPSBmdW5jdGlvbiAoY2FwYWNpdHkpIHtcbiAgICB2YXIgb2xkQ2FwYWNpdHkgPSB0aGlzLl9jYXBhY2l0eTtcbiAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGg7XG4gICAgaWYgKGZyb250ICsgbGVuZ3RoID4gb2xkQ2FwYWNpdHkpIHtcbiAgICAgICAgdmFyIG1vdmVJdGVtc0NvdW50ID0gKGZyb250ICsgbGVuZ3RoKSAmIChvbGRDYXBhY2l0eSAtIDEpO1xuICAgICAgICBhcnJheU1vdmUodGhpcywgMCwgdGhpcywgb2xkQ2FwYWNpdHksIG1vdmVJdGVtc0NvdW50KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXVlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlKSB7XG52YXIgYXBpUmVqZWN0aW9uID0gcmVxdWlyZShcIi4vZXJyb3JzX2FwaV9yZWplY3Rpb24uanNcIikoUHJvbWlzZSk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIikuaXNBcnJheTtcblxudmFyIHJhY2VMYXRlciA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihhcnJheSkge1xuICAgICAgICByZXR1cm4gcmFjZShhcnJheSwgcHJvbWlzZSk7XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiByYWNlKHByb21pc2VzLCBwYXJlbnQpIHtcbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShwcm9taXNlcywgdW5kZWZpbmVkKTtcblxuICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiByYWNlTGF0ZXIobWF5YmVQcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKCFpc0FycmF5KHByb21pc2VzKSkge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGFuIGFycmF5LCBhIHByb21pc2Ugb3IgYSB0aGVuYWJsZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL3M4TU1oY1xcdTAwMGFcIik7XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICBpZiAocGFyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0Ll9wcm9wYWdhdGVGcm9tKHBhcmVudCwgNCB8IDEpO1xuICAgIH1cbiAgICB2YXIgZnVsZmlsbCA9IHJldC5fZnVsZmlsbDtcbiAgICB2YXIgcmVqZWN0ID0gcmV0Ll9yZWplY3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb21pc2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciB2YWwgPSBwcm9taXNlc1tpXTtcblxuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQgJiYgIShpIGluIHByb21pc2VzKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBQcm9taXNlLmNhc3QodmFsKS5fdGhlbihmdWxmaWxsLCByZWplY3QsIHVuZGVmaW5lZCwgcmV0LCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHJhY2UocHJvbWlzZXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByYWNlKHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2VBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVqZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTCkge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpO1xudmFyIHRyeUNhdGNoNCA9IHV0aWwudHJ5Q2F0Y2g0O1xudmFyIHRyeUNhdGNoMyA9IHV0aWwudHJ5Q2F0Y2gzO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbmZ1bmN0aW9uIFJlZHVjdGlvblByb21pc2VBcnJheShwcm9taXNlcywgZm4sIGFjY3VtLCBfZWFjaCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHByb21pc2VzKTtcbiAgICB0aGlzLl9wcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHRoaXMuX3ByZXNlcnZlZFZhbHVlcyA9IF9lYWNoID09PSBJTlRFUk5BTCA/IFtdIDogbnVsbDtcbiAgICB0aGlzLl96ZXJvdGhJc0FjY3VtID0gKGFjY3VtID09PSB1bmRlZmluZWQpO1xuICAgIHRoaXMuX2dvdEFjY3VtID0gZmFsc2U7XG4gICAgdGhpcy5fcmVkdWNpbmdJbmRleCA9ICh0aGlzLl96ZXJvdGhJc0FjY3VtID8gMSA6IDApO1xuICAgIHRoaXMuX3ZhbHVlc1BoYXNlID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UoYWNjdW0sIHVuZGVmaW5lZCk7XG4gICAgdmFyIHJlamVjdGVkID0gZmFsc2U7XG4gICAgdmFyIGlzUHJvbWlzZSA9IG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2U7XG4gICAgaWYgKGlzUHJvbWlzZSkge1xuICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlLl9pc1BlbmRpbmcoKSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9wcm94eVByb21pc2VBcnJheSh0aGlzLCAtMSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF5YmVQcm9taXNlLl9pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICBhY2N1bSA9IG1heWJlUHJvbWlzZS5fdmFsdWUoKTtcbiAgICAgICAgICAgIHRoaXMuX2dvdEFjY3VtID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0KG1heWJlUHJvbWlzZS5fcmVhc29uKCkpO1xuICAgICAgICAgICAgcmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghKGlzUHJvbWlzZSB8fCB0aGlzLl96ZXJvdGhJc0FjY3VtKSkgdGhpcy5fZ290QWNjdW0gPSB0cnVlO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gZm47XG4gICAgdGhpcy5fYWNjdW0gPSBhY2N1bTtcbiAgICBpZiAoIXJlamVjdGVkKSB0aGlzLl9pbml0JCh1bmRlZmluZWQsIC01KTtcbn1cbnV0aWwuaW5oZXJpdHMoUmVkdWN0aW9uUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge307XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmVFbXB0eUFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9nb3RBY2N1bSB8fCB0aGlzLl96ZXJvdGhJc0FjY3VtKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fcHJlc2VydmVkVmFsdWVzICE9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdIDogdGhpcy5fYWNjdW0pO1xuICAgIH1cbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgdmFyIHByZXNlcnZlZFZhbHVlcyA9IHRoaXMuX3ByZXNlcnZlZFZhbHVlcztcbiAgICB2YXIgaXNFYWNoID0gcHJlc2VydmVkVmFsdWVzICE9PSBudWxsO1xuICAgIHZhciBnb3RBY2N1bSA9IHRoaXMuX2dvdEFjY3VtO1xuICAgIHZhciB2YWx1ZXNQaGFzZSA9IHRoaXMuX3ZhbHVlc1BoYXNlO1xuICAgIHZhciB2YWx1ZXNQaGFzZUluZGV4O1xuICAgIGlmICghdmFsdWVzUGhhc2UpIHtcbiAgICAgICAgdmFsdWVzUGhhc2UgPSB0aGlzLl92YWx1ZXNQaGFzZSA9IEFycmF5KGxlbmd0aCk7XG4gICAgICAgIGZvciAodmFsdWVzUGhhc2VJbmRleD0wOyB2YWx1ZXNQaGFzZUluZGV4PGxlbmd0aDsgKyt2YWx1ZXNQaGFzZUluZGV4KSB7XG4gICAgICAgICAgICB2YWx1ZXNQaGFzZVt2YWx1ZXNQaGFzZUluZGV4XSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsdWVzUGhhc2VJbmRleCA9IHZhbHVlc1BoYXNlW2luZGV4XTtcblxuICAgIGlmIChpbmRleCA9PT0gMCAmJiB0aGlzLl96ZXJvdGhJc0FjY3VtKSB7XG4gICAgICAgIGlmICghZ290QWNjdW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2FjY3VtID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9nb3RBY2N1bSA9IGdvdEFjY3VtID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNQaGFzZVtpbmRleF0gPSAoKHZhbHVlc1BoYXNlSW5kZXggPT09IDApXG4gICAgICAgICAgICA/IDEgOiAyKTtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICBpZiAoIWdvdEFjY3VtKSB7XG4gICAgICAgICAgICB0aGlzLl9hY2N1bSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fZ290QWNjdW0gPSBnb3RBY2N1bSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsdWVzUGhhc2VJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgdmFsdWVzUGhhc2VbaW5kZXhdID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlc1BoYXNlW2luZGV4XSA9IDI7XG4gICAgICAgICAgICBpZiAoZ290QWNjdW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY2N1bSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghZ290QWNjdW0pIHJldHVybjtcblxuICAgIHZhciBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrO1xuICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3Byb21pc2UuX2JvdW5kVG87XG4gICAgdmFyIHJldDtcblxuICAgIGZvciAodmFyIGkgPSB0aGlzLl9yZWR1Y2luZ0luZGV4OyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFsdWVzUGhhc2VJbmRleCA9IHZhbHVlc1BoYXNlW2ldO1xuICAgICAgICBpZiAodmFsdWVzUGhhc2VJbmRleCA9PT0gMikge1xuICAgICAgICAgICAgdGhpcy5fcmVkdWNpbmdJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlc1BoYXNlSW5kZXggIT09IDEpIHJldHVybjtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuX3RhcmdldCgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLl9pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5fdmFsdWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUuX2lzUGVuZGluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWplY3QodmFsdWUuX3JlYXNvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIGlmIChpc0VhY2gpIHtcbiAgICAgICAgICAgIHByZXNlcnZlZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJldCA9IHRyeUNhdGNoMyhjYWxsYmFjaywgcmVjZWl2ZXIsIHZhbHVlLCBpLCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gdHJ5Q2F0Y2g0KGNhbGxiYWNrLCByZWNlaXZlciwgdGhpcy5fYWNjdW0sIHZhbHVlLCBpLCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3BvcENvbnRleHQoKTtcblxuICAgICAgICBpZiAocmV0ID09PSBlcnJvck9iaikgcmV0dXJuIHRoaXMuX3JlamVjdChyZXQuZSk7XG5cbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmV0LCB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlLl9pc1BlbmRpbmcoKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlc1BoYXNlW2ldID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlLl9wcm94eVByb21pc2VBcnJheSh0aGlzLCBpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF5YmVQcm9taXNlLl9pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbWF5YmVQcm9taXNlLl92YWx1ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0KG1heWJlUHJvbWlzZS5fcmVhc29uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVkdWNpbmdJbmRleCA9IGkgKyAxO1xuICAgICAgICB0aGlzLl9hY2N1bSA9IHJldDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVkdWNpbmdJbmRleCA8IGxlbmd0aCkgcmV0dXJuO1xuICAgIHRoaXMuX3Jlc29sdmUoaXNFYWNoID8gcHJlc2VydmVkVmFsdWVzIDogdGhpcy5fYWNjdW0pO1xufTtcblxuZnVuY3Rpb24gcmVkdWNlKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCkge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGFwaVJlamVjdGlvbihcImZuIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzkxNmxKSlxcdTAwMGFcIik7XG4gICAgdmFyIGFycmF5ID0gbmV3IFJlZHVjdGlvblByb21pc2VBcnJheShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpO1xuICAgIHJldHVybiBhcnJheS5wcm9taXNlKCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgcmV0dXJuIHJlZHVjZSh0aGlzLCBmbiwgaW5pdGlhbFZhbHVlLCBudWxsKTtcbn07XG5cblByb21pc2UucmVkdWNlID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCkge1xuICAgIHJldHVybiByZWR1Y2UocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKTtcbn07XG59O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcblwidXNlIHN0cmljdFwiO1xudmFyIHNjaGVkdWxlO1xuaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICBzY2hlZHVsZSA9IHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbi5zcGxpdChcIi5cIilbMV0sIDEwKSA+IDEwXG4gICAgICAgID8gc2V0SW1tZWRpYXRlIDogcHJvY2Vzcy5uZXh0VGljaztcbn1cbmVsc2UgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbihmbikge1xuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZm4pO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGRpdiwge2F0dHJpYnV0ZXM6IHRydWV9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyBkaXYuY2xhc3NMaXN0LnRvZ2dsZShcImZvb1wiKTsgfTtcbiAgICB9O1xuICAgIHNjaGVkdWxlLmlzU3RhdGljID0gdHJ1ZTtcbn1cbmVsc2UgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn1cbmVsc2Uge1xuICAgIHNjaGVkdWxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFzeW5jIHNjaGVkdWxlciBhdmFpbGFibGVcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9tM09UWGtcXHUwMDBhXCIpO1xuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IHNjaGVkdWxlO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbiAgICBmdW5jdGlvbihQcm9taXNlLCBQcm9taXNlQXJyYXkpIHtcbnZhciBQcm9taXNlSW5zcGVjdGlvbiA9IFByb21pc2UuUHJvbWlzZUluc3BlY3Rpb247XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIik7XG5cbmZ1bmN0aW9uIFNldHRsZWRQcm9taXNlQXJyYXkodmFsdWVzKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQodmFsdWVzKTtcbiAgICB0aGlzLl9wcm9taXNlLl9zZXRJc1NwcmVhZGFibGUoKTtcbn1cbnV0aWwuaW5oZXJpdHMoU2V0dGxlZFByb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuU2V0dGxlZFByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZXNvbHZlZCA9IGZ1bmN0aW9uIChpbmRleCwgaW5zcGVjdGlvbikge1xuICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSBpbnNwZWN0aW9uO1xuICAgIHZhciB0b3RhbFJlc29sdmVkID0gKyt0aGlzLl90b3RhbFJlc29sdmVkO1xuICAgIGlmICh0b3RhbFJlc29sdmVkID49IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyk7XG4gICAgfVxufTtcblxuU2V0dGxlZFByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlSW5zcGVjdGlvbigpO1xuICAgIHJldC5fYml0RmllbGQgPSAyNjg0MzU0NTY7XG4gICAgcmV0Ll9zZXR0bGVkVmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLl9wcm9taXNlUmVzb2x2ZWQoaW5kZXgsIHJldCk7XG59O1xuU2V0dGxlZFByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24sIGluZGV4KSB7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlSW5zcGVjdGlvbigpO1xuICAgIHJldC5fYml0RmllbGQgPSAxMzQyMTc3Mjg7XG4gICAgcmV0Ll9zZXR0bGVkVmFsdWUgPSByZWFzb247XG4gICAgdGhpcy5fcHJvbWlzZVJlc29sdmVkKGluZGV4LCByZXQpO1xufTtcblxuUHJvbWlzZS5zZXR0bGUgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gbmV3IFNldHRsZWRQcm9taXNlQXJyYXkocHJvbWlzZXMpLnByb21pc2UoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNldHRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNldHRsZWRQcm9taXNlQXJyYXkodGhpcykucHJvbWlzZSgpO1xufTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbmZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIik7XG52YXIgUmFuZ2VFcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKS5SYW5nZUVycm9yO1xudmFyIEFnZ3JlZ2F0ZUVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLkFnZ3JlZ2F0ZUVycm9yO1xudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG5cblxuZnVuY3Rpb24gU29tZVByb21pc2VBcnJheSh2YWx1ZXMpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yJCh2YWx1ZXMpO1xuICAgIHRoaXMuX2hvd01hbnkgPSAwO1xuICAgIHRoaXMuX3Vud3JhcCA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG59XG51dGlsLmluaGVyaXRzKFNvbWVQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9wcm9taXNlLl9zZXRJc1NwcmVhZGFibGUoKTtcbiAgICBpZiAodGhpcy5faG93TWFueSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKFtdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIC01KTtcbiAgICB2YXIgaXNBcnJheVJlc29sdmVkID0gaXNBcnJheSh0aGlzLl92YWx1ZXMpO1xuICAgIGlmICghdGhpcy5faXNSZXNvbHZlZCgpICYmXG4gICAgICAgIGlzQXJyYXlSZXNvbHZlZCAmJlxuICAgICAgICB0aGlzLl9ob3dNYW55ID4gdGhpcy5fY2FuUG9zc2libHlGdWxmaWxsKCkpIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KHRoaXMuX2dldFJhbmdlRXJyb3IodGhpcy5sZW5ndGgoKSkpO1xuICAgIH1cbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2luaXQoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLnNldFVud3JhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl91bndyYXAgPSB0cnVlO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuaG93TWFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faG93TWFueTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLnNldEhvd01hbnkgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgdGhpcy5faG93TWFueSA9IGNvdW50O1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLl9hZGRGdWxmaWxsZWQodmFsdWUpO1xuICAgIGlmICh0aGlzLl9mdWxmaWxsZWQoKSA9PT0gdGhpcy5ob3dNYW55KCkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IHRoaXMuaG93TWFueSgpO1xuICAgICAgICBpZiAodGhpcy5ob3dNYW55KCkgPT09IDEgJiYgdGhpcy5fdW53cmFwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX2FkZFJlamVjdGVkKHJlYXNvbik7XG4gICAgaWYgKHRoaXMuaG93TWFueSgpID4gdGhpcy5fY2FuUG9zc2libHlGdWxmaWxsKCkpIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgQWdncmVnYXRlRXJyb3IoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoKCk7IGkgPCB0aGlzLl92YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGUucHVzaCh0aGlzLl92YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlamVjdChlKTtcbiAgICB9XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl90b3RhbFJlc29sdmVkO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3JlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXMubGVuZ3RoIC0gdGhpcy5sZW5ndGgoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9hZGRSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl92YWx1ZXMucHVzaChyZWFzb24pO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2FkZEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlc1t0aGlzLl90b3RhbFJlc29sdmVkKytdID0gdmFsdWU7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fY2FuUG9zc2libHlGdWxmaWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCgpIC0gdGhpcy5fcmVqZWN0ZWQoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9nZXRSYW5nZUVycm9yID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBcIklucHV0IGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBcIiArXG4gICAgICAgICAgICB0aGlzLl9ob3dNYW55ICsgXCIgaXRlbXMgYnV0IGNvbnRhaW5zIG9ubHkgXCIgKyBjb3VudCArIFwiIGl0ZW1zXCI7XG4gICAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKG1lc3NhZ2UpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmVFbXB0eUFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3JlamVjdCh0aGlzLl9nZXRSYW5nZUVycm9yKDApKTtcbn07XG5cbmZ1bmN0aW9uIHNvbWUocHJvbWlzZXMsIGhvd01hbnkpIHtcbiAgICBpZiAoKGhvd01hbnkgfCAwKSAhPT0gaG93TWFueSB8fCBob3dNYW55IDwgMCkge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgcG9zaXRpdmUgaW50ZWdlclxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzF3QW1IeFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciByZXQgPSBuZXcgU29tZVByb21pc2VBcnJheShwcm9taXNlcyk7XG4gICAgdmFyIHByb21pc2UgPSByZXQucHJvbWlzZSgpO1xuICAgIGlmIChwcm9taXNlLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcmV0LnNldEhvd01hbnkoaG93TWFueSk7XG4gICAgcmV0LmluaXQoKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuUHJvbWlzZS5zb21lID0gZnVuY3Rpb24gKHByb21pc2VzLCBob3dNYW55KSB7XG4gICAgcmV0dXJuIHNvbWUocHJvbWlzZXMsIGhvd01hbnkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uIChob3dNYW55KSB7XG4gICAgcmV0dXJuIHNvbWUodGhpcywgaG93TWFueSk7XG59O1xuXG5Qcm9taXNlLl9Tb21lUHJvbWlzZUFycmF5ID0gU29tZVByb21pc2VBcnJheTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xuZnVuY3Rpb24gUHJvbWlzZUluc3BlY3Rpb24ocHJvbWlzZSkge1xuICAgIGlmIChwcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvbWlzZSA9IHByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICB0aGlzLl9zZXR0bGVkVmFsdWUgPSBwcm9taXNlLl9pc1Jlc29sdmVkKClcbiAgICAgICAgICAgID8gcHJvbWlzZS5fc2V0dGxlZFZhbHVlXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gMDtcbiAgICAgICAgdGhpcy5fc2V0dGxlZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgZ2V0IGZ1bGZpbGxtZW50IHZhbHVlIG9mIGEgbm9uLWZ1bGZpbGxlZCBwcm9taXNlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvaGMxRExqXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZTtcbn07XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5lcnJvciA9XG5Qcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUucmVhc29uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBnZXQgcmVqZWN0aW9uIHJlYXNvbiBvZiBhIG5vbi1yZWplY3RlZCBwcm9taXNlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvaFB1aXdCXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZTtcbn07XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc0Z1bGZpbGxlZCA9XG5Qcm9taXNlLnByb3RvdHlwZS5faXNGdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDI2ODQzNTQ1NikgPiAwO1xufTtcblxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUmVqZWN0ZWQgPVxuUHJvbWlzZS5wcm90b3R5cGUuX2lzUmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDEzNDIxNzcyOCkgPiAwO1xufTtcblxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUGVuZGluZyA9XG5Qcm9taXNlLnByb3RvdHlwZS5faXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA0MDI2NTMxODQpID09PSAwO1xufTtcblxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUmVzb2x2ZWQgPVxuUHJvbWlzZS5wcm90b3R5cGUuX2lzUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDQwMjY1MzE4NCkgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldCgpLl9pc1BlbmRpbmcoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0KCkuX2lzUmVqZWN0ZWQoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldCgpLl9pc0Z1bGZpbGxlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZXNvbHZlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXQoKS5faXNSZXNvbHZlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3ZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWFzb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0KCk7XG4gICAgaWYgKCF0YXJnZXQuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IGdldCBmdWxmaWxsbWVudCB2YWx1ZSBvZiBhIG5vbi1mdWxmaWxsZWQgcHJvbWlzZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL2hjMURMalxcdTAwMGFcIik7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQuX3NldHRsZWRWYWx1ZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnJlYXNvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICBpZiAoIXRhcmdldC5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBnZXQgcmVqZWN0aW9uIHJlYXNvbiBvZiBhIG5vbi1yZWplY3RlZCBwcm9taXNlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvaFB1aXdCXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldC5fc2V0dGxlZFZhbHVlO1xufTtcblxuXG5Qcm9taXNlLlByb21pc2VJbnNwZWN0aW9uID0gUHJvbWlzZUluc3BlY3Rpb247XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIik7XG52YXIgY2FuQXR0YWNoVHJhY2UgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIikuY2FuQXR0YWNoVHJhY2U7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdDtcblxuZnVuY3Rpb24gZ2V0VGhlbihvYmopIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gb2JqLnRoZW47XG4gICAgfVxuICAgIGNhdGNoKGUpIHtcbiAgICAgICAgZXJyb3JPYmouZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyeUNvbnZlcnRUb1Byb21pc2Uob2JqLCB0cmFjZVBhcmVudCkge1xuICAgIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQW55Qmx1ZWJpcmRQcm9taXNlKG9iaikpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgICAgICBvYmouX3RoZW4oXG4gICAgICAgICAgICAgICAgcmV0Ll9mdWxmaWxsVW5jaGVja2VkLFxuICAgICAgICAgICAgICAgIHJldC5fcmVqZWN0VW5jaGVja2VkQ2hlY2tFcnJvcixcbiAgICAgICAgICAgICAgICByZXQuX3Byb2dyZXNzVW5jaGVja2VkLFxuICAgICAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhlbiA9IGdldFRoZW4ob2JqKTtcbiAgICAgICAgaWYgKHRoZW4gPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICBpZiAodHJhY2VQYXJlbnQgIT09IHVuZGVmaW5lZCAmJiBjYW5BdHRhY2hUcmFjZSh0aGVuLmUpKSB7XG4gICAgICAgICAgICAgICAgdHJhY2VQYXJlbnQuX2F0dGFjaEV4dHJhVHJhY2UodGhlbi5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGVuLmUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkb1RoZW5hYmxlKG9iaiwgdGhlbiwgdHJhY2VQYXJlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbnZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBpc0FueUJsdWViaXJkUHJvbWlzZShvYmopIHtcbiAgICByZXR1cm4gaGFzUHJvcC5jYWxsKG9iaiwgXCJfcHJvbWlzZTBcIik7XG59XG5cbmZ1bmN0aW9uIGRvVGhlbmFibGUoeCwgdGhlbiwgdHJhY2VQYXJlbnQpIHtcbiAgICB2YXIgcmVzb2x2ZXIgPSBQcm9taXNlLmRlZmVyKCk7XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIHRoZW4uY2FsbChcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICByZXNvbHZlRnJvbVRoZW5hYmxlLFxuICAgICAgICAgICAgcmVqZWN0RnJvbVRoZW5hYmxlLFxuICAgICAgICAgICAgcHJvZ3Jlc3NGcm9tVGhlbmFibGVcbiAgICAgICAgKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgdHJhY2UgPSBjYW5BdHRhY2hUcmFjZShlKSA/IGUgOiBuZXcgRXJyb3IodXRpbC50b1N0cmluZyhlKSk7XG4gICAgICAgICAgICBpZiAodHJhY2VQYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRyYWNlUGFyZW50Ll9hdHRhY2hFeHRyYVRyYWNlKHRyYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmVyLnByb21pc2UuX3JlamVjdChlLCB0cmFjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmVyLnByb21pc2U7XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlRnJvbVRoZW5hYmxlKHkpIHtcbiAgICAgICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgICAgICB2YXIgZSA9IFByb21pc2UuX21ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCk7XG4gICAgICAgICAgICBpZiAodHJhY2VQYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRyYWNlUGFyZW50Ll9hdHRhY2hFeHRyYVRyYWNlKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZXIucHJvbWlzZS5fcmVqZWN0KGUsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZXIucmVzb2x2ZSh5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWplY3RGcm9tVGhlbmFibGUocikge1xuICAgICAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIHZhciB0cmFjZSA9IGNhbkF0dGFjaFRyYWNlKHIpID8gciA6IG5ldyBFcnJvcih1dGlsLnRvU3RyaW5nKHIpKTtcbiAgICAgICAgaWYgKHRyYWNlUGFyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyYWNlUGFyZW50Ll9hdHRhY2hFeHRyYVRyYWNlKHRyYWNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlci5wcm9taXNlLl9yZWplY3QociwgdHJhY2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2dyZXNzRnJvbVRoZW5hYmxlKHYpIHtcbiAgICAgICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHJlc29sdmVyLnByb21pc2U7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvbWlzZS5fcHJvZ3Jlc3MgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcHJvbWlzZS5fcHJvZ3Jlc3Modik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnJldHVybiB0cnlDb252ZXJ0VG9Qcm9taXNlO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSkge1xudmFyIGVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbnZhciBUaW1lb3V0RXJyb3IgPSBQcm9taXNlLlRpbWVvdXRFcnJvcjtcblxudmFyIGFmdGVyVGltZW91dCA9IGZ1bmN0aW9uIChwcm9taXNlLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFwcm9taXNlLmlzUGVuZGluZygpKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIm9wZXJhdGlvbiB0aW1lZCBvdXRcIjtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBUaW1lb3V0RXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3JzLm1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihlcnIpO1xuICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICBwcm9taXNlLl9jYW5jZWwoZXJyKTtcbn07XG5cbnZhciBhZnRlckRlbGF5ID0gZnVuY3Rpb24gKHZhbHVlLCBwcm9taXNlKSB7XG4gICAgcHJvbWlzZS5fZnVsZmlsbCh2YWx1ZSk7XG59O1xuXG52YXIgZGVsYXkgPSBQcm9taXNlLmRlbGF5ID0gZnVuY3Rpb24gKHZhbHVlLCBtcykge1xuICAgIGlmIChtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1zID0gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBtcyA9ICttcztcbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZSwgdW5kZWZpbmVkKTtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcblxuICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UuX3Byb3BhZ2F0ZUZyb20obWF5YmVQcm9taXNlLCA0IHwgMSk7XG4gICAgICAgIHByb21pc2UuX2ZvbGxvdyhtYXliZVByb21pc2UuX3RhcmdldCgpKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuZGVsYXkodmFsdWUsIG1zKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiBkZWxheVRpbWVvdXQoKSB7XG4gICAgICAgICAgICBhZnRlckRlbGF5KHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSwgbXMpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKG1zKSB7XG4gICAgcmV0dXJuIGRlbGF5KHRoaXMsIG1zKTtcbn07XG5cbmZ1bmN0aW9uIHN1Y2Nlc3NDbGVhcih2YWx1ZSkge1xuICAgIHZhciBoYW5kbGUgPSB0aGlzO1xuICAgIGlmIChoYW5kbGUgaW5zdGFuY2VvZiBOdW1iZXIpIGhhbmRsZSA9ICtoYW5kbGU7XG4gICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBmYWlsdXJlQ2xlYXIocmVhc29uKSB7XG4gICAgdmFyIGhhbmRsZSA9IHRoaXM7XG4gICAgaWYgKGhhbmRsZSBpbnN0YW5jZW9mIE51bWJlcikgaGFuZGxlID0gK2hhbmRsZTtcbiAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICB0aHJvdyByZWFzb247XG59XG5cblByb21pc2UucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMsIG1lc3NhZ2UpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0KCk7XG4gICAgbXMgPSArbXM7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKS5jYW5jZWxsYWJsZSgpO1xuICAgIHJldC5fcHJvcGFnYXRlRnJvbSh0aGlzLCA0IHwgMSk7XG4gICAgcmV0Ll9mb2xsb3codGFyZ2V0KTtcbiAgICB2YXIgaGFuZGxlID0gc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0VGltZW91dCgpIHtcbiAgICAgICAgYWZ0ZXJUaW1lb3V0KHJldCwgbWVzc2FnZSk7XG4gICAgfSwgbXMpO1xuICAgIHJldHVybiByZXQuX3RoZW4oc3VjY2Vzc0NsZWFyLCBmYWlsdXJlQ2xlYXIsIHVuZGVmaW5lZCwgaGFuZGxlLCB1bmRlZmluZWQpO1xufTtcblxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgIGNyZWF0ZUNvbnRleHQpIHtcbiAgICB2YXIgVHlwZUVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLlR5cGVFcnJvcjtcbiAgICB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpLmluaGVyaXRzO1xuICAgIHZhciBQcm9taXNlSW5zcGVjdGlvbiA9IFByb21pc2UuUHJvbWlzZUluc3BlY3Rpb247XG5cbiAgICBmdW5jdGlvbiBpbnNwZWN0aW9uTWFwcGVyKGluc3BlY3Rpb25zKSB7XG4gICAgICAgIHZhciBsZW4gPSBpbnNwZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpbnNwZWN0aW9uID0gaW5zcGVjdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAoaW5zcGVjdGlvbi5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoaW5zcGVjdGlvbi5lcnJvcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3BlY3Rpb25zW2ldID0gaW5zcGVjdGlvbi5fc2V0dGxlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNwZWN0aW9ucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aHJvd2VyKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGU7fSwgMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FzdFByZXNlcnZpbmdEaXNwb3NhYmxlKHRoZW5hYmxlKSB7XG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoZW5hYmxlLCB1bmRlZmluZWQpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlICE9PSB0aGVuYWJsZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLl9pc0Rpc3Bvc2FibGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLl9nZXREaXNwb3NlciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0aGVuYWJsZS5faXNEaXNwb3NhYmxlKCkpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fc2V0RGlzcG9zYWJsZSh0aGVuYWJsZS5fZ2V0RGlzcG9zZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcG9zZShyZXNvdXJjZXMsIGluc3BlY3Rpb24pIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gcmVzb3VyY2VzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJldCA9IFByb21pc2UuZGVmZXIoKTtcbiAgICAgICAgZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBsZW4pIHJldHVybiByZXQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGNhc3RQcmVzZXJ2aW5nRGlzcG9zYWJsZShyZXNvdXJjZXNbaSsrXSk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSAmJlxuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5faXNEaXNwb3NhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9nZXREaXNwb3NlcigpLnRyeURpc3Bvc2UoaW5zcGVjdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRocm93ZXIoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXliZVByb21pc2UuX3RoZW4oaXRlcmF0b3IsIHRocm93ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlcmF0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRvcigpO1xuICAgICAgICByZXR1cm4gcmV0LnByb21pc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzcG9zZXJTdWNjZXNzKHZhbHVlKSB7XG4gICAgICAgIHZhciBpbnNwZWN0aW9uID0gbmV3IFByb21pc2VJbnNwZWN0aW9uKCk7XG4gICAgICAgIGluc3BlY3Rpb24uX3NldHRsZWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBpbnNwZWN0aW9uLl9iaXRGaWVsZCA9IDI2ODQzNTQ1NjtcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2UodGhpcywgaW5zcGVjdGlvbikudGhlblJldHVybih2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzcG9zZXJGYWlsKHJlYXNvbikge1xuICAgICAgICB2YXIgaW5zcGVjdGlvbiA9IG5ldyBQcm9taXNlSW5zcGVjdGlvbigpO1xuICAgICAgICBpbnNwZWN0aW9uLl9zZXR0bGVkVmFsdWUgPSByZWFzb247XG4gICAgICAgIGluc3BlY3Rpb24uX2JpdEZpZWxkID0gMTM0MjE3NzI4O1xuICAgICAgICByZXR1cm4gZGlzcG9zZSh0aGlzLCBpbnNwZWN0aW9uKS50aGVuVGhyb3cocmVhc29uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEaXNwb3NlcihkYXRhLCBwcm9taXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLl9wcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS5yZXNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvbWlzZSgpLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2UoKS52YWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUudHJ5RGlzcG9zZSA9IGZ1bmN0aW9uKGluc3BlY3Rpb24pIHtcbiAgICAgICAgdmFyIHJlc291cmNlID0gdGhpcy5yZXNvdXJjZSgpO1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIGNvbnRleHQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciByZXQgPSByZXNvdXJjZSAhPT0gbnVsbFxuICAgICAgICAgICAgPyB0aGlzLmRvRGlzcG9zZShyZXNvdXJjZSwgaW5zcGVjdGlvbikgOiBudWxsO1xuICAgICAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSBjb250ZXh0Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3Vuc2V0RGlzcG9zYWJsZSgpO1xuICAgICAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIuaXNEaXNwb3NlciA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAoZCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGQucmVzb3VyY2UgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkLnRyeURpc3Bvc2UgPT09IFwiZnVuY3Rpb25cIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRGlzcG9zZXIoZm4sIHByb21pc2UpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciQoZm4sIHByb21pc2UpO1xuICAgIH1cbiAgICBpbmhlcml0cyhGdW5jdGlvbkRpc3Bvc2VyLCBEaXNwb3Nlcik7XG5cbiAgICBGdW5jdGlvbkRpc3Bvc2VyLnByb3RvdHlwZS5kb0Rpc3Bvc2UgPSBmdW5jdGlvbiAocmVzb3VyY2UsIGluc3BlY3Rpb24pIHtcbiAgICAgICAgdmFyIGZuID0gdGhpcy5kYXRhKCk7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHJlc291cmNlLCByZXNvdXJjZSwgaW5zcGVjdGlvbik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1heWJlVW53cmFwRGlzcG9zZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKERpc3Bvc2VyLmlzRGlzcG9zZXIodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc291cmNlc1t0aGlzLmluZGV4XS5fc2V0RGlzcG9zYWJsZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUucHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBQcm9taXNlLnVzaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA8IDIpIHJldHVybiBhcGlSZWplY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBcInlvdSBtdXN0IHBhc3MgYXQgbGVhc3QgMiBhcmd1bWVudHMgdG8gUHJvbWlzZS51c2luZ1wiKTtcbiAgICAgICAgdmFyIGZuID0gYXJndW1lbnRzW2xlbiAtIDFdO1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBhcGlSZWplY3Rpb24oXCJmbiBtdXN0IGJlIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC85MTZsSkpcXHUwMDBhXCIpO1xuICAgICAgICBsZW4tLTtcbiAgICAgICAgdmFyIHJlc291cmNlcyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpZiAoRGlzcG9zZXIuaXNEaXNwb3NlcihyZXNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzcG9zZXIgPSByZXNvdXJjZTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZSA9IHJlc291cmNlLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZS5fc2V0RGlzcG9zYWJsZShkaXNwb3Nlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJlc291cmNlLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihtYXliZVVud3JhcERpc3Bvc2VyLCBudWxsLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzOiByZXNvdXJjZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICAgICAgfSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvdXJjZXNbaV0gPSByZXNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5zZXR0bGUocmVzb3VyY2VzKVxuICAgICAgICAgICAgLnRoZW4oaW5zcGVjdGlvbk1hcHBlcilcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gZm4uYXBwbHkodW5kZWZpbmVkLCB2YWxzKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLl90aGVuKFxuICAgICAgICAgICAgICAgIGRpc3Bvc2VyU3VjY2VzcywgZGlzcG9zZXJGYWlsLCB1bmRlZmluZWQsIHJlc291cmNlcywgdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLl9zZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKGRpc3Bvc2VyKSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAyNjIxNDQ7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VyID0gZGlzcG9zZXI7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLl9pc0Rpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyNjIxNDQpID4gMDtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX2dldERpc3Bvc2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcG9zZXI7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLl91bnNldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjI2MjE0NCk7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VyID0gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5kaXNwb3NlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25EaXNwb3NlcihmbiwgdGhpcywgY3JlYXRlQ29udGV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfTtcblxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGVzNSA9IHJlcXVpcmUoXCIuL2VzNS5qc1wiKTtcbnZhciBoYXZlR2V0dGVycyA9IChmdW5jdGlvbigpe1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBvID0ge307XG4gICAgICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShvLCBcImZcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gby5mID09PSAzO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG59KSgpO1xudmFyIGNhbkV2YWx1YXRlID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcInVuZGVmaW5lZFwiO1xudmFyIGVycm9yT2JqID0ge2U6IHt9fTtcbmZ1bmN0aW9uIHRyeUNhdGNoMChmbiwgcmVjZWl2ZXIpIHtcbiAgICB0cnkgeyByZXR1cm4gZm4uY2FsbChyZWNlaXZlcik7IH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJ5Q2F0Y2gxKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgdHJ5IHsgcmV0dXJuIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7IH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJ5Q2F0Y2gyKGZuLCByZWNlaXZlciwgYXJnLCBhcmcyKSB7XG4gICAgdHJ5IHsgcmV0dXJuIGZuLmNhbGwocmVjZWl2ZXIsIGFyZywgYXJnMik7IH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJ5Q2F0Y2gzKGZuLCByZWNlaXZlciwgYXJnLCBhcmcyLCBhcmczKSB7XG4gICAgdHJ5IHsgcmV0dXJuIGZuLmNhbGwocmVjZWl2ZXIsIGFyZywgYXJnMiwgYXJnMyk7IH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJ5Q2F0Y2g0KGZuLCByZWNlaXZlciwgYXJnLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgdHJ5IHsgcmV0dXJuIGZuLmNhbGwocmVjZWl2ZXIsIGFyZywgYXJnMiwgYXJnMywgYXJnNCk7IH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJ5Q2F0Y2hBcHBseShmbiwgYXJncywgcmVjZWl2ZXIpIHtcbiAgICB0cnkgeyByZXR1cm4gZm4uYXBwbHkocmVjZWl2ZXIsIGFyZ3MpOyB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JPYmouZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICB9XG59XG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uKENoaWxkLCBQYXJlbnQpIHtcbiAgICB2YXIgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gICAgZnVuY3Rpb24gVCgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IENoaWxkO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yJCA9IFBhcmVudDtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIFBhcmVudC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGlmIChoYXNQcm9wLmNhbGwoUGFyZW50LnByb3RvdHlwZSwgcHJvcGVydHlOYW1lKSAmJlxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZS5jaGFyQXQocHJvcGVydHlOYW1lLmxlbmd0aC0xKSAhPT0gXCIkXCJcbiAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWUgKyBcIiRcIl0gPSBQYXJlbnQucHJvdG90eXBlW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgVC5wcm90b3R5cGUgPSBQYXJlbnQucHJvdG90eXBlO1xuICAgIENoaWxkLnByb3RvdHlwZSA9IG5ldyBUKCk7XG4gICAgcmV0dXJuIENoaWxkLnByb3RvdHlwZTtcbn07XG5cbmZ1bmN0aW9uIGFzU3RyaW5nKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gdmFsIDogKFwiXCIgKyB2YWwpO1xufVxuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2UgfHxcbiAgICAgICAgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiO1xuXG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuICFpc1ByaW1pdGl2ZSh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIG1heWJlV3JhcEFzRXJyb3IobWF5YmVFcnJvcikge1xuICAgIGlmICghaXNQcmltaXRpdmUobWF5YmVFcnJvcikpIHJldHVybiBtYXliZUVycm9yO1xuXG4gICAgcmV0dXJuIG5ldyBFcnJvcihhc1N0cmluZyhtYXliZUVycm9yKSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhBcHBlbmRlZCh0YXJnZXQsIGFwcGVuZGVlKSB7XG4gICAgdmFyIGxlbiA9IHRhcmdldC5sZW5ndGg7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgcmV0W2ldID0gdGFyZ2V0W2ldO1xuICAgIH1cbiAgICByZXRbaV0gPSBhcHBlbmRlZTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQob2JqLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChlczUuaXNFUzUpIHtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICAgICAgaWYgKGRlc2MgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0ID09IG51bGwgJiYgZGVzYy5zZXQgPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICA/IGRlc2MudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgPyBvYmpba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vdEVudW1lcmFibGVQcm9wKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoaXNQcmltaXRpdmUob2JqKSkgcmV0dXJuIG9iajtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH07XG4gICAgZXM1LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwgZGVzY3JpcHRvcik7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuXG52YXIgd3JhcHNQcmltaXRpdmVSZWNlaXZlciA9IChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcyAhPT0gXCJzdHJpbmdcIjtcbn0pLmNhbGwoXCJzdHJpbmdcIik7XG5cbmZ1bmN0aW9uIHRocm93ZXIocikge1xuICAgIHRocm93IHI7XG59XG5cbnZhciBpbmhlcml0ZWREYXRhS2V5cyA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAoZXM1LmlzRVM1KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIG9wdHMpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgIHZhciB2aXNpdGVkS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB2YXIgZ2V0S2V5cyA9IE9iamVjdChvcHRzKS5pbmNsdWRlSGlkZGVuXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICAgICAgICAgICAgICAgIDogT2JqZWN0LmtleXM7XG4gICAgICAgICAgICB3aGlsZSAob2JqICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzID0gZ2V0S2V5cyhvYmopO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlzaXRlZEtleXNba2V5XSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAhPSBudWxsICYmIGRlc2MuZ2V0ID09IG51bGwgJiYgZGVzYy5zZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmogPSBlczUuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgLypqc2hpbnQgZm9yaW46ZmFsc2UgKi9cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICB9XG5cbn0pKCk7XG5cbmZ1bmN0aW9uIGlzQ2xhc3MoZm4pIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gZXM1LmtleXMoZm4ucHJvdG90eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBrZXlzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAhKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09IFwiY29uc3RydWN0b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9GYXN0UHJvcGVydGllcyhvYmopIHtcbiAgICAvKmpzaGludCAtVzAyNyovXG4gICAgZnVuY3Rpb24gZigpIHt9XG4gICAgZi5wcm90b3R5cGUgPSBvYmo7XG4gICAgcmV0dXJuIGY7XG4gICAgZXZhbChvYmopO1xufVxuXG52YXIgcmlkZW50ID0gL15bYS16JF9dW2EteiRfMC05XSokL2k7XG5mdW5jdGlvbiBpc0lkZW50aWZpZXIoc3RyKSB7XG4gICAgcmV0dXJuIHJpZGVudC50ZXN0KHN0cik7XG59XG5cbmZ1bmN0aW9uIGZpbGxlZFJhbmdlKGNvdW50LCBwcmVmaXgsIHN1ZmZpeCkge1xuICAgIHZhciByZXQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIHJldFtpXSA9IHByZWZpeCArIGkgKyBzdWZmaXg7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNhZmVUb1N0cmluZyhvYmopIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gb2JqICsgXCJcIjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBcIltubyBzdHJpbmcgcmVwcmVzZW50YXRpb25dXCI7XG4gICAgfVxufVxuXG52YXIgcmV0ID0ge1xuICAgIGlzQ2xhc3M6IGlzQ2xhc3MsXG4gICAgaXNJZGVudGlmaWVyOiBpc0lkZW50aWZpZXIsXG4gICAgaW5oZXJpdGVkRGF0YUtleXM6IGluaGVyaXRlZERhdGFLZXlzLFxuICAgIGdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdDogZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0LFxuICAgIHRocm93ZXI6IHRocm93ZXIsXG4gICAgaXNBcnJheTogZXM1LmlzQXJyYXksXG4gICAgaGF2ZUdldHRlcnM6IGhhdmVHZXR0ZXJzLFxuICAgIG5vdEVudW1lcmFibGVQcm9wOiBub3RFbnVtZXJhYmxlUHJvcCxcbiAgICBpc1ByaW1pdGl2ZTogaXNQcmltaXRpdmUsXG4gICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgIGNhbkV2YWx1YXRlOiBjYW5FdmFsdWF0ZSxcbiAgICBlcnJvck9iajogZXJyb3JPYmosXG4gICAgdHJ5Q2F0Y2gwOiB0cnlDYXRjaDAsXG4gICAgdHJ5Q2F0Y2gxOiB0cnlDYXRjaDEsXG4gICAgdHJ5Q2F0Y2gyOiB0cnlDYXRjaDIsXG4gICAgdHJ5Q2F0Y2gzOiB0cnlDYXRjaDMsXG4gICAgdHJ5Q2F0Y2g0OiB0cnlDYXRjaDQsXG4gICAgdHJ5Q2F0Y2hBcHBseTogdHJ5Q2F0Y2hBcHBseSxcbiAgICBpbmhlcml0czogaW5oZXJpdHMsXG4gICAgd2l0aEFwcGVuZGVkOiB3aXRoQXBwZW5kZWQsXG4gICAgYXNTdHJpbmc6IGFzU3RyaW5nLFxuICAgIG1heWJlV3JhcEFzRXJyb3I6IG1heWJlV3JhcEFzRXJyb3IsXG4gICAgd3JhcHNQcmltaXRpdmVSZWNlaXZlcjogd3JhcHNQcmltaXRpdmVSZWNlaXZlcixcbiAgICB0b0Zhc3RQcm9wZXJ0aWVzOiB0b0Zhc3RQcm9wZXJ0aWVzLFxuICAgIGZpbGxlZFJhbmdlOiBmaWxsZWRSYW5nZSxcbiAgICB0b1N0cmluZzogc2FmZVRvU3RyaW5nXG59O1xudHJ5IHt0aHJvdyBuZXcgRXJyb3IoKTsgfSBjYXRjaCAoZSkge3JldC5sYXN0TGluZUVycm9yID0gZTt9XG5tb2R1bGUuZXhwb3J0cyA9IHJldDtcbiIsbnVsbCwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5NdXRhdGlvbk9ic2VydmVyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcjtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICB2YXIgcXVldWUgPSBbXTtcblxuICAgIGlmIChjYW5NdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgIHZhciBoaWRkZW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcXVldWVMaXN0ID0gcXVldWUuc2xpY2UoKTtcbiAgICAgICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBxdWV1ZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoaGlkZGVuRGl2LCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBpZiAoIXF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGhpZGRlbkRpdi5zZXRBdHRyaWJ1dGUoJ3llcycsICdubycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIiwiLy8gZG9ULmpzXG4vLyAyMDExLTIwMTQsIExhdXJhIERva3Rvcm92YSwgaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVFxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBkb1QgPSB7XG5cdFx0dmVyc2lvbjogXCIxLjAuM1wiLFxuXHRcdHRlbXBsYXRlU2V0dGluZ3M6IHtcblx0XHRcdGV2YWx1YXRlOiAgICAvXFx7XFx7KFtcXHNcXFNdKz8oXFx9PykrKVxcfVxcfS9nLFxuXHRcdFx0aW50ZXJwb2xhdGU6IC9cXHtcXHs9KFtcXHNcXFNdKz8pXFx9XFx9L2csXG5cdFx0XHRlbmNvZGU6ICAgICAgL1xce1xceyEoW1xcc1xcU10rPylcXH1cXH0vZyxcblx0XHRcdHVzZTogICAgICAgICAvXFx7XFx7IyhbXFxzXFxTXSs/KVxcfVxcfS9nLFxuXHRcdFx0dXNlUGFyYW1zOiAgIC8oXnxbXlxcdyRdKWRlZig/OlxcLnxcXFtbXFwnXFxcIl0pKFtcXHckXFwuXSspKD86W1xcJ1xcXCJdXFxdKT9cXHMqXFw6XFxzKihbXFx3JFxcLl0rfFxcXCJbXlxcXCJdK1xcXCJ8XFwnW15cXCddK1xcJ3xcXHtbXlxcfV0rXFx9KS9nLFxuXHRcdFx0ZGVmaW5lOiAgICAgIC9cXHtcXHsjI1xccyooW1xcd1xcLiRdKylcXHMqKFxcOnw9KShbXFxzXFxTXSs/KSNcXH1cXH0vZyxcblx0XHRcdGRlZmluZVBhcmFtczovXlxccyooW1xcdyRdKyk6KFtcXHNcXFNdKykvLFxuXHRcdFx0Y29uZGl0aW9uYWw6IC9cXHtcXHtcXD8oXFw/KT9cXHMqKFtcXHNcXFNdKj8pXFxzKlxcfVxcfS9nLFxuXHRcdFx0aXRlcmF0ZTogICAgIC9cXHtcXHt+XFxzKig/OlxcfVxcfXwoW1xcc1xcU10rPylcXHMqXFw6XFxzKihbXFx3JF0rKVxccyooPzpcXDpcXHMqKFtcXHckXSspKT9cXHMqXFx9XFx9KS9nLFxuXHRcdFx0dmFybmFtZTpcdFwiaXRcIixcblx0XHRcdHN0cmlwOlx0XHR0cnVlLFxuXHRcdFx0YXBwZW5kOlx0XHR0cnVlLFxuXHRcdFx0c2VsZmNvbnRhaW5lZDogZmFsc2UsXG5cdFx0XHRkb05vdFNraXBFbmNvZGVkOiBmYWxzZVxuXHRcdH0sXG5cdFx0dGVtcGxhdGU6IHVuZGVmaW5lZCwgLy9mbiwgY29tcGlsZSB0ZW1wbGF0ZVxuXHRcdGNvbXBpbGU6ICB1bmRlZmluZWQgIC8vZm4sIGZvciBleHByZXNzXG5cdH0sIF9nbG9iYWxzO1xuXG5cdGRvVC5lbmNvZGVIVE1MU291cmNlID0gZnVuY3Rpb24oZG9Ob3RTa2lwRW5jb2RlZCkge1xuXHRcdHZhciBlbmNvZGVIVE1MUnVsZXMgPSB7IFwiJlwiOiBcIiYjMzg7XCIsIFwiPFwiOiBcIiYjNjA7XCIsIFwiPlwiOiBcIiYjNjI7XCIsICdcIic6IFwiJiMzNDtcIiwgXCInXCI6IFwiJiMzOTtcIiwgXCIvXCI6IFwiJiM0NztcIiB9LFxuXHRcdFx0bWF0Y2hIVE1MID0gZG9Ob3RTa2lwRW5jb2RlZCA/IC9bJjw+XCInXFwvXS9nIDogLyYoPyEjP1xcdys7KXw8fD58XCJ8J3xcXC8vZztcblx0XHRyZXR1cm4gZnVuY3Rpb24oY29kZSkge1xuXHRcdFx0cmV0dXJuIGNvZGUgPyBjb2RlLnRvU3RyaW5nKCkucmVwbGFjZShtYXRjaEhUTUwsIGZ1bmN0aW9uKG0pIHtyZXR1cm4gZW5jb2RlSFRNTFJ1bGVzW21dIHx8IG07fSkgOiBcIlwiO1xuXHRcdH07XG5cdH07XG5cblx0X2dsb2JhbHMgPSAoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMgfHwgKDAsZXZhbCkoXCJ0aGlzXCIpOyB9KCkpO1xuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBkb1Q7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4gZG9UO30pO1xuXHR9IGVsc2Uge1xuXHRcdF9nbG9iYWxzLmRvVCA9IGRvVDtcblx0fVxuXG5cdHZhciBzdGFydGVuZCA9IHtcblx0XHRhcHBlbmQ6IHsgc3RhcnQ6IFwiJysoXCIsICAgICAgZW5kOiBcIikrJ1wiLCAgICAgIHN0YXJ0ZW5jb2RlOiBcIicrZW5jb2RlSFRNTChcIiB9LFxuXHRcdHNwbGl0OiAgeyBzdGFydDogXCInO291dCs9KFwiLCBlbmQ6IFwiKTtvdXQrPSdcIiwgc3RhcnRlbmNvZGU6IFwiJztvdXQrPWVuY29kZUhUTUwoXCIgfVxuXHR9LCBza2lwID0gLyReLztcblxuXHRmdW5jdGlvbiByZXNvbHZlRGVmcyhjLCBibG9jaywgZGVmKSB7XG5cdFx0cmV0dXJuICgodHlwZW9mIGJsb2NrID09PSBcInN0cmluZ1wiKSA/IGJsb2NrIDogYmxvY2sudG9TdHJpbmcoKSlcblx0XHQucmVwbGFjZShjLmRlZmluZSB8fCBza2lwLCBmdW5jdGlvbihtLCBjb2RlLCBhc3NpZ24sIHZhbHVlKSB7XG5cdFx0XHRpZiAoY29kZS5pbmRleE9mKFwiZGVmLlwiKSA9PT0gMCkge1xuXHRcdFx0XHRjb2RlID0gY29kZS5zdWJzdHJpbmcoNCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIShjb2RlIGluIGRlZikpIHtcblx0XHRcdFx0aWYgKGFzc2lnbiA9PT0gXCI6XCIpIHtcblx0XHRcdFx0XHRpZiAoYy5kZWZpbmVQYXJhbXMpIHZhbHVlLnJlcGxhY2UoYy5kZWZpbmVQYXJhbXMsIGZ1bmN0aW9uKG0sIHBhcmFtLCB2KSB7XG5cdFx0XHRcdFx0XHRkZWZbY29kZV0gPSB7YXJnOiBwYXJhbSwgdGV4dDogdn07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0aWYgKCEoY29kZSBpbiBkZWYpKSBkZWZbY29kZV09IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ldyBGdW5jdGlvbihcImRlZlwiLCBcImRlZlsnXCIrY29kZStcIiddPVwiICsgdmFsdWUpKGRlZik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH0pXG5cdFx0LnJlcGxhY2UoYy51c2UgfHwgc2tpcCwgZnVuY3Rpb24obSwgY29kZSkge1xuXHRcdFx0aWYgKGMudXNlUGFyYW1zKSBjb2RlID0gY29kZS5yZXBsYWNlKGMudXNlUGFyYW1zLCBmdW5jdGlvbihtLCBzLCBkLCBwYXJhbSkge1xuXHRcdFx0XHRpZiAoZGVmW2RdICYmIGRlZltkXS5hcmcgJiYgcGFyYW0pIHtcblx0XHRcdFx0XHR2YXIgcncgPSAoZCtcIjpcIitwYXJhbSkucmVwbGFjZSgvJ3xcXFxcL2csIFwiX1wiKTtcblx0XHRcdFx0XHRkZWYuX19leHAgPSBkZWYuX19leHAgfHwge307XG5cdFx0XHRcdFx0ZGVmLl9fZXhwW3J3XSA9IGRlZltkXS50ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChcIihefFteXFxcXHckXSlcIiArIGRlZltkXS5hcmcgKyBcIihbXlxcXFx3JF0pXCIsIFwiZ1wiKSwgXCIkMVwiICsgcGFyYW0gKyBcIiQyXCIpO1xuXHRcdFx0XHRcdHJldHVybiBzICsgXCJkZWYuX19leHBbJ1wiK3J3K1wiJ11cIjtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR2YXIgdiA9IG5ldyBGdW5jdGlvbihcImRlZlwiLCBcInJldHVybiBcIiArIGNvZGUpKGRlZik7XG5cdFx0XHRyZXR1cm4gdiA/IHJlc29sdmVEZWZzKGMsIHYsIGRlZikgOiB2O1xuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gdW5lc2NhcGUoY29kZSkge1xuXHRcdHJldHVybiBjb2RlLnJlcGxhY2UoL1xcXFwoJ3xcXFxcKS9nLCBcIiQxXCIpLnJlcGxhY2UoL1tcXHJcXHRcXG5dL2csIFwiIFwiKTtcblx0fVxuXG5cdGRvVC50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRtcGwsIGMsIGRlZikge1xuXHRcdGMgPSBjIHx8IGRvVC50ZW1wbGF0ZVNldHRpbmdzO1xuXHRcdHZhciBjc2UgPSBjLmFwcGVuZCA/IHN0YXJ0ZW5kLmFwcGVuZCA6IHN0YXJ0ZW5kLnNwbGl0LCBuZWVkaHRtbGVuY29kZSwgc2lkID0gMCwgaW5kdixcblx0XHRcdHN0ciAgPSAoYy51c2UgfHwgYy5kZWZpbmUpID8gcmVzb2x2ZURlZnMoYywgdG1wbCwgZGVmIHx8IHt9KSA6IHRtcGw7XG5cblx0XHRzdHIgPSAoXCJ2YXIgb3V0PSdcIiArIChjLnN0cmlwID8gc3RyLnJlcGxhY2UoLyhefFxccnxcXG4pXFx0KiArfCArXFx0KihcXHJ8XFxufCQpL2csXCIgXCIpXG5cdFx0XHRcdFx0LnJlcGxhY2UoL1xccnxcXG58XFx0fFxcL1xcKltcXHNcXFNdKj9cXCpcXC8vZyxcIlwiKTogc3RyKVxuXHRcdFx0LnJlcGxhY2UoLyd8XFxcXC9nLCBcIlxcXFwkJlwiKVxuXHRcdFx0LnJlcGxhY2UoYy5pbnRlcnBvbGF0ZSB8fCBza2lwLCBmdW5jdGlvbihtLCBjb2RlKSB7XG5cdFx0XHRcdHJldHVybiBjc2Uuc3RhcnQgKyB1bmVzY2FwZShjb2RlKSArIGNzZS5lbmQ7XG5cdFx0XHR9KVxuXHRcdFx0LnJlcGxhY2UoYy5lbmNvZGUgfHwgc2tpcCwgZnVuY3Rpb24obSwgY29kZSkge1xuXHRcdFx0XHRuZWVkaHRtbGVuY29kZSA9IHRydWU7XG5cdFx0XHRcdHJldHVybiBjc2Uuc3RhcnRlbmNvZGUgKyB1bmVzY2FwZShjb2RlKSArIGNzZS5lbmQ7XG5cdFx0XHR9KVxuXHRcdFx0LnJlcGxhY2UoYy5jb25kaXRpb25hbCB8fCBza2lwLCBmdW5jdGlvbihtLCBlbHNlY2FzZSwgY29kZSkge1xuXHRcdFx0XHRyZXR1cm4gZWxzZWNhc2UgP1xuXHRcdFx0XHRcdChjb2RlID8gXCInO31lbHNlIGlmKFwiICsgdW5lc2NhcGUoY29kZSkgKyBcIil7b3V0Kz0nXCIgOiBcIic7fWVsc2V7b3V0Kz0nXCIpIDpcblx0XHRcdFx0XHQoY29kZSA/IFwiJztpZihcIiArIHVuZXNjYXBlKGNvZGUpICsgXCIpe291dCs9J1wiIDogXCInO31vdXQrPSdcIik7XG5cdFx0XHR9KVxuXHRcdFx0LnJlcGxhY2UoYy5pdGVyYXRlIHx8IHNraXAsIGZ1bmN0aW9uKG0sIGl0ZXJhdGUsIHZuYW1lLCBpbmFtZSkge1xuXHRcdFx0XHRpZiAoIWl0ZXJhdGUpIHJldHVybiBcIic7fSB9IG91dCs9J1wiO1xuXHRcdFx0XHRzaWQrPTE7IGluZHY9aW5hbWUgfHwgXCJpXCIrc2lkOyBpdGVyYXRlPXVuZXNjYXBlKGl0ZXJhdGUpO1xuXHRcdFx0XHRyZXR1cm4gXCInO3ZhciBhcnJcIitzaWQrXCI9XCIraXRlcmF0ZStcIjtpZihhcnJcIitzaWQrXCIpe3ZhciBcIit2bmFtZStcIixcIitpbmR2K1wiPS0xLGxcIitzaWQrXCI9YXJyXCIrc2lkK1wiLmxlbmd0aC0xO3doaWxlKFwiK2luZHYrXCI8bFwiK3NpZCtcIil7XCJcblx0XHRcdFx0XHQrdm5hbWUrXCI9YXJyXCIrc2lkK1wiW1wiK2luZHYrXCIrPTFdO291dCs9J1wiO1xuXHRcdFx0fSlcblx0XHRcdC5yZXBsYWNlKGMuZXZhbHVhdGUgfHwgc2tpcCwgZnVuY3Rpb24obSwgY29kZSkge1xuXHRcdFx0XHRyZXR1cm4gXCInO1wiICsgdW5lc2NhcGUoY29kZSkgKyBcIm91dCs9J1wiO1xuXHRcdFx0fSlcblx0XHRcdCsgXCInO3JldHVybiBvdXQ7XCIpXG5cdFx0XHQucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIikucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpLnJlcGxhY2UoL1xcci9nLCBcIlxcXFxyXCIpXG5cdFx0XHQucmVwbGFjZSgvKFxcc3w7fFxcfXxefFxceylvdXRcXCs9Jyc7L2csICckMScpLnJlcGxhY2UoL1xcKycnL2csIFwiXCIpO1xuXHRcdFx0Ly8ucmVwbGFjZSgvKFxcc3w7fFxcfXxefFxceylvdXRcXCs9JydcXCsvZywnJDFvdXQrPScpO1xuXG5cdFx0aWYgKG5lZWRodG1sZW5jb2RlKSB7XG5cdFx0XHRpZiAoIWMuc2VsZmNvbnRhaW5lZCAmJiBfZ2xvYmFscyAmJiAhX2dsb2JhbHMuX2VuY29kZUhUTUwpIF9nbG9iYWxzLl9lbmNvZGVIVE1MID0gZG9ULmVuY29kZUhUTUxTb3VyY2UoYy5kb05vdFNraXBFbmNvZGVkKTtcblx0XHRcdHN0ciA9IFwidmFyIGVuY29kZUhUTUwgPSB0eXBlb2YgX2VuY29kZUhUTUwgIT09ICd1bmRlZmluZWQnID8gX2VuY29kZUhUTUwgOiAoXCJcblx0XHRcdFx0KyBkb1QuZW5jb2RlSFRNTFNvdXJjZS50b1N0cmluZygpICsgXCIoXCIgKyAoYy5kb05vdFNraXBFbmNvZGVkIHx8ICcnKSArIFwiKSk7XCJcblx0XHRcdFx0KyBzdHI7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gbmV3IEZ1bmN0aW9uKGMudmFybmFtZSwgc3RyKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUubG9nKFwiQ291bGQgbm90IGNyZWF0ZSBhIHRlbXBsYXRlIGZ1bmN0aW9uOiBcIiArIHN0cik7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0fTtcblxuXHRkb1QuY29tcGlsZSA9IGZ1bmN0aW9uKHRtcGwsIGRlZikge1xuXHRcdHJldHVybiBkb1QudGVtcGxhdGUodG1wbCwgbnVsbCwgZGVmKTtcblx0fTtcbn0oKSk7XG4iLCIvKiBkb1QgKyBhdXRvLWNvbXBpbGF0aW9uIG9mIGRvVCB0ZW1wbGF0ZXNcbiAqXG4gKiAyMDEyLCBMYXVyYSBEb2t0b3JvdmEsIGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1RcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICpcbiAqIENvbXBpbGVzIC5kZWYsIC5kb3QsIC5qc3QgZmlsZXMgZm91bmQgdW5kZXIgdGhlIHNwZWNpZmllZCBwYXRoLlxuICogSXQgaWdub3JlcyBzdWItZGlyZWN0b3JpZXMuXG4gKiBUZW1wbGF0ZSBmaWxlcyBjYW4gaGF2ZSBtdWx0aXBsZSBleHRlbnNpb25zIGF0IHRoZSBzYW1lIHRpbWUuXG4gKiBGaWxlcyB3aXRoIC5kZWYgZXh0ZW5zaW9uIGNhbiBiZSBpbmNsdWRlZCBpbiBvdGhlciBmaWxlcyB2aWEge3sjZGVmLm5hbWV9fVxuICogRmlsZXMgd2l0aCAuZG90IGV4dGVuc2lvbiBhcmUgY29tcGlsZWQgaW50byBmdW5jdGlvbnMgd2l0aCB0aGUgc2FtZSBuYW1lIGFuZFxuICogY2FuIGJlIGFjY2Vzc2VkIGFzIHJlbmRlcmVyLmZpbGVuYW1lXG4gKiBGaWxlcyB3aXRoIC5qc3QgZXh0ZW5zaW9uIGFyZSBjb21waWxlZCBpbnRvIC5qcyBmaWxlcy4gUHJvZHVjZWQgLmpzIGZpbGUgY2FuIGJlXG4gKiBsb2FkZWQgYXMgYSBjb21tb25KUywgQU1EIG1vZHVsZSwgb3IganVzdCBpbnN0YWxsZWQgaW50byBhIGdsb2JhbCB2YXJpYWJsZVxuICogKGRlZmF1bHQgaXMgc2V0IHRvIHdpbmRvdy5yZW5kZXIpLlxuICogQWxsIGlubGluZSBkZWZpbmVzIGRlZmluZWQgaW4gdGhlIC5qc3QgZmlsZSBhcmVcbiAqIGNvbXBpbGVkIGludG8gc2VwYXJhdGUgZnVuY3Rpb25zIGFuZCBhcmUgYXZhaWxhYmxlIHZpYSBfcmVuZGVyLmZpbGVuYW1lLmRlZmluZW5hbWVcbiAqXG4gKiBCYXNpYyB1c2FnZTpcbiAqIHZhciBkb3RzID0gcmVxdWlyZShcImRvdFwiKS5wcm9jZXNzKHtwYXRoOiBcIi4vdmlld3NcIn0pO1xuICogZG90cy5teXRlbXBsYXRlKHtmb286XCJoZWxsbyB3b3JsZFwifSk7XG4gKlxuICogVGhlIGFib3ZlIHNuaXBwZXQgd2lsbDpcbiAqIDEuIENvbXBpbGUgYWxsIHRlbXBsYXRlcyBpbiB2aWV3cyBmb2xkZXIgKC5kb3QsIC5kZWYsIC5qc3QpXG4gKiAyLiBQbGFjZSAuanMgZmlsZXMgY29tcGlsZWQgZnJvbSAuanN0IHRlbXBsYXRlcyBpbnRvIHRoZSBzYW1lIGZvbGRlci5cbiAqICAgIFRoZXNlIGZpbGVzIGNhbiBiZSB1c2VkIHdpdGggcmVxdWlyZSwgaS5lLiByZXF1aXJlKFwiLi92aWV3cy9teXRlbXBsYXRlXCIpLlxuICogMy4gUmV0dXJuIGFuIG9iamVjdCB3aXRoIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIC5kb3QgdGVtcGxhdGVzIGFzIGl0cyBwcm9wZXJ0aWVzLlxuICogNC4gUmVuZGVyIG15dGVtcGxhdGUgdGVtcGxhdGUuXG4gKi9cblxudmFyIGZzID0gcmVxdWlyZShcImZzXCIpLFxuXHRkb1QgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2RvVFwiKTtcblxuZG9ULnByb2Nlc3MgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdC8vcGF0aCwgZGVzdGluYXRpb24sIGdsb2JhbCwgcmVuZGVybW9kdWxlLCB0ZW1wbGF0ZVNldHRpbmdzXG5cdHJldHVybiBuZXcgSW5zdGFsbERvdHMob3B0aW9ucykuY29tcGlsZUFsbCgpO1xufTtcblxuZnVuY3Rpb24gSW5zdGFsbERvdHMobykge1xuXHR0aGlzLl9fcGF0aCBcdFx0PSBvLnBhdGggfHwgXCIuL1wiO1xuXHRpZiAodGhpcy5fX3BhdGhbdGhpcy5fX3BhdGgubGVuZ3RoLTFdICE9PSAnLycpIHRoaXMuX19wYXRoICs9ICcvJztcblx0dGhpcy5fX2Rlc3RpbmF0aW9uXHQ9IG8uZGVzdGluYXRpb24gfHwgdGhpcy5fX3BhdGg7XG5cdGlmICh0aGlzLl9fZGVzdGluYXRpb25bdGhpcy5fX2Rlc3RpbmF0aW9uLmxlbmd0aC0xXSAhPT0gJy8nKSB0aGlzLl9fZGVzdGluYXRpb24gKz0gJy8nO1xuXHR0aGlzLl9fZ2xvYmFsXHRcdD0gby5nbG9iYWwgfHwgXCJ3aW5kb3cucmVuZGVyXCI7XG5cdHRoaXMuX19yZW5kZXJtb2R1bGVcdD0gby5yZW5kZXJtb2R1bGUgfHwge307XG5cdHRoaXMuX19zZXR0aW5ncyBcdD0gby50ZW1wbGF0ZVNldHRpbmdzID8gY29weShvLnRlbXBsYXRlU2V0dGluZ3MsIGNvcHkoZG9ULnRlbXBsYXRlU2V0dGluZ3MpKSA6IHVuZGVmaW5lZDtcblx0dGhpcy5fX2luY2x1ZGVzXHRcdD0ge307XG59XG5cbkluc3RhbGxEb3RzLnByb3RvdHlwZS5jb21waWxlVG9GaWxlID0gZnVuY3Rpb24ocGF0aCwgdGVtcGxhdGUsIGRlZikge1xuXHRkZWYgPSBkZWYgfHwge307XG5cdHZhciBtb2R1bGVuYW1lID0gcGF0aC5zdWJzdHJpbmcocGF0aC5sYXN0SW5kZXhPZihcIi9cIikrMSwgcGF0aC5sYXN0SW5kZXhPZihcIi5cIikpXG5cdFx0LCBkZWZzID0gY29weSh0aGlzLl9faW5jbHVkZXMsIGNvcHkoZGVmKSlcblx0XHQsIHNldHRpbmdzID0gdGhpcy5fX3NldHRpbmdzIHx8IGRvVC50ZW1wbGF0ZVNldHRpbmdzXG5cdFx0LCBjb21waWxlb3B0aW9ucyA9IGNvcHkoc2V0dGluZ3MpXG5cdFx0LCBkZWZhdWx0Y29tcGlsZWQgPSBkb1QudGVtcGxhdGUodGVtcGxhdGUsIHNldHRpbmdzLCBkZWZzKVxuXHRcdCwgZXhwb3J0cyA9IFtdXG5cdFx0LCBjb21waWxlZCA9IFwiXCJcblx0XHQsIGZuO1xuXG5cdGZvciAodmFyIHByb3BlcnR5IGluIGRlZnMpIHtcblx0XHRpZiAoZGVmc1twcm9wZXJ0eV0gIT09IGRlZltwcm9wZXJ0eV0gJiYgZGVmc1twcm9wZXJ0eV0gIT09IHRoaXMuX19pbmNsdWRlc1twcm9wZXJ0eV0pIHtcblx0XHRcdGZuID0gdW5kZWZpbmVkO1xuXHRcdFx0aWYgKHR5cGVvZiBkZWZzW3Byb3BlcnR5XSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Zm4gPSBkb1QudGVtcGxhdGUoZGVmc1twcm9wZXJ0eV0sIHNldHRpbmdzLCBkZWZzKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGRlZnNbcHJvcGVydHldID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGZuID0gZGVmc1twcm9wZXJ0eV07XG5cdFx0XHR9IGVsc2UgaWYgKGRlZnNbcHJvcGVydHldLmFyZykge1xuXHRcdFx0XHRjb21waWxlb3B0aW9ucy52YXJuYW1lID0gZGVmc1twcm9wZXJ0eV0uYXJnO1xuXHRcdFx0XHRmbiA9IGRvVC50ZW1wbGF0ZShkZWZzW3Byb3BlcnR5XS50ZXh0LCBjb21waWxlb3B0aW9ucywgZGVmcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZm4pIHtcblx0XHRcdFx0Y29tcGlsZWQgKz0gZm4udG9TdHJpbmcoKS5yZXBsYWNlKCdhbm9ueW1vdXMnLCBwcm9wZXJ0eSk7XG5cdFx0XHRcdGV4cG9ydHMucHVzaChwcm9wZXJ0eSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGNvbXBpbGVkICs9IGRlZmF1bHRjb21waWxlZC50b1N0cmluZygpLnJlcGxhY2UoJ2Fub255bW91cycsIG1vZHVsZW5hbWUpO1xuXHRmcy53cml0ZUZpbGVTeW5jKHBhdGgsIFwiKGZ1bmN0aW9uKCl7XCIgKyBjb21waWxlZFxuXHRcdCsgXCJ2YXIgaXRzZWxmPVwiICsgbW9kdWxlbmFtZSArIFwiLCBfZW5jb2RlSFRNTD0oXCIgKyBkb1QuZW5jb2RlSFRNTFNvdXJjZS50b1N0cmluZygpICsgXCIoXCIgKyAoc2V0dGluZ3MuZG9Ob3RTa2lwRW5jb2RlZCB8fCAnJykgKyBcIikpO1wiXG5cdFx0KyBhZGRleHBvcnRzKGV4cG9ydHMpXG5cdFx0KyBcImlmKHR5cGVvZiBtb2R1bGUhPT0ndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHM9aXRzZWxmO2Vsc2UgaWYodHlwZW9mIGRlZmluZT09PSdmdW5jdGlvbicpZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIGl0c2VsZjt9KTtlbHNlIHtcIlxuXHRcdCsgdGhpcy5fX2dsb2JhbCArIFwiPVwiICsgdGhpcy5fX2dsb2JhbCArIFwifHx7fTtcIiArIHRoaXMuX19nbG9iYWwgKyBcIlsnXCIgKyBtb2R1bGVuYW1lICsgXCInXT1pdHNlbGY7fX0oKSk7XCIpO1xufTtcblxuZnVuY3Rpb24gYWRkZXhwb3J0cyhleHBvcnRzKSB7XG5cdGZvciAodmFyIHJldCA9JycsIGk9MDsgaTwgZXhwb3J0cy5sZW5ndGg7IGkrKykge1xuXHRcdHJldCArPSBcIml0c2VsZi5cIiArIGV4cG9ydHNbaV0rIFwiPVwiICsgZXhwb3J0c1tpXStcIjtcIjtcblx0fVxuXHRyZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBjb3B5KG8sIHRvKSB7XG5cdHRvID0gdG8gfHwge307XG5cdGZvciAodmFyIHByb3BlcnR5IGluIG8pIHtcblx0XHR0b1twcm9wZXJ0eV0gPSBvW3Byb3BlcnR5XTtcblx0fVxuXHRyZXR1cm4gdG87XG59XG5cbmZ1bmN0aW9uIHJlYWRkYXRhKHBhdGgpIHtcblx0dmFyIGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMocGF0aCk7XG5cdGlmIChkYXRhKSByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuXHRjb25zb2xlLmxvZyhcInByb2JsZW1zIHdpdGggXCIgKyBwYXRoKTtcbn1cblxuSW5zdGFsbERvdHMucHJvdG90eXBlLmNvbXBpbGVQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuXHR2YXIgZGF0YSA9IHJlYWRkYXRhKHBhdGgpO1xuXHRpZiAoZGF0YSkge1xuXHRcdHJldHVybiBkb1QudGVtcGxhdGUoZGF0YSxcblx0XHRcdFx0XHR0aGlzLl9fc2V0dGluZ3MgfHwgZG9ULnRlbXBsYXRlU2V0dGluZ3MsXG5cdFx0XHRcdFx0Y29weSh0aGlzLl9faW5jbHVkZXMpKTtcblx0fVxufTtcblxuSW5zdGFsbERvdHMucHJvdG90eXBlLmNvbXBpbGVBbGwgPSBmdW5jdGlvbigpIHtcblx0Y29uc29sZS5sb2coXCJDb21waWxpbmcgYWxsIGRvVCB0ZW1wbGF0ZXMuLi5cIik7XG5cblx0dmFyIGRlZkZvbGRlciA9IHRoaXMuX19wYXRoLFxuXHRcdHNvdXJjZXMgPSBmcy5yZWFkZGlyU3luYyhkZWZGb2xkZXIpLFxuXHRcdGssIGwsIG5hbWU7XG5cblx0Zm9yKCBrID0gMCwgbCA9IHNvdXJjZXMubGVuZ3RoOyBrIDwgbDsgaysrKSB7XG5cdFx0bmFtZSA9IHNvdXJjZXNba107XG5cdFx0aWYgKC9cXC5kZWYoXFwuZG90fFxcLmpzdCk/JC8udGVzdChuYW1lKSkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJMb2FkZWQgZGVmIFwiICsgbmFtZSk7XG5cdFx0XHR0aGlzLl9faW5jbHVkZXNbbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5pbmRleE9mKCcuJykpXSA9IHJlYWRkYXRhKGRlZkZvbGRlciArIG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdGZvciggayA9IDAsIGwgPSBzb3VyY2VzLmxlbmd0aDsgayA8IGw7IGsrKykge1xuXHRcdG5hbWUgPSBzb3VyY2VzW2tdO1xuXHRcdGlmICgvXFwuZG90KFxcLmRlZnxcXC5qc3QpPyQvLnRlc3QobmFtZSkpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwiQ29tcGlsaW5nIFwiICsgbmFtZSArIFwiIHRvIGZ1bmN0aW9uXCIpO1xuXHRcdFx0dGhpcy5fX3JlbmRlcm1vZHVsZVtuYW1lLnN1YnN0cmluZygwLCBuYW1lLmluZGV4T2YoJy4nKSldID0gdGhpcy5jb21waWxlUGF0aChkZWZGb2xkZXIgKyBuYW1lKTtcblx0XHR9XG5cdFx0aWYgKC9cXC5qc3QoXFwuZG90fFxcLmRlZik/JC8udGVzdChuYW1lKSkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJDb21waWxpbmcgXCIgKyBuYW1lICsgXCIgdG8gZmlsZVwiKTtcblx0XHRcdHRoaXMuY29tcGlsZVRvRmlsZSh0aGlzLl9fZGVzdGluYXRpb24gKyBuYW1lLnN1YnN0cmluZygwLCBuYW1lLmluZGV4T2YoJy4nKSkgKyAnLmpzJyxcblx0XHRcdFx0XHRyZWFkZGF0YShkZWZGb2xkZXIgKyBuYW1lKSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0aGlzLl9fcmVuZGVybW9kdWxlO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4vKipcbiAqIFRoZSBhdmFpbGFibGUgcmVuZGVyIHR5cGVzXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQGFsaWFzIEltZ2x5S2l0LlJlbmRlclR5cGVcbiAqL1xuZXhwb3J0IHZhciBSZW5kZXJUeXBlID0ge1xuICBJTUFHRTogXCJpbWFnZVwiLFxuICBEQVRBVVJMOiBcImRhdGEtdXJsXCJcbn07XG5cbi8qKlxuICogVGhlIGF2YWlsYWJsZSBvdXRwdXQgaW1hZ2UgZm9ybWF0c1xuICogQGVudW0ge3N0cmluZ31cbiAqIEBhbGlhcyBJbWdseUtpdC5JbWFnZUZvcm1hdFxuICovXG5leHBvcnQgdmFyIEltYWdlRm9ybWF0ID0ge1xuICBQTkc6IFwiaW1hZ2UvcG5nXCIsXG4gIEpQRUc6IFwiaW1hZ2UvanBlZ1wiXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBibHVlYmlyZCBmcm9tIFwiYmx1ZWJpcmRcIjtcbmltcG9ydCBSZW5kZXJJbWFnZSBmcm9tIFwiLi9saWIvcmVuZGVyLWltYWdlXCI7XG5pbXBvcnQgSW1hZ2VFeHBvcnRlciBmcm9tIFwiLi9saWIvaW1hZ2UtZXhwb3J0ZXJcIjtcbmltcG9ydCB7IFJlbmRlclR5cGUsIEltYWdlRm9ybWF0IH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4vbGliL3V0aWxzXCI7XG5cbi8vIERlZmF1bHQgVUlzXG5pbXBvcnQgTmlnaHRVSSBmcm9tIFwiLi91aS9uaWdodC91aVwiO1xuXG4vLyBEb24ndCBjYXRjaCBlcnJvcnNcbmJsdWViaXJkLm9uUG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24oKGVycm9yKSA9PiB7IHRocm93IGVycm9yOyB9KTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbb3B0aW9ucy5jb250YWluZXJdIC0gU3BlY2lmaWVzIHdoZXJlIHRoZSBVSSBzaG91bGQgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWQgdG8uIElmIG5vbmUgaXMgZ2l2ZW4sIHRoZSBVSVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgZGlzYWJsZWQuXG4gKiBAcGFyYW0ge0ltYWdlfSBvcHRpb25zLmltYWdlIC0gVGhlIHNvdXJjZSBpbWFnZVxuICovXG5jbGFzcyBJbWdseUtpdCB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG5cbiAgICAvLyBgb3B0aW9uc2AgaXMgcmVxdWlyZWRcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHRocm93IG5ldyBFcnJvcihcIk5vIG9wdGlvbnMgZ2l2ZW4uXCIpO1xuICAgIC8vIGBvcHRpb25zLmltYWdlYCBpcyByZXF1aXJlZFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pbWFnZSA9PT0gXCJ1bmRlZmluZWRcIikgdGhyb3cgbmV3IEVycm9yKFwiYG9wdGlvbnMuaW1hZ2VgIGlzIHVuZGVmaW5lZC5cIik7XG5cbiAgICAvLyBTZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgYXNzZXRzVXJsOiBcImFzc2V0c1wiLFxuICAgICAgY29udGFpbmVyOiBudWxsLFxuICAgICAgdWk6IHRydWVcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGFjayBvZiB7QGxpbmsgT3BlcmF0aW9ufSBpbnN0YW5jZXMgdGhhdCB3aWxsIGJlIHVzZWRcbiAgICAgKiB0byByZW5kZXIgdGhlIGZpbmFsIEltYWdlXG4gICAgICogQHR5cGUge0FycmF5LjxJbWdseUtpdC5PcGVyYXRpb24+fVxuICAgICAqL1xuICAgIHRoaXMub3BlcmF0aW9uc1N0YWNrID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVnaXN0ZXJlZCBVSSB0eXBlcyB0aGF0IGNhbiBiZSBzZWxlY3RlZCB2aWEgdGhlIGB1aWAgb3B0aW9uXG4gICAgICogQHR5cGUge09iamVjdC48U3RyaW5nLCBVST59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yZWdpc3RlcmVkVUlzID0ge307XG5cbiAgICAvLyBSZWdpc3RlciB0aGUgZGVmYXVsdCBVSXNcbiAgICB0aGlzLl9yZWdpc3RlclVJcygpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlZ2lzdGVyZWQgb3BlcmF0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3QuPFN0cmluZywgSW1nbHlLaXQuT3BlcmF0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLl9yZWdpc3RlcmVkT3BlcmF0aW9ucyA9IHt9O1xuXG4gICAgLy8gUmVnaXN0ZXIgdGhlIGRlZmF1bHQgb3BlcmF0aW9uc1xuICAgIHRoaXMuX3JlZ2lzdGVyT3BlcmF0aW9ucygpO1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMudWkpIHtcbiAgICAgIHRoaXMuX2luaXRVSSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBpbWFnZVxuICAgKiBAcGFyYW0gIHtJbWdseUtpdC5SZW5kZXJUeXBlfSBbcmVuZGVyVHlwZT1JbWdseUtpdC5SZW5kZXJUeXBlLkRBVEFfVVJMXSAtIFRoZSBvdXRwdXQgdHlwZVxuICAgKiBAcGFyYW0gIHtJbWdseUtpdC5JbWFnZUZvcm1hdH0gW2ltYWdlRm9ybWF0PUltZ2x5S2l0LkltYWdlRm9ybWF0LlBOR10gLSBUaGUgb3V0cHV0IGltYWdlIGZvcm1hdFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IFtkaW1lbnNpb25zXSAtIFRoZSBmaW5hbCBkaW1lbnNpb25zIG9mIHRoZSBpbWFnZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJUeXBlLCBpbWFnZUZvcm1hdCwgZGltZW5zaW9ucykge1xuICAgIHZhciBzZXR0aW5ncyA9IEltYWdlRXhwb3J0ZXIudmFsaWRhdGVTZXR0aW5ncyhyZW5kZXJUeXBlLCBpbWFnZUZvcm1hdCk7XG5cbiAgICByZW5kZXJUeXBlID0gc2V0dGluZ3MucmVuZGVyVHlwZTtcbiAgICBpbWFnZUZvcm1hdCA9IHNldHRpbmdzLmltYWdlRm9ybWF0O1xuXG4gICAgLy8gQ3JlYXRlIGEgUmVuZGVySW1hZ2VcbiAgICB2YXIgcmVuZGVySW1hZ2UgPSBuZXcgUmVuZGVySW1hZ2UodGhpcy5fb3B0aW9ucy5pbWFnZSwgdGhpcy5vcGVyYXRpb25zU3RhY2ssIGRpbWVuc2lvbnMsIHRoaXMuX29wdGlvbnMucmVuZGVyZXIpO1xuXG4gICAgLy8gSW5pdGlhdGUgaW1hZ2UgcmVuZGVyaW5nXG4gICAgcmV0dXJuIHJlbmRlckltYWdlLnJlbmRlcigpXG4gICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSByZW5kZXJJbWFnZS5nZXRSZW5kZXJlcigpLmdldENhbnZhcygpO1xuICAgICAgICByZXR1cm4gSW1hZ2VFeHBvcnRlci5leHBvcnQoY2FudmFzLCByZW5kZXJUeXBlLCBpbWFnZUZvcm1hdCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgYWxsIGN1c3RvbSBhbmQgc2VsZWN0ZWQgb3BlcmF0aW9uc1xuICAgKi9cbiAgcmVzZXQgKCkge1xuXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXNzZXQgcGF0aCBmb3IgdGhlIGdpdmVuIGZpbGVuYW1lXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYXNzZXRcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0QXNzZXRQYXRoIChhc3NldCkge1xuICAgIHZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5hc3NldHNVcmwgKyBcIi9cIiArIGFzc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuICAgICAgcmV0dXJuIHBhdGgucmVzb2x2ZSh0aGlzLl9vcHRpb25zLmFzc2V0c1VybCwgYXNzZXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYWxsIGRlZmF1bHQgVUlzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVnaXN0ZXJVSXMgKCkge1xuICAgIHRoaXMucmVnaXN0ZXJVSShOaWdodFVJKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYWxsIGRlZmF1bHQgb3BlcmF0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlZ2lzdGVyT3BlcmF0aW9ucyAoKSB7XG4gICAgZm9yIChsZXQgb3BlcmF0aW9uTmFtZSBpbiBJbWdseUtpdC5PcGVyYXRpb25zKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyT3BlcmF0aW9uKEltZ2x5S2l0Lk9wZXJhdGlvbnNbb3BlcmF0aW9uTmFtZV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgdGhlIGdpdmVuIG9wZXJhdGlvblxuICAgKiBAcGFyYW0ge0ltZ2x5S2l0Lk9wZXJhdGlvbn0gb3BlcmF0aW9uIC0gVGhlIG9wZXJhdGlvbiBjbGFzc1xuICAgKi9cbiAgcmVnaXN0ZXJPcGVyYXRpb24gKG9wZXJhdGlvbikge1xuICAgIHRoaXMuX3JlZ2lzdGVyZWRPcGVyYXRpb25zW29wZXJhdGlvbi5wcm90b3R5cGUuaWRlbnRpZmllcl0gPSBvcGVyYXRpb247XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIHRoZSBnaXZlbiBVSVxuICAgKiBAcGFyYW0ge1VJfSB1aVxuICAgKi9cbiAgcmVnaXN0ZXJVSSAodWkpIHtcbiAgICB0aGlzLl9yZWdpc3RlcmVkVUlzW3VpLnByb3RvdHlwZS5pZGVudGlmaWVyXSA9IHVpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBVSVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgX2luaXRVSSAoKSB7XG4gICAgdmFyIFVJO1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMudWkgPT09IHRydWUpIHtcbiAgICAgIC8vIFNlbGVjdCB0aGUgZmlyc3QgVUkgYnkgZGVmYXVsdFxuICAgICAgVUkgPSBVdGlscy52YWx1ZXModGhpcy5fcmVnaXN0ZXJlZFVJcylbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlbGVjdCB0aGUgVUkgd2l0aCB0aGUgZ2l2ZW4gaWRlbnRpZmllclxuICAgICAgVUkgPSB0aGlzLl9yZWdpc3RlcmVkVUlzW3RoaXMuX29wdGlvbnMudWldO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIFVJIGV4aXN0c1xuICAgIGlmICh0eXBlb2YgVUkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkltZ2x5S2l0OiBVbmtub3duIFVJOiBcIiArIHRoaXMuX29wdGlvbnMudWkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJbWdseUtpdC5VSX1cbiAgICAgKi9cbiAgICBsZXQgeyBjb250YWluZXIsIGFzc2V0c1VybCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICB0aGlzLnVpID0gbmV3IFVJKHRoaXMsIHsgY29udGFpbmVyLCBhc3NldHNVcmwgfSk7XG4gIH1cblxuICBnZXQgcmVnaXN0ZXJlZE9wZXJhdGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWdpc3RlcmVkT3BlcmF0aW9ucztcbiAgfVxuXG4gIHJ1biAoKSB7XG4gICAgdGhpcy51aS5ydW4oKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgdGhlIFNES1xuICogQG5hbWUgSW1nbHlLaXQudmVyc2lvblxuICogQGludGVybmFsIEtlZXAgaW4gc3luYyB3aXRoIHBhY2thZ2UuanNvblxuICovXG5JbWdseUtpdC52ZXJzaW9uID0gXCIwLjAuMVwiO1xuXG4vLyBFeHBvc2VkIGNsYXNzZXNcbkltZ2x5S2l0LlJlbmRlckltYWdlID0gUmVuZGVySW1hZ2U7XG5JbWdseUtpdC5Db2xvciA9IHJlcXVpcmUoXCIuL2xpYi9jb2xvclwiKTtcbkltZ2x5S2l0Lk9wZXJhdGlvbiA9IHJlcXVpcmUoXCIuL29wZXJhdGlvbnMvb3BlcmF0aW9uXCIpO1xuSW1nbHlLaXQuT3BlcmF0aW9ucyA9IHt9O1xuSW1nbHlLaXQuT3BlcmF0aW9ucy5GaWx0ZXJzT3BlcmF0aW9uID0gcmVxdWlyZShcIi4vb3BlcmF0aW9ucy9maWx0ZXJzLW9wZXJhdGlvblwiKTtcbkltZ2x5S2l0Lk9wZXJhdGlvbnMuUm90YXRpb25PcGVyYXRpb24gPSByZXF1aXJlKFwiLi9vcGVyYXRpb25zL3JvdGF0aW9uLW9wZXJhdGlvblwiKTtcbkltZ2x5S2l0Lk9wZXJhdGlvbnMuQ3JvcE9wZXJhdGlvbiA9IHJlcXVpcmUoXCIuL29wZXJhdGlvbnMvY3JvcC1vcGVyYXRpb25cIik7XG5JbWdseUtpdC5PcGVyYXRpb25zLlNhdHVyYXRpb25PcGVyYXRpb24gPSByZXF1aXJlKFwiLi9vcGVyYXRpb25zL3NhdHVyYXRpb24tb3BlcmF0aW9uXCIpO1xuSW1nbHlLaXQuT3BlcmF0aW9ucy5Db250cmFzdE9wZXJhdGlvbiA9IHJlcXVpcmUoXCIuL29wZXJhdGlvbnMvY29udHJhc3Qtb3BlcmF0aW9uXCIpO1xuSW1nbHlLaXQuT3BlcmF0aW9ucy5CcmlnaHRuZXNzT3BlcmF0aW9uID0gcmVxdWlyZShcIi4vb3BlcmF0aW9ucy9icmlnaHRuZXNzLW9wZXJhdGlvblwiKTtcbkltZ2x5S2l0Lk9wZXJhdGlvbnMuRmxpcE9wZXJhdGlvbiA9IHJlcXVpcmUoXCIuL29wZXJhdGlvbnMvZmxpcC1vcGVyYXRpb25cIik7XG5JbWdseUtpdC5PcGVyYXRpb25zLlRpbHRTaGlmdE9wZXJhdGlvbiA9IHJlcXVpcmUoXCIuL29wZXJhdGlvbnMvdGlsdC1zaGlmdC1vcGVyYXRpb25cIik7XG5JbWdseUtpdC5PcGVyYXRpb25zLlJhZGlhbEJsdXJPcGVyYXRpb24gPSByZXF1aXJlKFwiLi9vcGVyYXRpb25zL3JhZGlhbC1ibHVyLW9wZXJhdGlvblwiKTtcbkltZ2x5S2l0Lk9wZXJhdGlvbnMuVGV4dE9wZXJhdGlvbiA9IHJlcXVpcmUoXCIuL29wZXJhdGlvbnMvdGV4dC1vcGVyYXRpb25cIik7XG5JbWdseUtpdC5PcGVyYXRpb25zLlN0aWNrZXJzT3BlcmF0aW9uID0gcmVxdWlyZShcIi4vb3BlcmF0aW9ucy9zdGlja2Vycy1vcGVyYXRpb25cIik7XG5JbWdseUtpdC5PcGVyYXRpb25zLkZyYW1lc09wZXJhdGlvbiA9IHJlcXVpcmUoXCIuL29wZXJhdGlvbnMvZnJhbWVzLW9wZXJhdGlvblwiKTtcblxuLy8gRXhwb3NlZCBjb25zdGFudHNcbkltZ2x5S2l0LlJlbmRlclR5cGUgPSBSZW5kZXJUeXBlO1xuSW1nbHlLaXQuSW1hZ2VGb3JtYXQgPSBJbWFnZUZvcm1hdDtcbkltZ2x5S2l0LlZlY3RvcjIgPSByZXF1aXJlKFwiLi9saWIvbWF0aC92ZWN0b3IyXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBJbWdseUtpdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb2xvclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuQ29sb3JcbiAqIEBwYXJhbSB7TnVtYmVyfSByXG4gKiBAcGFyYW0ge051bWJlcn0gZ1xuICogQHBhcmFtIHtOdW1iZXJ9IGJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYV1cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbG9yIHtcbiAgY29uc3RydWN0b3IgKHIsIGcsIGIsIGEpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09IFwidW5kZWZpbmVkXCIpIGEgPSAxLjA7XG5cbiAgICB0aGlzLnIgPSByO1xuICAgIHRoaXMuZyA9IGc7XG4gICAgdGhpcy5iID0gYjtcbiAgICB0aGlzLmEgPSBhO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gcmdiYSgpIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29sb3JcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgdG9SR0JBICgpIHtcbiAgICB2YXIgY29sb3JzID0gW1xuICAgICAgdGhpcy5yICogMjU1LFxuICAgICAgdGhpcy5nICogMjU1LFxuICAgICAgdGhpcy5iICogMjU1LFxuICAgICAgdGhpcy5hXG4gICAgXTtcbiAgICByZXR1cm4gXCJyZ2JhKFwiICsgY29sb3JzLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbG9yXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvSGV4ICgpIHtcbiAgICB2YXIgY29tcG9uZW50cyA9IFtcbiAgICAgIHRoaXMuX2NvbXBvbmVudFRvSGV4KHRoaXMuciAqIDI1NSksXG4gICAgICB0aGlzLl9jb21wb25lbnRUb0hleCh0aGlzLmcgKiAyNTUpLFxuICAgICAgdGhpcy5fY29tcG9uZW50VG9IZXgodGhpcy5iICogMjU1KVxuICAgIF07XG4gICAgcmV0dXJuIFwiI1wiICsgY29tcG9uZW50cy5qb2luKFwiXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCA0IHZhbHVlcyAoMC4uLjEpXG4gICAqIEByZXR1cm4ge0FycmF5LjxOdW1iZXI+fVxuICAgKi9cbiAgdG9HTENvbG9yICgpIHtcbiAgICByZXR1cm4gW3RoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYV07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSB3aXRoIDMgdmFsdWVzICgwLi4uMSlcbiAgICogQHJldHVybiB7QXJyYXkuPE51bWJlcj59XG4gICAqL1xuICB0b1JHQkdMQ29sb3IgKCkge1xuICAgIHJldHVybiBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYl07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ2l2ZW4gbnVtYmVyIGFzIGhleFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcG9uZW50VG9IZXggKGNvbXBvbmVudCkge1xuICAgIHZhciBoZXggPSBjb21wb25lbnQudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoID09IDEgPyBcIjBcIiArIGhleCA6IGhleDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2xvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBFdmVudEVtaXR0ZXIgKEVTNikgZnJvbTpcbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2Jsb29keW93bC80MWIxZGUzMzg4YzYyNjc5NmVjYVxuICovXG5cbmNvbnN0IERFRkFVTFRfTUFYX0xJU1RFTkVSUyA9IDEyO1xuXG5mdW5jdGlvbiBlcnJvciAobWVzc2FnZSwgLi4uYXJncykge1xuICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIFttZXNzYWdlXS5jb25jYXQoYXJncykpO1xuICBjb25zb2xlLnRyYWNlKCk7XG59XG5cbmNsYXNzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBERUZBVUxUX01BWF9MSVNURU5FUlM7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gIH1cblxuICBvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZih0eXBlb2YgbGlzdGVuZXIgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfVxuXG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXSB8fCh0aGlzLl9ldmVudHNbdHlwZV0gPSBbXSk7XG4gICAgaWYgKGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKSAhPSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gdGhpcy5fbWF4TGlzdGVuZXJzKSB7XG4gICAgICBlcnJvcihcbiAgICAgICAgXCJwb3NzaWJsZSBtZW1vcnkgbGVhaywgYWRkZWQgJWkgJXMgbGlzdGVuZXJzLCBcIitcbiAgICAgICAgXCJ1c2UgRXZlbnRFbWl0dGVyI3NldE1heExpc3RlbmVycyhudW1iZXIpIGlmIHlvdSBcIiArXG4gICAgICAgIFwid2FudCB0byBpbmNyZWFzZSB0aGUgbGltaXQgKCVpIG5vdylcIixcbiAgICAgICAgbGlzdGVuZXJzLmxlbmd0aCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGhpcy5fbWF4TGlzdGVuZXJzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9uY2UgKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgbGV0IGV2ZW50c0luc3RhbmNlID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbmNlQ2FsbGJhY2sgKCkge1xuICAgICAgZXZlbnRzSW5zdGFuY2Uub2ZmKHR5cGUsIG9uY2VDYWxsYmFjayk7XG4gICAgICBsaXN0ZW5lci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vbih0eXBlLCBvbmNlQ2FsbGJhY2spO1xuICB9XG5cbiAgb2ZmICh0eXBlLCAuLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBudWxsO1xuICAgIH1cblxuICAgIGxldCBsaXN0ZW5lciA9IGFyZ3NbMF07XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9XG5cbiAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICghbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBsZXQgaW5kZXhPZkxpc3RlbmVyID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgIGlmIChpbmRleE9mTGlzdGVuZXIgPT0gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXhPZkxpc3RlbmVyLCAxKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGVtaXQgKHR5cGUsIC4uLmFyZ3MpIHtcbiAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmKCFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmbiA9PiBmbi5hcHBseShudWxsLCBhcmdzKSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHNldE1heExpc3RlbmVycyAobmV3TWF4TGlzdGVuZXJzKSB7XG4gICAgaWYgKHBhcnNlSW50KG5ld01heExpc3RlbmVycykgIT09IG5ld01heExpc3RlbmVycykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH1cblxuICAgIHRoaXMuX21heExpc3RlbmVycyA9IG5ld01heExpc3RlbmVycztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFdmVudEVtaXR0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29ycmVjdGx5IHNldCB1cCB0aGUgcHJvdG90eXBlIGNoYWluXG4gKiBCYXNlZCBvbiB0aGUgYmFja2JvbmUuanMgZXh0ZW5kIGZ1bmN0aW9uOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy9iYWNrYm9uZS9ibG9iL21hc3Rlci9iYWNrYm9uZS5qc1xuICogQHBhcmFtICB7T2JqZWN0fSBwcm90b3R5cGVQcm9wZXJ0aWVzXG4gKiBAcGFyYW0gIHtPYmplY3R9IGNsYXNzUHJvcGVydGllc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHByb3RvdHlwZVByb3BlcnRpZXMsIGNsYXNzUHJvcGVydGllcykge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSovXG4gIHZhciBwYXJlbnQgPSB0aGlzO1xuICB2YXIgY2hpbGQ7XG5cbiAgLy8gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgbmV3IHN1YmNsYXNzIGlzIGVpdGhlciBkZWZpbmVkIGJ5IHlvdVxuICAvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcbiAgLy8gYnkgdXMgdG8gc2ltcGx5IGNhbGwgdGhlIHBhcmVudCdzIGNvbnN0cnVjdG9yLlxuICBpZiAocHJvdG90eXBlUHJvcGVydGllcyAmJlxuICAgIHByb3RvdHlwZVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgY2hpbGQgPSBwcm90b3R5cGVQcm9wZXJ0aWVzLmNvbnN0cnVjdG9yO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkID0gZnVuY3Rpb24oKXsgcmV0dXJuIHBhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICB9XG5cbiAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbiAgfVxuICBpZiAodHlwZW9mIGNsYXNzUHJvcGVydGllcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGZvciAoa2V5IGluIGNsYXNzUHJvcGVydGllcykge1xuICAgICAgY2hpbGRba2V5XSA9IGNsYXNzUHJvcGVydGllc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNldCB0aGUgcHJvdG90eXBlIGNoYWluIHRvIGluaGVyaXQgZnJvbSBgcGFyZW50YCwgd2l0aG91dCBjYWxsaW5nXG4gIC8vIGBwYXJlbnRgJ3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gIHZhciBTdXJyb2dhdGUgPSBmdW5jdGlvbigpeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH07XG4gIFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgU3Vycm9nYXRlKCk7XG5cbiAgLy8gQWRkIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChpbnN0YW5jZSBwcm9wZXJ0aWVzKSB0byB0aGUgc3ViY2xhc3MsXG4gIC8vIGlmIHN1cHBsaWVkLlxuICBpZiAocHJvdG90eXBlUHJvcGVydGllcykge1xuICAgIGZvciAoa2V5IGluIHByb3RvdHlwZVByb3BlcnRpZXMpIHtcbiAgICAgIGNoaWxkLnByb3RvdHlwZVtrZXldID0gcHJvdG90eXBlUHJvcGVydGllc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNldCBhIGNvbnZlbmllbmNlIHByb3BlcnR5IGluIGNhc2UgdGhlIHBhcmVudCdzIHByb3RvdHlwZSBpcyBuZWVkZWRcbiAgLy8gbGF0ZXIuXG4gIGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XG5cbiAgcmV0dXJuIGNoaWxkO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZGltZW5zaW9ucyBzdHJpbmcgYW5kIHByb3ZpZGVzIGNhbGN1bGF0aW9uIGZ1bmN0aW9uc1xuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuSW1hZ2VEaW1lbnNpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gZGltZW5zaW9uc1xuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgSW1hZ2VEaW1lbnNpb25zIHtcbiAgY29uc3RydWN0b3IgKGRpbWVuc2lvbnMpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYXZhaWxhYmxlIGRpbWVuc2lvbiBtb2RpZmllcnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbW9kaWZpZXJzID0ge1xuICAgICAgRklYRUQ6IFwiIVwiXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9kaW1lbnNpb25zU3RyaW5nID0gZGltZW5zaW9ucztcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhcnNlZCBkaW1lbnNpb25zIHN0cmluZ1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fcnVsZXMgPSB0aGlzLl9wYXJzZSgpO1xuXG4gICAgdGhpcy5fdmFsaWRhdGVSdWxlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZGltZW5zaW9ucyBzdHJpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wYXJzZSAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9kaW1lbnNpb25zU3RyaW5nID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2ggPSB0aGlzLl9kaW1lbnNpb25zU3RyaW5nLm1hdGNoKC9eKFswLTldKyk/eChbMC05XSspPyhbXFwhXSk/JC9pKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpemUgb3B0aW9uOiBcIiArIHRoaXMuX2RpbWVuc2lvbnNTdHJpbmcpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4OiBpc05hTihtYXRjaFsxXSkgPyBudWxsIDogcGFyc2VJbnQobWF0Y2hbMV0pLFxuICAgICAgeTogaXNOYU4obWF0Y2hbMl0pID8gbnVsbCA6IHBhcnNlSW50KG1hdGNoWzJdKSxcbiAgICAgIG1vZGlmaWVyOiBtYXRjaFszXVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBydWxlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ZhbGlkYXRlUnVsZXMgKCkge1xuICAgIGlmICh0aGlzLl9ydWxlcyA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgdmFyIHhBdmFpbGFibGUgPSB0aGlzLl9ydWxlcy54ICE9PSBudWxsO1xuICAgIHZhciB5QXZhaWxhYmxlID0gdGhpcy5fcnVsZXMueSAhPT0gbnVsbDtcblxuICAgIGlmICh0aGlzLl9ydWxlcy5tb2RpZmllciA9PT0gdGhpcy5fbW9kaWZpZXJzLkZJWEVEICYmICEoeEF2YWlsYWJsZSAmJiB5QXZhaWxhYmxlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm90aCBgeGAgYW5kIGB5YCBoYXZlIHRvIGJlIHNldCB3aGVuIHVzaW5nIHRoZSBmaXhlZCAoISkgbW9kaWZpZXIuXCIpO1xuICAgIH1cblxuICAgIGlmICgheEF2YWlsYWJsZSAmJiAheUF2YWlsYWJsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmVpdGhlciBgeGAgbm9yIGB5YCBhcmUgZ2l2ZW4uXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBmaW5hbCBkaW1lbnNpb25zIHVzaW5nIHRoZSBkaW1lbnNpb25zIHN0cmluZyBhbmQgdGhlXG4gICAqIGdpdmVuIGluaXRpYWwgZGltZW5zaW9uc1xuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBpbml0aWFsRGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgKi9cbiAgY2FsY3VsYXRlRmluYWxEaW1lbnNpb25zIChpbml0aWFsRGltZW5zaW9ucykge1xuICAgIHZhciBkaW1lbnNpb25zID0gaW5pdGlhbERpbWVuc2lvbnMuY2xvbmUoKSwgcmF0aW87XG5cbiAgICBpZiAodGhpcy5fcnVsZXMgPT09IG51bGwpIHJldHVybiBkaW1lbnNpb25zO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodGhpcy5fcnVsZXMubW9kaWZpZXIgPT09IHRoaXMuX21vZGlmaWVycy5GSVhFRCkge1xuICAgICAgLy8gRml4ZWQgZGltZW5zaW9uc1xuICAgICAgZGltZW5zaW9ucy5zZXQodGhpcy5fcnVsZXMueCwgdGhpcy5fcnVsZXMueSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9ydWxlcy54ICE9PSBudWxsICYmIHRoaXMuX3J1bGVzLnkgIT09IG51bGwpIHtcbiAgICAgIC8vIEJvdGggeCBhbmQgeSBnaXZlbiwgcmVzaXplIHRvIGZpdFxuICAgICAgcmF0aW8gPSBNYXRoLm1pbih0aGlzLl9ydWxlcy54IC8gZGltZW5zaW9ucy54LCB0aGlzLl9ydWxlcy55IC8gZGltZW5zaW9ucy55KTtcbiAgICAgIGRpbWVuc2lvbnMubXVsdGlwbHkocmF0aW8pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcnVsZXMueCAhPT0gbnVsbCkge1xuICAgICAgLy8gRml4ZWQgeCwgeSBieSByYXRpb1xuICAgICAgcmF0aW8gPSBpbml0aWFsRGltZW5zaW9ucy55IC8gaW5pdGlhbERpbWVuc2lvbnMueDtcbiAgICAgIGRpbWVuc2lvbnMueCA9IHRoaXMuX3J1bGVzLng7XG4gICAgICBkaW1lbnNpb25zLnkgPSBkaW1lbnNpb25zLnggKiByYXRpbztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3J1bGVzLnkgIT09IG51bGwpIHtcbiAgICAgIC8vIEZpeGVkIHksIHggYnkgcmF0aW9cbiAgICAgIHJhdGlvID0gaW5pdGlhbERpbWVuc2lvbnMueCAvIGluaXRpYWxEaW1lbnNpb25zLnk7XG4gICAgICBkaW1lbnNpb25zLnkgPSB0aGlzLl9ydWxlcy55O1xuICAgICAgZGltZW5zaW9ucy54ID0gZGltZW5zaW9ucy55ICogcmF0aW87XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpbWVuc2lvbnM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VEaW1lbnNpb25zO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5pbXBvcnQgeyBSZW5kZXJUeXBlLCBJbWFnZUZvcm1hdCB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi91dGlsc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkltYWdlRXhwb3J0ZXJcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEltYWdlRXhwb3J0ZXIge1xuXG4gIHN0YXRpYyB2YWxpZGF0ZVNldHRpbmdzIChyZW5kZXJUeXBlLCBpbWFnZUZvcm1hdCkge1xuICAgIHZhciBzZXR0aW5ncyA9IHtcbiAgICAgIHJlbmRlclR5cGU6IHJlbmRlclR5cGUsXG4gICAgICBpbWFnZUZvcm1hdDogaW1hZ2VGb3JtYXRcbiAgICB9O1xuXG4gICAgLy8gVmFsaWRhdGUgUmVuZGVyVHlwZVxuICAgIGlmICgodHlwZW9mIHNldHRpbmdzLnJlbmRlclR5cGUgIT09IFwidW5kZWZpbmVkXCIgJiYgc2V0dGluZ3MucmVuZGVyVHlwZSAhPT0gbnVsbCkgJiZcbiAgICAgIFV0aWxzLnZhbHVlcyhSZW5kZXJUeXBlKS5pbmRleE9mKHNldHRpbmdzLnJlbmRlclR5cGUpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlbmRlciB0eXBlOiBcIiArIHNldHRpbmdzLnJlbmRlclR5cGUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlbmRlclR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHNldHRpbmdzLnJlbmRlclR5cGUgPSBSZW5kZXJUeXBlLkRBVEFfVVJMO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIEltYWdlRm9ybWF0XG4gICAgaWYgKCh0eXBlb2Ygc2V0dGluZ3MuaW1hZ2VGb3JtYXQgIT09IFwidW5kZWZpbmVkXCIgJiYgc2V0dGluZ3MuaW1hZ2VGb3JtYXQgIT09IG51bGwpICYmXG4gICAgICBVdGlscy52YWx1ZXMoSW1hZ2VGb3JtYXQpLmluZGV4T2Yoc2V0dGluZ3MuaW1hZ2VGb3JtYXQpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGltYWdlIGZvcm1hdDogXCIgKyBzZXR0aW5ncy5pbWFnZUZvcm1hdCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW1hZ2VGb3JtYXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHNldHRpbmdzLmltYWdlRm9ybWF0ID0gSW1hZ2VGb3JtYXQuUE5HO1xuICAgIH1cblxuICAgIHJldHVybiBzZXR0aW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnRzIHRoZSBpbWFnZSBmcm9tIHRoZSBnaXZlbiBjYW52YXMgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtDYW52YXN9IGNhbnZhc1xuICAgKiBAcGFyYW0gIHtJbWdseUtpdC5SZW5kZXJUeXBlfSByZW5kZXJUeXBlXG4gICAqIEBwYXJhbSAge0ltZ2x5S2l0LkltYWdlRm9ybWF0fSBpbWFnZUZvcm1hdFxuICAgKiBAcmV0dXJuIHtzdHJpbmd8aW1hZ2V9XG4gICAqL1xuICBzdGF0aWMgZXhwb3J0IChjYW52YXMsIHJlbmRlclR5cGUsIGltYWdlRm9ybWF0KSB7XG4gICAgdmFyIHJlc3VsdCA9IGNhbnZhcy50b0RhdGFVUkwoaW1hZ2VGb3JtYXQpO1xuICAgIGlmIChyZW5kZXJUeXBlID09IFJlbmRlclR5cGUuSU1BR0UpIHtcbiAgICAgIHZhciBpbWFnZTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBOb3QgYSBicm93c2VyIGVudmlyb25tZW50XG4gICAgICAgIHZhciBDYW52YXNJbWFnZSA9IHJlcXVpcmUoXCJjYW52YXNcIikuSW1hZ2U7XG4gICAgICAgIGltYWdlID0gbmV3IENhbnZhc0ltYWdlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgfVxuXG4gICAgICBpbWFnZS5zcmMgPSByZXN1bHQ7XG4gICAgICByZXN1bHQgPSBpbWFnZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlRXhwb3J0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgMi1kaW1lbnNpb25hbCB2ZWN0b3Igd2hpbGUgcHJvdmlkaW5nIG1hdGggZnVuY3Rpb25zIHRvXG4gKiBtb2RpZnkgLyBjbG9uZSB0aGUgdmVjdG9yLiBGdWxseSBjaGFpbmFibGUuXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5WZWN0b3IyXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFZlY3RvcjIge1xuICBjb25zdHJ1Y3RvciAoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICBpZiAodHlwZW9mIHRoaXMueCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy54ID0gMDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRoaXMueSA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIHZhbHVlc1xuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgKi9cbiAgc2V0ICh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHZlY3RvclxuICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLngsIHRoaXMueSk7XG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIHZlY3RvclxuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBvdGhlclxuICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgKi9cbiAgY29weSAob3RoZXIpIHtcbiAgICB0aGlzLnggPSBvdGhlci54O1xuICAgIHRoaXMueSA9IG90aGVyLnk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2xhbXBzIHRoaXMgdmVjdG9yIHdpdGggdGhlIGdpdmVuIFZlY3RvcjIgLyBudW1iZXJcbiAgICogQHBhcmFtICB7KG51bWJlcnxWZWN0b3IyKX0gbWluaW11bVxuICAgKiBAcGFyYW0gIHsobnVtYmVyfFZlY3RvcjIpfSBtYXhpbXVtXG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAqL1xuICBjbGFtcCAobWluaW11bSwgbWF4aW11bSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuICAgIGlmICghKG1pbmltdW0gaW5zdGFuY2VvZiBWZWN0b3IyKSkge1xuICAgICAgbWluaW11bSA9IG5ldyBWZWN0b3IyKG1pbmltdW0sIG1pbmltdW0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cbiAgICBpZiAoIShtYXhpbXVtIGluc3RhbmNlb2YgVmVjdG9yMikpIHtcbiAgICAgIG1heGltdW0gPSBuZXcgVmVjdG9yMihtYXhpbXVtLCBtYXhpbXVtKTtcbiAgICB9XG4gICAgdGhpcy54ID0gTWF0aC5tYXgobWluaW11bS54LCBNYXRoLm1pbihtYXhpbXVtLngsIHRoaXMueCkpO1xuICAgIHRoaXMueSA9IE1hdGgubWF4KG1pbmltdW0ueSwgTWF0aC5taW4obWF4aW11bS55LCB0aGlzLnkpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXZpZGVzIHRoaXMgdmVjdG9yIGJ5IHRoZSBnaXZlbiBWZWN0b3IyIC8gbnVtYmVyXG4gICAqIEBwYXJhbSAgeyhudW1iZXJ8VmVjdG9yMil9IGRpdmlzb3JcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbeV1cbiAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICovXG4gIGRpdmlkZSAoZGl2aXNvciwgeSkge1xuICAgIGlmIChkaXZpc29yIGluc3RhbmNlb2YgVmVjdG9yMikge1xuICAgICAgdGhpcy54IC89IGRpdmlzb3IueDtcbiAgICAgIHRoaXMueSAvPSBkaXZpc29yLnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueCAvPSBkaXZpc29yO1xuICAgICAgdGhpcy55IC89ICh0eXBlb2YgeSA9PT0gXCJ1bmRlZmluZWRcIiA/IGRpdmlzb3IgOiB5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU3VidHJhY3RzIHRoZSBnaXZlbiBWZWN0b3IyIC8gbnVtYmVyIGZyb20gdGhpcyB2ZWN0b3JcbiAgICogQHBhcmFtICB7KG51bWJlcnxWZWN0b3IyKX0gc3VidHJhaGVuZFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFt5XVxuICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgKi9cbiAgc3VidHJhY3QgKHN1YnRyYWhlbmQsIHkpIHtcbiAgICBpZiAoc3VidHJhaGVuZCBpbnN0YW5jZW9mIFZlY3RvcjIpIHtcbiAgICAgIHRoaXMueCAtPSBzdWJ0cmFoZW5kLng7XG4gICAgICB0aGlzLnkgLT0gc3VidHJhaGVuZC55O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnggLT0gc3VidHJhaGVuZDtcbiAgICAgIHRoaXMueSAtPSAodHlwZW9mIHkgPT09IFwidW5kZWZpbmVkXCIgPyBzdWJ0cmFoZW5kIDogeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgdGhlIGdpdmVuIFZlY3RvcjIgLyBudW1iZXIgd2l0aCB0aGlzIHZlY3RvclxuICAgKiBAcGFyYW0gIHsobnVtYmVyfFZlY3RvcjIpfSBzdWJ0cmFoZW5kXG4gICAqIEBwYXJhbSAge251bWJlcn0gW3ldXG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAqL1xuICBtdWx0aXBseSAoZmFjdG9yLCB5KSB7XG4gICAgaWYgKGZhY3RvciBpbnN0YW5jZW9mIFZlY3RvcjIpIHtcbiAgICAgIHRoaXMueCAqPSBmYWN0b3IueDtcbiAgICAgIHRoaXMueSAqPSBmYWN0b3IueTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54ICo9IGZhY3RvcjtcbiAgICAgIHRoaXMueSAqPSAodHlwZW9mIHkgPT09IFwidW5kZWZpbmVkXCIgPyBmYWN0b3IgOiB5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gVmVjdG9yMiAvIG51bWJlcnMgdG8gdGhpcyB2ZWN0b3JcbiAgICogQHBhcmFtIHsobnVtYmVyfFZlY3RvcjIpfSBhZGRlbmRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5XVxuICAgKi9cbiAgYWRkIChhZGRlbmQsIHkpIHtcbiAgICBpZiAoYWRkZW5kIGluc3RhbmNlb2YgVmVjdG9yMikge1xuICAgICAgdGhpcy54ICs9IGFkZGVuZC54O1xuICAgICAgdGhpcy55ICs9IGFkZGVuZC55O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnggKz0gYWRkZW5kO1xuICAgICAgdGhpcy55ICs9ICh0eXBlb2YgeSA9PT0gXCJ1bmRlZmluZWRcIiA/IGFkZGVuZCA6IHkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSB2YWx1ZSBhcmUgdGhlIHNhbWUgYXMgdGhlIGdpdmVuIG9uZXNcbiAgICogQHBhcmFtICB7KG51bWJlcnxWZWN0b3IyKX0gdmVjXG4gICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzICh2ZWMsIHkpIHtcbiAgICBpZiAodmVjIGluc3RhbmNlb2YgVmVjdG9yMikge1xuICAgICAgcmV0dXJuIHZlYy54ID09PSB0aGlzLnggJiYgdmVjLnkgPT09IHRoaXMueTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZlYyA9PT0gdGhpcy54ICYmIHkgPT09IHRoaXMueTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZlY3RvclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIFwiVmVjdG9yMih7IHg6IFwiICsgdGhpcy54ICsgXCIsIHk6IFwiICsgdGhpcy55ICsgXCIgfSlcIjtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFZlY3RvcjI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cbmltcG9ydCBibHVlYmlyZCBmcm9tIFwiYmx1ZWJpcmRcIjtcbmltcG9ydCBJbWFnZURpbWVuc2lvbnMgZnJvbSBcIi4vaW1hZ2UtZGltZW5zaW9uc1wiO1xuaW1wb3J0IFZlY3RvcjIgZnJvbSBcIi4vbWF0aC92ZWN0b3IyXCI7XG5pbXBvcnQgQ2FudmFzUmVuZGVyZXIgZnJvbSBcIi4uL3JlbmRlcmVycy9jYW52YXMtcmVuZGVyZXJcIjtcbmltcG9ydCBXZWJHTFJlbmRlcmVyIGZyb20gXCIuLi9yZW5kZXJlcnMvd2ViZ2wtcmVuZGVyZXJcIjtcblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBpbWFnZSByZW5kZXJpbmcgcHJvY2Vzc1xuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuUmVuZGVySW1hZ2VcbiAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gKiBAcGFyYW0ge0FycmF5LjxJbWdseUtpdC5PcGVyYXRpb24+fSBvcGVyYXRpb25zU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaW1lbnNpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZmVycmVkUmVuZGVyZXJcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFJlbmRlckltYWdlIHtcbiAgY29uc3RydWN0b3IgKGltYWdlLCBvcGVyYXRpb25zU3RhY2ssIGRpbWVuc2lvbnMsIHByZWZlcnJlZFJlbmRlcmVyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICBwcmVmZXJyZWRSZW5kZXJlcjogcHJlZmVycmVkUmVuZGVyZXJcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHRoaXMuX3dlYmdsRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1JlbmRlcmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0ltYWdlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48SW1nbHlLaXQuT3BlcmF0aW9uPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3N0YWNrID0gb3BlcmF0aW9uc1N0YWNrO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0ltZ2x5S2l0LkltYWdlRGltZW5zaW9uc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2RpbWVuc2lvbnMgPSBuZXcgSW1hZ2VEaW1lbnNpb25zKGRpbWVuc2lvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1ZlY3RvcjJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9pbml0aWFsRGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKHRoaXMuX2ltYWdlLndpZHRoLCB0aGlzLl9pbWFnZS5oZWlnaHQpO1xuXG4gICAgdGhpcy5faW5pdFJlbmRlcmVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJlbmRlcmVyIChjYW52YXMgb3Igd2ViZ2wsIGRlcGVuZGluZyBvbiBzdXBwb3J0KVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRSZW5kZXJlciAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKFdlYkdMUmVuZGVyZXIuaXNTdXBwb3J0ZWQoKSAmJiB0aGlzLl9vcHRpb25zLnByZWZlcnJlZFJlbmRlcmVyICE9PSBcImNhbnZhc1wiKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKHRoaXMuX2luaXRpYWxEaW1lbnNpb25zKTtcbiAgICAgIHRoaXMuX3dlYmdsRW5hYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChDYW52YXNSZW5kZXJlci5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlciA9IG5ldyBDYW52YXNSZW5kZXJlcih0aGlzLl9pbml0aWFsRGltZW5zaW9ucyk7XG4gICAgICB0aGlzLl93ZWJnbEVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5fcmVuZGVyZXIgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5laXRoZXIgQ2FudmFzIG5vciBXZWJHTCByZW5kZXJlciBhcmUgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXJlci5kcmF3SW1hZ2UodGhpcy5faW1hZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGltYWdlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICByZW5kZXIgKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gYmx1ZWJpcmRcbiAgICAgIC5tYXAodGhpcy5fc3RhY2ssIGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi52YWxpZGF0ZVNldHRpbmdzKCk7XG4gICAgICB9KVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYmx1ZWJpcmQubWFwKHNlbGYuX3N0YWNrLCBmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5yZW5kZXIoc2VsZi5fcmVuZGVyZXIpO1xuICAgICAgICB9LCB7IGNvbmN1cnJlbmN5OiAxIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLl9yZW5kZXJlci5yZW5kZXJGaW5hbCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbml0aWFsU2l6ZSA9IHNlbGYuX3JlbmRlcmVyLmdldFNpemUoKTtcbiAgICAgICAgdmFyIGZpbmFsRGltZW5zaW9ucyA9IHNlbGYuX2RpbWVuc2lvbnMuY2FsY3VsYXRlRmluYWxEaW1lbnNpb25zKGluaXRpYWxTaXplKTtcblxuICAgICAgICBpZiAoZmluYWxEaW1lbnNpb25zLmVxdWFscyhpbml0aWFsU2l6ZSkpIHtcbiAgICAgICAgICAvLyBObyBuZWVkIHRvIHJlc2l6ZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmLl9yZW5kZXJlci5yZXNpemVUbyhmaW5hbERpbWVuc2lvbnMpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVuZGVyZXJcbiAgICogQHJldHVybiB7UmVuZGVyZXJ9XG4gICAqL1xuICBnZXRSZW5kZXJlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlckltYWdlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbi8qKlxuICogUHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGludGVybmFsIHVzZVxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFV0aWxzIHtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gQXJyYXlcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb2JqZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNBcnJheSAob2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlbXMgc2VsZWN0ZWQgYnkgdGhlIGdpdmVuIHNlbGVjdG9yXG4gICAqIEBwYXJhbSAge0FycmF5fSBpdGVtc1xuICAgKiBAcGFyYW0gIHtJbWdseUtpdH5TZWxlY3Rvcn0gc2VsZWN0b3IgLSBUaGUgc2VsZWN0b3JcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBzZWxlY3RlZCBpdGVtc1xuICAgKi9cbiAgc3RhdGljIHNlbGVjdCAoaXRlbXMsIHNlbGVjdG9yKSB7XG4gICAgaWYgKHNlbGVjdG9yID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuXG4gICAgLy8gVHVybiBzdHJpbmcgcGFyYW1ldGVyIGludG8gYW4gYXJyYXlcbiAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnNwbGl0KFwiLFwiKS5tYXAoZnVuY3Rpb24gKGlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXIudHJpbSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVHVybiBhcnJheSBwYXJhbWV0ZXIgaW50byBhbiBvYmplY3Qgd2l0aCBgb25seWBcbiAgICBpZiAoVXRpbHMuaXNBcnJheShzZWxlY3RvcikpIHtcbiAgICAgIHNlbGVjdG9yID0geyBvbmx5OiBzZWxlY3RvciB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2VsZWN0b3Iub25seSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgLy8gU2VsZWN0IG9ubHkgdGhlIGdpdmVuIGlkZW50aWZpZXJzXG4gICAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rvci5vbmx5LmluZGV4T2YoaXRlbSkgIT09IC0xO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBzZWxlY3Rvci5leGNlcHQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIC8vIFNlbGVjdCBhbGwgYnV0IHRoZSBnaXZlbiBpZGVudGlmaWVyc1xuICAgICAgcmV0dXJuIGl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IuZXhjZXB0LmluZGV4T2YoaXRlbSkgPT09IC0xO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXRpbHMjc2VsZWN0IGZhaWxlZCB0byBmaWx0ZXIgaXRlbXMuXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdpdmVuIG9iamVjdCdzIHZhbHVlcyBhcyBhbiBhcnJheVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEByZXR1cm5zIHtBcnJheTwqPn1cbiAgICovXG4gIHN0YXRpYyB2YWx1ZXMgKG9iamVjdCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICB2YWx1ZXMucHVzaChvYmplY3Rba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBET00gZWxlbWVudFxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBzdGF0aWMgaXNET01FbGVtZW50IChvKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJvYmplY3RcIiA/IG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA6XG4gICAgICBvICYmIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmIG8gIT09IG51bGwgJiYgby5ub2RlVHlwZSA9PT0gMSAmJiB0eXBlb2Ygby5ub2RlTmFtZT09PVwic3RyaW5nXCJcbiAgICApO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVXRpbHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IE9wZXJhdGlvbiBmcm9tIFwiLi9vcGVyYXRpb25cIjtcbmltcG9ydCBQcmltaXRpdmVzU3RhY2sgZnJvbSBcIi4vZmlsdGVycy9wcmltaXRpdmVzLXN0YWNrXCI7XG5pbXBvcnQgQnJpZ2h0bmVzc1ByaW1pdGl2ZSBmcm9tIFwiLi9maWx0ZXJzL3ByaW1pdGl2ZXMvYnJpZ2h0bmVzc1wiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0Lk9wZXJhdGlvbnMuQnJpZ2h0bmVzc09wZXJhdGlvblxuICogQGV4dGVuZHMgSW1nbHlLaXQuT3BlcmF0aW9uXG4gKi9cbmNsYXNzIEJyaWdodG5lc3NPcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHRoaXMuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgICAgIGJyaWdodG5lc3M6IHsgdHlwZTogXCJudW1iZXJcIiwgZGVmYXVsdDogMCB9XG4gICAgfTtcblxuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiBvcGVyYXRpb25zLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiBcImJyaWdodG5lc3NcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICByZW5kZXIgKHJlbmRlcmVyKSB7XG4gICAgdmFyIHN0YWNrID0gbmV3IFByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgc3RhY2suYWRkKG5ldyBCcmlnaHRuZXNzUHJpbWl0aXZlKHtcbiAgICAgIGJyaWdodG5lc3M6IHRoaXMuX29wdGlvbnMuYnJpZ2h0bmVzc1xuICAgIH0pKTtcblxuICAgIHN0YWNrLnJlbmRlcihyZW5kZXJlcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnJpZ2h0bmVzc09wZXJhdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5pbXBvcnQgT3BlcmF0aW9uIGZyb20gXCIuL29wZXJhdGlvblwiO1xuaW1wb3J0IFByaW1pdGl2ZXNTdGFjayBmcm9tIFwiLi9maWx0ZXJzL3ByaW1pdGl2ZXMtc3RhY2tcIjtcbmltcG9ydCBDb250cmFzdFByaW1pdGl2ZSBmcm9tIFwiLi9maWx0ZXJzL3ByaW1pdGl2ZXMvY29udHJhc3RcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5PcGVyYXRpb25zLkNvbnRyYXN0T3BlcmF0aW9uXG4gKiBAZXh0ZW5kcyBJbWdseUtpdC5PcGVyYXRpb25cbiAqL1xuY2xhc3MgQ29udHJhc3RPcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHRoaXMuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgICAgIGNvbnRyYXN0OiB7IHR5cGU6IFwibnVtYmVyXCIsIGRlZmF1bHQ6IDEuMCB9XG4gICAgfTtcblxuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiBvcGVyYXRpb25zLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiBcImNvbnRyYXN0XCI7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJlcikge1xuICAgIHZhciBzdGFjayA9IG5ldyBQcmltaXRpdmVzU3RhY2soKTtcblxuICAgIHN0YWNrLmFkZChuZXcgQ29udHJhc3RQcmltaXRpdmUoe1xuICAgICAgY29udHJhc3Q6IHRoaXMuX29wdGlvbnMuY29udHJhc3RcbiAgICB9KSk7XG5cbiAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRyYXN0T3BlcmF0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBPcGVyYXRpb24gZnJvbSBcIi4vb3BlcmF0aW9uXCI7XG5pbXBvcnQgVmVjdG9yMiBmcm9tIFwiLi4vbGliL21hdGgvdmVjdG9yMlwiO1xuXG4vKipcbiAqIEFuIG9wZXJhdGlvbiB0aGF0IGNhbiBjcm9wIG91dCBhIHBhcnQgb2YgdGhlIGltYWdlXG4gKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuT3BlcmF0aW9ucy5Dcm9wT3BlcmF0aW9uXG4gKiBAZXh0ZW5kcyBJbWdseUtpdC5PcGVyYXRpb25cbiAqL1xuY2xhc3MgQ3JvcE9wZXJhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgdGhpcy5hdmFpbGFibGVPcHRpb25zID0ge1xuICAgICAgc3RhcnQ6IHsgdHlwZTogXCJ2ZWN0b3IyXCIsIHJlcXVpcmVkOiB0cnVlIH0sXG4gICAgICBlbmQ6IHsgdHlwZTogXCJ2ZWN0b3IyXCIsIHJlcXVpcmVkOiB0cnVlIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYWdtZW50IHNoYWRlciB1c2VkIGZvciB0aGlzIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBgXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XG4gICAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcbiAgICAgIHVuaWZvcm0gdmVjMiB1X2Nyb3BTdGFydDtcbiAgICAgIHVuaWZvcm0gdmVjMiB1X2Nyb3BFbmQ7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjMiBzaXplID0gdV9jcm9wRW5kIC0gdV9jcm9wU3RhcnQ7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkICogc2l6ZSArIHVfY3JvcFN0YXJ0KTtcbiAgICAgIH1cbiAgICBgO1xuXG4gICAgc3VwZXIoLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAqIG9wZXJhdGlvbnMuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgaWRlbnRpZmllciAoKSB7XG4gICAgcmV0dXJuIFwiY3JvcFwiO1xuICB9XG5cbiAgLyoqXG4gICAqIENyb3BzIHRoaXMgaW1hZ2UgdXNpbmcgV2ViR0xcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIF9yZW5kZXJXZWJHTCAocmVuZGVyZXIpIHtcbiAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG4gICAgdmFyIGdsID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpO1xuICAgIHZhciBjYW52YXNTaXplID0gbmV3IFZlY3RvcjIoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgIHZhciBzdGFydCA9IHRoaXMuX29wdGlvbnMuc3RhcnQuY2xvbmUoKTtcbiAgICB2YXIgZW5kID0gdGhpcy5fb3B0aW9ucy5lbmQuY2xvbmUoKTtcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLm51bWJlckZvcm1hdCA9PT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICBzdGFydC5kaXZpZGUoY2FudmFzU2l6ZSk7XG4gICAgICBlbmQuZGl2aWRlKGNhbnZhc1NpemUpO1xuICAgIH1cblxuICAgIC8vIDAuLjEgPiAxLi4wIG9uIHktYXhpc1xuICAgIHZhciBvcmlnaW5hbFN0YXJ0WSA9IHN0YXJ0Lnk7XG4gICAgc3RhcnQueSA9IDEgLSBlbmQueTtcbiAgICBlbmQueSA9IDEgLSBvcmlnaW5hbFN0YXJ0WTtcblxuICAgIC8vIFRoZSBuZXcgc2l6ZVxuICAgIHZhciBuZXdEaW1lbnNpb25zID0gdGhpcy5fZ2V0TmV3RGltZW5zaW9ucyhyZW5kZXJlcik7XG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmVzaXplIHRoZSBpbnB1dCB0ZXh0dXJlXG4gICAgdmFyIGxhc3RUZXh0dXJlID0gcmVuZGVyZXIuZ2V0TGFzdFRleHR1cmUoKTtcblxuICAgIC8vIFJlc2l6ZSBhbGwgdGV4dHVyZXMgZXhjZXB0IHRoZSBvbmUgd2UgdXNlIGFzIGlucHV0XG4gICAgdmFyIHRleHR1cmVzID0gcmVuZGVyZXIuZ2V0VGV4dHVyZXMoKTtcbiAgICB2YXIgdGV4dHVyZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0ZXh0dXJlID0gdGV4dHVyZXNbaV07XG4gICAgICBpZiAodGV4dHVyZSA9PT0gbGFzdFRleHR1cmUpIGNvbnRpbnVlO1xuXG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgbmV3RGltZW5zaW9ucy54LCBuZXdEaW1lbnNpb25zLnksIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgIH1cblxuICAgIC8vIFJlc2l6ZSB0aGUgY2FudmFzXG4gICAgY2FudmFzLndpZHRoID0gbmV3RGltZW5zaW9ucy54O1xuICAgIGNhbnZhcy5oZWlnaHQgPSBuZXdEaW1lbnNpb25zLnk7XG5cbiAgICAvLyBSdW4gdGhlIGNyb3BwaW5nIHNoYWRlclxuICAgIHJlbmRlcmVyLnJ1blNoYWRlcihudWxsLCB0aGlzLmZyYWdtZW50U2hhZGVyLCB7XG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICB1X2Nyb3BTdGFydDogeyB0eXBlOiBcIjJmXCIsIHZhbHVlOiBbc3RhcnQueCwgc3RhcnQueV0gfSxcbiAgICAgICAgdV9jcm9wRW5kOiB7IHR5cGU6IFwiMmZcIiwgdmFsdWU6IFtlbmQueCwgZW5kLnldIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlc2l6ZSB0aGUgaW5wdXQgdGV4dHVyZVxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGxhc3RUZXh0dXJlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIG5ld0RpbWVuc2lvbnMueCwgbmV3RGltZW5zaW9ucy55LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcm9wcyB0aGUgaW1hZ2UgdXNpbmcgQ2FudmFzMkRcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqL1xuICBfcmVuZGVyQ2FudmFzIChyZW5kZXJlcikge1xuICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcbiAgICB2YXIgZGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICB2YXIgbmV3RGltZW5zaW9ucyA9IHRoaXMuX2dldE5ld0RpbWVuc2lvbnMocmVuZGVyZXIpO1xuXG4gICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGNhbnZhcyB0byBkcmF3IHRvXG4gICAgdmFyIG5ld0NhbnZhcyA9IHJlbmRlcmVyLmNyZWF0ZUNhbnZhcygpO1xuICAgIG5ld0NhbnZhcy53aWR0aCA9IG5ld0RpbWVuc2lvbnMueDtcbiAgICBuZXdDYW52YXMuaGVpZ2h0ID0gbmV3RGltZW5zaW9ucy55O1xuICAgIHZhciBuZXdDb250ZXh0ID0gbmV3Q2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgIC8vIFRoZSB1cHBlciBsZWZ0IGNvcm5lciBvZiB0aGUgY3JvcHBlZCBhcmVhIG9uIHRoZSBvcmlnaW5hbCBpbWFnZVxuICAgIHZhciBzdGFydFBvc2l0aW9uID0gdGhpcy5fb3B0aW9ucy5zdGFydC5jbG9uZSgpO1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMubnVtYmVyRm9ybWF0ID09PSBcInJlbGF0aXZlXCIpIHtcbiAgICAgIHN0YXJ0UG9zaXRpb24ubXVsdGlwbHkoZGltZW5zaW9ucyk7XG4gICAgfVxuXG4gICAgLy8gRHJhdyB0aGUgc291cmNlIGNhbnZhcyBvbnRvIHRoZSBuZXcgb25lXG4gICAgbmV3Q29udGV4dC5kcmF3SW1hZ2UoY2FudmFzLFxuICAgICAgc3RhcnRQb3NpdGlvbi54LCBzdGFydFBvc2l0aW9uLnksIC8vIHNvdXJjZSB4LCB5XG4gICAgICBuZXdEaW1lbnNpb25zLngsIG5ld0RpbWVuc2lvbnMueSwgLy8gc291cmNlIGRpbWVuc2lvbnNcbiAgICAgIDAsIDAsIC8vIGRlc3RpbmF0aW9uIHgsIHlcbiAgICAgIG5ld0RpbWVuc2lvbnMueCwgbmV3RGltZW5zaW9ucy55IC8vIGRlc3RpbmF0aW9uIGRpbWVuc2lvbnNcbiAgICAgICk7XG5cbiAgICAvLyBTZXQgdGhlIG5ldyBjYW52YXNcbiAgICByZW5kZXJlci5zZXRDYW52YXMobmV3Q2FudmFzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBuZXcgZGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldE5ld0RpbWVuc2lvbnMgKHJlbmRlcmVyKSB7XG4gICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgIHZhciBkaW1lbnNpb25zID0gbmV3IFZlY3RvcjIoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgIHZhciBuZXdEaW1lbnNpb25zID0gdGhpcy5fb3B0aW9ucy5lbmRcbiAgICAgIC5jbG9uZSgpXG4gICAgICAuc3VidHJhY3QodGhpcy5fb3B0aW9ucy5zdGFydCk7XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5udW1iZXJGb3JtYXQgPT09IFwicmVsYXRpdmVcIikge1xuICAgICAgbmV3RGltZW5zaW9ucy5tdWx0aXBseShkaW1lbnNpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RGltZW5zaW9ucztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDcm9wT3BlcmF0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBPcGVyYXRpb24gZnJvbSBcIi4vb3BlcmF0aW9uXCI7XG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIHRoYXQgY2FuIGFwcGx5IGEgc2VsZWN0ZWQgZmlsdGVyXG4gKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuT3BlcmF0aW9ucy5GaWx0ZXJzT3BlcmF0aW9uXG4gKiBAZXh0ZW5kcyBJbWdseUtpdC5PcGVyYXRpb25cbiAqL1xuY2xhc3MgRmlsdGVyc09wZXJhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgdGhpcy5hdmFpbGFibGVPcHRpb25zID0ge1xuICAgICAgZmlsdGVyOiB7IHR5cGU6IFwic3RyaW5nXCIsIGRlZmF1bHQ6IFwiaWRlbnRpdHlcIixcbiAgICAgICAgc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgRmlsdGVyID0gdGhpcy5fZmlsdGVyc1t2YWx1ZV07XG4gICAgICAgICAgaWYgKHR5cGVvZiBGaWx0ZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpbHRlcnNPcGVyYXRpb246IFVua25vd24gZmlsdGVyIFxcXCJcIiArIHZhbHVlICsgXCJcXFwiLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc2VsZWN0ZWRGaWx0ZXIgPSBuZXcgRmlsdGVyKCk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZWdpc3RlcmVkIGZpbHRlcnNcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIGNsYXNzPn1cbiAgICAgKi9cbiAgICB0aGlzLl9maWx0ZXJzID0ge307XG4gICAgdGhpcy5fcmVnaXN0ZXJGaWx0ZXJzKCk7XG5cbiAgICBzdXBlciguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogb3BlcmF0aW9ucy5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBpZGVudGlmaWVyICgpIHtcbiAgICByZXR1cm4gXCJmaWx0ZXJzXCI7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJlcikge1xuICAgIHRoaXMuX3NlbGVjdGVkRmlsdGVyLnJlbmRlcihyZW5kZXJlcik7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFsbCB0aGUga25vd24gZmlsdGVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlZ2lzdGVyRmlsdGVycyAoKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJGaWx0ZXIocmVxdWlyZShcIi4vZmlsdGVycy9pZGVudGl0eS1maWx0ZXJcIikpO1xuICAgIHRoaXMuX3JlZ2lzdGVyRmlsdGVyKHJlcXVpcmUoXCIuL2ZpbHRlcnMvazEtZmlsdGVyXCIpKTtcbiAgICB0aGlzLl9yZWdpc3RlckZpbHRlcihyZXF1aXJlKFwiLi9maWx0ZXJzL2syLWZpbHRlclwiKSk7XG4gICAgdGhpcy5fcmVnaXN0ZXJGaWx0ZXIocmVxdWlyZShcIi4vZmlsdGVycy9rNi1maWx0ZXJcIikpO1xuICAgIHRoaXMuX3JlZ2lzdGVyRmlsdGVyKHJlcXVpcmUoXCIuL2ZpbHRlcnMva2R5bmFtaWMtZmlsdGVyXCIpKTtcbiAgICB0aGlzLl9yZWdpc3RlckZpbHRlcihyZXF1aXJlKFwiLi9maWx0ZXJzL2ZyaWRnZS1maWx0ZXJcIikpO1xuICAgIHRoaXMuX3JlZ2lzdGVyRmlsdGVyKHJlcXVpcmUoXCIuL2ZpbHRlcnMvYnJlZXplLWZpbHRlclwiKSk7XG4gICAgdGhpcy5fcmVnaXN0ZXJGaWx0ZXIocmVxdWlyZShcIi4vZmlsdGVycy9vcmNoaWQtZmlsdGVyXCIpKTtcbiAgICB0aGlzLl9yZWdpc3RlckZpbHRlcihyZXF1aXJlKFwiLi9maWx0ZXJzL2NoZXN0LWZpbHRlclwiKSk7XG4gICAgdGhpcy5fcmVnaXN0ZXJGaWx0ZXIocmVxdWlyZShcIi4vZmlsdGVycy9mcm9udC1maWx0ZXJcIikpO1xuICAgIHRoaXMuX3JlZ2lzdGVyRmlsdGVyKHJlcXVpcmUoXCIuL2ZpbHRlcnMvZml4aWUtZmlsdGVyXCIpKTtcbiAgICB0aGlzLl9yZWdpc3RlckZpbHRlcihyZXF1aXJlKFwiLi9maWx0ZXJzL3g0MDAtZmlsdGVyXCIpKTtcbiAgICB0aGlzLl9yZWdpc3RlckZpbHRlcihyZXF1aXJlKFwiLi9maWx0ZXJzL2J3LWZpbHRlclwiKSk7XG4gICAgdGhpcy5fcmVnaXN0ZXJGaWx0ZXIocmVxdWlyZShcIi4vZmlsdGVycy9id2hhcmQtZmlsdGVyXCIpKTtcbiAgICB0aGlzLl9yZWdpc3RlckZpbHRlcihyZXF1aXJlKFwiLi9maWx0ZXJzL2xlbmluLWZpbHRlclwiKSk7XG4gICAgdGhpcy5fcmVnaXN0ZXJGaWx0ZXIocmVxdWlyZShcIi4vZmlsdGVycy9xdW96aS1maWx0ZXJcIikpO1xuICAgIHRoaXMuX3JlZ2lzdGVyRmlsdGVyKHJlcXVpcmUoXCIuL2ZpbHRlcnMvcG9sYTY2OS1maWx0ZXJcIikpO1xuICAgIHRoaXMuX3JlZ2lzdGVyRmlsdGVyKHJlcXVpcmUoXCIuL2ZpbHRlcnMvcG9sYS1maWx0ZXJcIikpO1xuICAgIHRoaXMuX3JlZ2lzdGVyRmlsdGVyKHJlcXVpcmUoXCIuL2ZpbHRlcnMvZm9vZC1maWx0ZXJcIikpO1xuICAgIHRoaXMuX3JlZ2lzdGVyRmlsdGVyKHJlcXVpcmUoXCIuL2ZpbHRlcnMvZ2xhbS1maWx0ZXJcIikpO1xuICAgIHRoaXMuX3JlZ2lzdGVyRmlsdGVyKHJlcXVpcmUoXCIuL2ZpbHRlcnMvY2Vsc2l1cy1maWx0ZXJcIikpO1xuICAgIHRoaXMuX3JlZ2lzdGVyRmlsdGVyKHJlcXVpcmUoXCIuL2ZpbHRlcnMvdGV4YXMtZmlsdGVyXCIpKTtcbiAgICB0aGlzLl9yZWdpc3RlckZpbHRlcihyZXF1aXJlKFwiLi9maWx0ZXJzL21vcm5pbmctZmlsdGVyXCIpKTtcbiAgICB0aGlzLl9yZWdpc3RlckZpbHRlcihyZXF1aXJlKFwiLi9maWx0ZXJzL2xvbW8tZmlsdGVyXCIpKTtcbiAgICB0aGlzLl9yZWdpc3RlckZpbHRlcihyZXF1aXJlKFwiLi9maWx0ZXJzL2dvYmJsaW4tZmlsdGVyXCIpKTtcbiAgICB0aGlzLl9yZWdpc3RlckZpbHRlcihyZXF1aXJlKFwiLi9maWx0ZXJzL21lbGxvdy1maWx0ZXJcIikpO1xuICAgIHRoaXMuX3JlZ2lzdGVyRmlsdGVyKHJlcXVpcmUoXCIuL2ZpbHRlcnMvc3VubnktZmlsdGVyXCIpKTtcbiAgICB0aGlzLl9yZWdpc3RlckZpbHRlcihyZXF1aXJlKFwiLi9maWx0ZXJzL2ExNS1maWx0ZXJcIikpO1xuICAgIHRoaXMuX3JlZ2lzdGVyRmlsdGVyKHJlcXVpcmUoXCIuL2ZpbHRlcnMvc2VtaXJlZC1maWx0ZXJcIikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gZmlsdGVyXG4gICAqIEBwYXJhbSAge2NsYXNzfSBmaWx0ZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZWdpc3RlckZpbHRlciAoZmlsdGVyKSB7XG4gICAgdGhpcy5fZmlsdGVyc1tmaWx0ZXIuaWRlbnRpZmllcl0gPSBmaWx0ZXI7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJlZ2lzdGVyZWQgZmlsdGVyc1xuICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIEZpbHRlcj59XG4gICAqL1xuICBnZXQgZmlsdGVycyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmlsdGVyc09wZXJhdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gXCIuL2ZpbHRlclwiO1xuXG4vKipcbiAqIEExNSBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlcnMuQTE1RmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5jbGFzcyBBMTVGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAqIHRoZSBhY3RpdmUgZmlsdGVyLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBpZGVudGlmaWVyICgpIHtcbiAgICByZXR1cm4gXCJhMTVcIjtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlciAocmVuZGVyZXIpIHtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRmlsdGVyLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgc3RhY2suYWRkKG5ldyBGaWx0ZXIuUHJpbWl0aXZlcy5Db250cmFzdCh7XG4gICAgICBjb250cmFzdDogMC42M1xuICAgIH0pKTtcblxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuQnJpZ2h0bmVzcyh7XG4gICAgICBicmlnaHRuZXNzOiAwLjEyXG4gICAgfSkpO1xuXG4gICAgc3RhY2suYWRkKG5ldyBGaWx0ZXIuUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgMzhdLFxuICAgICAgICAgIFs5NCwgOTRdLFxuICAgICAgICAgIFsxNDgsIDE0Ml0sXG4gICAgICAgICAgWzE3NSwgMTg3XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFs3NywgNTNdLFxuICAgICAgICAgIFsxNzEsIDE5MF0sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDEwXSxcbiAgICAgICAgICBbNDgsIDg1XSxcbiAgICAgICAgICBbMTc0LCAyMjhdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHN0YWNrLnJlbmRlcihyZW5kZXJlcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQTE1RmlsdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSBcIi4vZmlsdGVyXCI7XG5cbi8qKlxuICogQnJlZXplIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5CcmVlemVGaWx0ZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXJ9XG4gKi9cbmNsYXNzIEJyZWV6ZUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgaWRlbnRpZmllciAoKSB7XG4gICAgcmV0dXJuIFwiYnJlZXplXCI7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJlcikge1xuICAgIHZhciBzdGFjayA9IG5ldyBGaWx0ZXIuUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICAvLyBEZXNhdHVyYXRpb25cbiAgICBzdGFjay5hZGQobmV3IEZpbHRlci5QcmltaXRpdmVzLkRlc2F0dXJhdGlvbih7XG4gICAgICBkZXNhdHVyYXRpb246IDAuNVxuICAgIH0pKTtcblxuICAgIC8vIFRvbmUgY3VydmVcbiAgICBzdGFjay5hZGQobmV3IEZpbHRlci5QcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgIHJlZDogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMTcwLCAxNzBdLFxuICAgICAgICAgIFsyMTIsIDIxOV0sXG4gICAgICAgICAgWzIzNCwgMjQyXSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsxNzAsIDE2OF0sXG4gICAgICAgICAgWzIzNCwgMjMxXSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzE3MCwgMTcwXSxcbiAgICAgICAgICBbMjEyLCAyMDhdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHN0YWNrLnJlbmRlcihyZW5kZXJlcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnJlZXplRmlsdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSBcIi4vZmlsdGVyXCI7XG5cbi8qKlxuICogQlcgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJzLkJXRmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5jbGFzcyBCV0ZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiBcImJ3XCI7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJlcikge1xuICAgIHZhciBzdGFjayA9IG5ldyBGaWx0ZXIuUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICBzdGFjay5hZGQobmV3IEZpbHRlci5QcmltaXRpdmVzLkdyYXlzY2FsZSgpKTtcblxuICAgIHN0YWNrLnJlbmRlcihyZW5kZXJlcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQldGaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tIFwiLi9maWx0ZXJcIjtcblxuLyoqXG4gKiBCV0hhcmQgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJzLkJXSGFyZEZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuY2xhc3MgQldIYXJkRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgaWRlbnRpZmllciAoKSB7XG4gICAgcmV0dXJuIFwiYndoYXJkXCI7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJlcikge1xuICAgIHZhciBzdGFjayA9IG5ldyBGaWx0ZXIuUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICBzdGFjay5hZGQobmV3IEZpbHRlci5QcmltaXRpdmVzLkdyYXlzY2FsZSgpKTtcbiAgICBzdGFjay5hZGQobmV3IEZpbHRlci5QcmltaXRpdmVzLkNvbnRyYXN0KHtcbiAgICAgIGNvbnRyYXN0OiAxLjVcbiAgICB9KSk7XG5cbiAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJXSGFyZEZpbHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gXCIuL2ZpbHRlclwiO1xuXG4vKipcbiAqIENlbHNpdXMgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJzLkNlbHNpdXNGaWx0ZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXJ9XG4gKi9cbmNsYXNzIENlbHNpdXNGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAqIHRoZSBhY3RpdmUgZmlsdGVyLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBpZGVudGlmaWVyICgpIHtcbiAgICByZXR1cm4gXCJjZWxzaXVzXCI7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJlcikge1xuICAgIHZhciBzdGFjayA9IG5ldyBGaWx0ZXIuUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICBzdGFjay5hZGQobmV3IEZpbHRlci5QcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgIHJlZDogW1xuICAgICAgICAgIFswLCA2OV0sXG4gICAgICAgICAgWzU1LCAxMTBdLFxuICAgICAgICAgIFsyMDIsIDIzMF0sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCA0NF0sXG4gICAgICAgICAgWzg5LCA5M10sXG4gICAgICAgICAgWzE4NSwgMTQxXSxcbiAgICAgICAgICBbMjU1LCAxODldXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgNzZdLFxuICAgICAgICAgIFszOSwgODJdLFxuICAgICAgICAgIFsyMTgsIDEzOF0sXG4gICAgICAgICAgWzI1NSwgMTcxXVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDZWxzaXVzRmlsdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSBcIi4vZmlsdGVyXCI7XG5cbi8qKlxuICogQ2hlc3QgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJzLkNoZXN0RmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5jbGFzcyBDaGVzdEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiBcImNoZXN0XCI7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJlcikge1xuICAgIHZhciBzdGFjayA9IG5ldyBGaWx0ZXIuUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICAvLyBUb25lIGN1cnZlXG4gICAgc3RhY2suYWRkKG5ldyBGaWx0ZXIuUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzQ0LCA0NF0sXG4gICAgICAgICAgWzEyNCwgMTQzXSxcbiAgICAgICAgICBbMjIxLCAyMDRdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXSxcbiAgICAgICAgZ3JlZW46IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzEzMCwgMTI3XSxcbiAgICAgICAgICBbMjEzLCAxOTldLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXSxcbiAgICAgICAgYmx1ZTogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbNTEsIDUyXSxcbiAgICAgICAgICBbMjE5LCAyMDRdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHN0YWNrLnJlbmRlcihyZW5kZXJlcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hlc3RGaWx0ZXI7XG4iLCIvKiBqc2hpbnQgdW51c2VkOiBmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgZmlsdGVycy4gRXh0ZW5kYWJsZSB2aWEge0BsaW5rIEltZ2x5S2l0LkZpbHRlciNleHRlbmR9XG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJcbiAqL1xuY2xhc3MgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgaWRlbnRpZmllciAoKSB7IHJldHVybiBudWxsOyB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlciAocmVuZGVyZXIpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZpbHRlciNyZW5kZXIgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MuXCIpO1xuICB9XG59XG5cbi8qKlxuICogVG8gY3JlYXRlIGFuIHtAbGluayBJbWdseUtpdC5GaWx0ZXJ9IGNsYXNzIG9mIHlvdXIgb3duLCBjYWxsIHRoaXNcbiAqIG1ldGhvZCBhbmQgcHJvdmlkZSBpbnN0YW5jZSBwcm9wZXJ0aWVzIGFuZCBmdW5jdGlvbnMuXG4gKiBAZnVuY3Rpb25cbiAqL1xuRmlsdGVyLmV4dGVuZCA9IHJlcXVpcmUoXCIuLi8uLi9saWIvZXh0ZW5kXCIpO1xuXG4vLyBFeHBvc2VkIGNsYXNzZXNcbkZpbHRlci5QcmltaXRpdmVzU3RhY2sgPSByZXF1aXJlKFwiLi9wcmltaXRpdmVzLXN0YWNrXCIpO1xuRmlsdGVyLlByaW1pdGl2ZXMgPSB7fTtcbkZpbHRlci5QcmltaXRpdmVzLlNhdHVyYXRpb24gPSByZXF1aXJlKFwiLi9wcmltaXRpdmVzL3NhdHVyYXRpb25cIik7XG5GaWx0ZXIuUHJpbWl0aXZlcy5Mb29rdXBUYWJsZSA9IHJlcXVpcmUoXCIuL3ByaW1pdGl2ZXMvbG9va3VwLXRhYmxlXCIpO1xuRmlsdGVyLlByaW1pdGl2ZXMuVG9uZUN1cnZlID0gcmVxdWlyZShcIi4vcHJpbWl0aXZlcy90b25lLWN1cnZlXCIpO1xuRmlsdGVyLlByaW1pdGl2ZXMuU29mdENvbG9yT3ZlcmxheSA9IHJlcXVpcmUoXCIuL3ByaW1pdGl2ZXMvc29mdC1jb2xvci1vdmVybGF5XCIpO1xuRmlsdGVyLlByaW1pdGl2ZXMuRGVzYXR1cmF0aW9uID0gcmVxdWlyZShcIi4vcHJpbWl0aXZlcy9kZXNhdHVyYXRpb25cIik7XG5GaWx0ZXIuUHJpbWl0aXZlcy5YNDAwID0gcmVxdWlyZShcIi4vcHJpbWl0aXZlcy94NDAwXCIpO1xuRmlsdGVyLlByaW1pdGl2ZXMuR3JheXNjYWxlID0gcmVxdWlyZShcIi4vcHJpbWl0aXZlcy9ncmF5c2NhbGVcIik7XG5GaWx0ZXIuUHJpbWl0aXZlcy5Db250cmFzdCA9IHJlcXVpcmUoXCIuL3ByaW1pdGl2ZXMvY29udHJhc3RcIik7XG5GaWx0ZXIuUHJpbWl0aXZlcy5HbG93ID0gcmVxdWlyZShcIi4vcHJpbWl0aXZlcy9nbG93XCIpO1xuRmlsdGVyLlByaW1pdGl2ZXMuR29iYmxpbiA9IHJlcXVpcmUoXCIuL3ByaW1pdGl2ZXMvZ29iYmxpblwiKTtcbkZpbHRlci5QcmltaXRpdmVzLkJyaWdodG5lc3MgPSByZXF1aXJlKFwiLi9wcmltaXRpdmVzL2JyaWdodG5lc3NcIik7XG5cbmV4cG9ydCBkZWZhdWx0IEZpbHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gXCIuL2ZpbHRlclwiO1xuXG4vKipcbiAqIEZpeGllIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5GaXhpZUZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuY2xhc3MgRml4aWVGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAqIHRoZSBhY3RpdmUgZmlsdGVyLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBpZGVudGlmaWVyICgpIHtcbiAgICByZXR1cm4gXCJmaXhpZVwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlciAocmVuZGVyZXIpIHtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRmlsdGVyLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFs0NCwgMjhdLFxuICAgICAgICAgIFs2MywgNDhdLFxuICAgICAgICAgIFsxMjgsIDEzMl0sXG4gICAgICAgICAgWzIzNSwgMjQ4XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsyMCwgMTBdLFxuICAgICAgICAgIFs2MCwgNDVdLFxuICAgICAgICAgIFsxOTAsIDIwOV0sXG4gICAgICAgICAgWzIxMSwgMjMxXSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgMzFdLFxuICAgICAgICAgIFs0MSwgNjJdLFxuICAgICAgICAgIFsxNTAsIDE0Ml0sXG4gICAgICAgICAgWzIzNCwgMjEyXSxcbiAgICAgICAgICBbMjU1LCAyMjRdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZpeGllRmlsdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSBcIi4vZmlsdGVyXCI7XG5cbi8qKlxuICogRm9vZCBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlcnMuRm9vZEZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuY2xhc3MgRm9vZEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiBcImZvb2RcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICByZW5kZXIgKHJlbmRlcmVyKSB7XG4gICAgdmFyIHN0YWNrID0gbmV3IEZpbHRlci5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuU2F0dXJhdGlvbih7XG4gICAgICBzYXR1cmF0aW9uOiAxLjM1XG4gICAgfSkpO1xuXG4gICAgc3RhY2suYWRkKG5ldyBGaWx0ZXIuUHJpbWl0aXZlcy5Db250cmFzdCh7XG4gICAgICBjb250cmFzdDogMS4xXG4gICAgfSkpO1xuXG4gICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGb29kRmlsdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSBcIi4vZmlsdGVyXCI7XG5cbi8qKlxuICogRnJpZGdlIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5GcmlkZ2VGaWx0ZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXJ9XG4gKi9cbmNsYXNzIEZyaWRnZUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiBcImZyaWRnZVwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlciAocmVuZGVyZXIpIHtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRmlsdGVyLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDldLFxuICAgICAgICAgIFsyMSwgMTFdLFxuICAgICAgICAgIFs0NSwgMjRdLFxuICAgICAgICAgIFsyNTUsIDIyMF1cbiAgICAgICAgXSxcbiAgICAgICAgZ3JlZW46IFtcbiAgICAgICAgICBbMCwgMTJdLFxuICAgICAgICAgIFsyMSwgMjFdLFxuICAgICAgICAgIFs0MiwgNDJdLFxuICAgICAgICAgIFsxNTAsIDE1MF0sXG4gICAgICAgICAgWzE3MCwgMTczXSxcbiAgICAgICAgICBbMjU1LCAyMTBdXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgMjhdLFxuICAgICAgICAgIFs0MywgNzJdLFxuICAgICAgICAgIFsxMjgsIDE4NV0sXG4gICAgICAgICAgWzI1NSwgMjIwXVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGcmlkZ2VGaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tIFwiLi9maWx0ZXJcIjtcblxuLyoqXG4gKiBGcm9udCBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlcnMuRnJvbnRGaWx0ZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXJ9XG4gKi9cbmNsYXNzIEZyb250RmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgaWRlbnRpZmllciAoKSB7XG4gICAgcmV0dXJuIFwiZnJvbnRcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICByZW5kZXIgKHJlbmRlcmVyKSB7XG4gICAgdmFyIHN0YWNrID0gbmV3IEZpbHRlci5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgIC8vIFRvbmUgY3VydmVcbiAgICBzdGFjay5hZGQobmV3IEZpbHRlci5QcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgIHJlZDogW1xuICAgICAgICAgIFswLCA2NV0sXG4gICAgICAgICAgWzI4LCA2N10sXG4gICAgICAgICAgWzY3LCAxMTNdLFxuICAgICAgICAgIFsxMjUsIDE4M10sXG4gICAgICAgICAgWzE4NywgMjE3XSxcbiAgICAgICAgICBbMjU1LCAyMjldXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDUyXSxcbiAgICAgICAgICBbNDIsIDU5XSxcbiAgICAgICAgICBbMTA0LCAxMzRdLFxuICAgICAgICAgIFsxNjksIDIwOV0sXG4gICAgICAgICAgWzI1NSwgMjQwXVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDUyXSxcbiAgICAgICAgICBbNjUsIDY4XSxcbiAgICAgICAgICBbOTMsIDEwNF0sXG4gICAgICAgICAgWzE1MCwgMTUzXSxcbiAgICAgICAgICBbMjU1LCAxOThdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZyb250RmlsdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSBcIi4vZmlsdGVyXCI7XG5cbi8qKlxuICogR2xhbSBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlcnMuR2xhbUZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuY2xhc3MgR2xhbUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiBcImdsYW1cIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICByZW5kZXIgKHJlbmRlcmVyKSB7XG4gICAgdmFyIHN0YWNrID0gbmV3IEZpbHRlci5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuQ29udHJhc3Qoe1xuICAgICAgY29udHJhc3Q6IDEuMVxuICAgIH0pKTtcblxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFs5NCwgNzRdLFxuICAgICAgICAgIFsxODEsIDIwNV0sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMTI3LCAxMjddLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXSxcbiAgICAgICAgYmx1ZTogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMTAyLCA3M10sXG4gICAgICAgICAgWzIyNywgMjEzXSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdsYW1GaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tIFwiLi9maWx0ZXJcIjtcblxuLyoqXG4gKiBHb2JibGluIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5Hb2JibGluRmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5jbGFzcyBHb2JibGluRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgaWRlbnRpZmllciAoKSB7XG4gICAgcmV0dXJuIFwiZ29iYmxpblwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlciAocmVuZGVyZXIpIHtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRmlsdGVyLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgc3RhY2suYWRkKG5ldyBGaWx0ZXIuUHJpbWl0aXZlcy5Hb2JibGluKCkpO1xuXG4gICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHb2JibGluRmlsdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSBcIi4vZmlsdGVyXCI7XG5cbi8qKlxuICogSWRlbnRpdHkgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJzLklkZW50aXR5RmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5jbGFzcyBJZGVudGl0eUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiBcImlkZW50aXR5XCI7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJlcikge1xuICAgIC8vIFRoaXMgaXMgdGhlIGlkZW50aXR5IGZpbHRlciwgaXQgZG9lc24ndCBoYXZlIGFueSBlZmZlY3QuXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSWRlbnRpdHlGaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tIFwiLi9maWx0ZXJcIjtcblxuLyoqXG4gKiBLMSBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlcnMuSzFGaWx0ZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXJ9XG4gKi9cbmNsYXNzIEsxRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgaWRlbnRpZmllciAoKSB7XG4gICAgcmV0dXJuIFwiazFcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICByZW5kZXIgKHJlbmRlcmVyKSB7XG4gICAgdmFyIHN0YWNrID0gbmV3IEZpbHRlci5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgIC8vIFRvbmUgY3VydmVcbiAgICBzdGFjay5hZGQobmV3IEZpbHRlci5QcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICBjb250cm9sUG9pbnRzOiBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgWzUzLCAzMl0sXG4gICAgICAgIFs5MSwgODBdLFxuICAgICAgICBbMTc2LCAyMDVdLFxuICAgICAgICBbMjU1LCAyNTVdXG4gICAgICBdXG4gICAgfSkpO1xuXG4gICAgLy8gU2F0dXJhdGlvblxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuU2F0dXJhdGlvbih7XG4gICAgICBzYXR1cmF0aW9uOiAwLjlcbiAgICB9KSk7XG5cbiAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEsxRmlsdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSBcIi4vZmlsdGVyXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL2xpYi9jb2xvclwiO1xuXG4vKipcbiAqIEsyIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5LMkZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuY2xhc3MgSzJGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAqIHRoZSBhY3RpdmUgZmlsdGVyLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBpZGVudGlmaWVyICgpIHtcbiAgICByZXR1cm4gXCJrMlwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlciAocmVuZGVyZXIpIHtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRmlsdGVyLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIGNvbnRyb2xQb2ludHM6IFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbNTQsIDMzXSxcbiAgICAgICAgWzc3LCA4Ml0sXG4gICAgICAgIFs5NCwgMTAzXSxcbiAgICAgICAgWzEyMiwgMTI2XSxcbiAgICAgICAgWzE3NywgMTkzXSxcbiAgICAgICAgWzIyOSwgMjMyXSxcbiAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgXVxuICAgIH0pKTtcblxuICAgIC8vIFNvZnQgY29sb3Igb3ZlcmxheVxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuU29mdENvbG9yT3ZlcmxheSh7XG4gICAgICBjb2xvcjogbmV3IENvbG9yKDQwIC8gMjU1LCA0MCAvIDI1NSwgNDAgLyAyNTUpXG4gICAgfSkpO1xuXG4gICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBLMkZpbHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gXCIuL2ZpbHRlclwiO1xuXG4vKipcbiAqIEs2IEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5LNkZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuY2xhc3MgSzZGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAqIHRoZSBhY3RpdmUgZmlsdGVyLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBpZGVudGlmaWVyICgpIHtcbiAgICByZXR1cm4gXCJrNlwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlciAocmVuZGVyZXIpIHtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRmlsdGVyLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgLy8gU2F0dXJhdGlvblxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuU2F0dXJhdGlvbih7XG4gICAgICBzYXR1cmF0aW9uOiAwLjVcbiAgICB9KSk7XG5cbiAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEs2RmlsdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSBcIi4vZmlsdGVyXCI7XG5cbi8qKlxuICogS0R5bmFtaWMgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJzLktEeW5hbWljRmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5jbGFzcyBLRHluYW1pY0ZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiBcImtkeW5hbWljXCI7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJlcikge1xuICAgIHZhciBzdGFjayA9IG5ldyBGaWx0ZXIuUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICAvLyBUb25lIGN1cnZlXG4gICAgc3RhY2suYWRkKG5ldyBGaWx0ZXIuUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgY29udHJvbFBvaW50czogW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFsxNywgMjddLFxuICAgICAgICBbNDYsIDY5XSxcbiAgICAgICAgWzkwLCAxMTJdLFxuICAgICAgICBbMTU2LCAyMDBdLFxuICAgICAgICBbMjAzLCAyNDNdLFxuICAgICAgICBbMjU1LCAyNTVdXG4gICAgICBdXG4gICAgfSkpO1xuXG4gICAgLy8gU2F0dXJhdGlvblxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuU2F0dXJhdGlvbih7XG4gICAgICBzYXR1cmF0aW9uOiAwLjdcbiAgICB9KSk7XG5cbiAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEtEeW5hbWljRmlsdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSBcIi4vZmlsdGVyXCI7XG5cbi8qKlxuICogTGVuaW4gRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJzLkxlbmluRmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5jbGFzcyBMZW5pbkZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiBcImxlbmluXCI7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJlcikge1xuICAgIHZhciBzdGFjayA9IG5ldyBGaWx0ZXIuUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICAvLyBEZXNhdHVyYXRpb25cbiAgICBzdGFjay5hZGQobmV3IEZpbHRlci5QcmltaXRpdmVzLkRlc2F0dXJhdGlvbih7XG4gICAgICBkZXNhdHVyYXRpb246IDAuNFxuICAgIH0pKTtcblxuICAgIC8vIFRvbmUgY3VydmVcbiAgICBzdGFjay5hZGQobmV3IEZpbHRlci5QcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgIHJlZDogW1xuICAgICAgICAgIFswLCAyMF0sXG4gICAgICAgICAgWzQwLCAyMF0sXG4gICAgICAgICAgWzEwNiwgMTExXSxcbiAgICAgICAgICBbMTI5LCAxNTNdLFxuICAgICAgICAgIFsxOTAsIDIyM10sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCAyMF0sXG4gICAgICAgICAgWzQwLCAyMF0sXG4gICAgICAgICAgWzYyLCA0MV0sXG4gICAgICAgICAgWzEwNiwgMTA4XSxcbiAgICAgICAgICBbMTMyLCAxNTldLFxuICAgICAgICAgIFsyMDMsIDIzN10sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDQwXSxcbiAgICAgICAgICBbNDAsIDQwXSxcbiAgICAgICAgICBbNzMsIDYwXSxcbiAgICAgICAgICBbMTMzLCAxNjBdLFxuICAgICAgICAgIFsxOTEsIDI5N10sXG4gICAgICAgICAgWzIwMywgMjM3XSxcbiAgICAgICAgICBbMjM3LCAyMzldLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHN0YWNrLnJlbmRlcihyZW5kZXJlcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGVuaW5GaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tIFwiLi9maWx0ZXJcIjtcblxuLyoqXG4gKiBMb21vIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5Mb21vRmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5jbGFzcyBMb21vRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAqIHRoZSBhY3RpdmUgZmlsdGVyLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBpZGVudGlmaWVyICgpIHtcbiAgICByZXR1cm4gXCJsb21vXCI7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJlcikge1xuICAgIHZhciBzdGFjayA9IG5ldyBGaWx0ZXIuUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICBzdGFjay5hZGQobmV3IEZpbHRlci5QcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICBjb250cm9sUG9pbnRzOiBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgWzg3LCAyMF0sXG4gICAgICAgIFsxMzEsIDE1Nl0sXG4gICAgICAgIFsxODMsIDIwNV0sXG4gICAgICAgIFsyNTUsIDIwMF1cbiAgICAgIF1cbiAgICB9KSk7XG5cbiAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExvbW9GaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tIFwiLi9maWx0ZXJcIjtcblxuLyoqXG4gKiBNZWxsb3cgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJzLk1lbGxvd0ZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuY2xhc3MgTWVsbG93RmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgaWRlbnRpZmllciAoKSB7XG4gICAgcmV0dXJuIFwibWVsbG93XCI7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJlcikge1xuICAgIHZhciBzdGFjayA9IG5ldyBGaWx0ZXIuUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICBzdGFjay5hZGQobmV3IEZpbHRlci5QcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgIHJlZDogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbNDEsIDg0XSxcbiAgICAgICAgICBbODcsIDEzNF0sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMjU1LCAyMTZdXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzI1NSwgMTMxXVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNZWxsb3dGaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tIFwiLi9maWx0ZXJcIjtcblxuLyoqXG4gKiBNb3JuaW5nIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5Nb3JuaW5nRmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5jbGFzcyBNb3JuaW5nRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgaWRlbnRpZmllciAoKSB7XG4gICAgcmV0dXJuIFwibW9ybmluZ1wiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlciAocmVuZGVyZXIpIHtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRmlsdGVyLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgc3RhY2suYWRkKG5ldyBGaWx0ZXIuUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgNDBdLFxuICAgICAgICAgIFsyNTUsIDIzMF1cbiAgICAgICAgXSxcbiAgICAgICAgZ3JlZW46IFtcbiAgICAgICAgICBbMCwgMTBdLFxuICAgICAgICAgIFsyNTUsIDIyNV1cbiAgICAgICAgXSxcbiAgICAgICAgYmx1ZTogW1xuICAgICAgICAgIFswLCAyMF0sXG4gICAgICAgICAgWzI1NSwgMTgxXVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgc3RhY2suYWRkKG5ldyBGaWx0ZXIuUHJpbWl0aXZlcy5HbG93KCkpO1xuXG4gICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNb3JuaW5nRmlsdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSBcIi4vZmlsdGVyXCI7XG5cbi8qKlxuICogT3JjaGlkIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5PcmNoaWRGaWx0ZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXJ9XG4gKi9cbmNsYXNzIE9yY2hpZEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiBcIm9yY2hpZFwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlciAocmVuZGVyZXIpIHtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRmlsdGVyLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsxMTUsIDEzMF0sXG4gICAgICAgICAgWzE5NSwgMjE1XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsxNDgsIDE1M10sXG4gICAgICAgICAgWzE3MiwgMjE1XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgNDZdLFxuICAgICAgICAgIFs1OCwgNzVdLFxuICAgICAgICAgIFsxNzgsIDIwNV0sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIGNvbnRyb2xQb2ludHM6IFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbMTE3LCAxNTFdLFxuICAgICAgICBbMTg5LCAyMTddLFxuICAgICAgICBbMjU1LCAyNTVdXG4gICAgICBdXG4gICAgfSkpO1xuXG4gICAgLy8gRGVzYXR1cmF0aW9uXG4gICAgc3RhY2suYWRkKG5ldyBGaWx0ZXIuUHJpbWl0aXZlcy5EZXNhdHVyYXRpb24oe1xuICAgICAgZGVzYXR1cmF0aW9uOiAwLjY1XG4gICAgfSkpO1xuXG4gICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBPcmNoaWRGaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tIFwiLi9maWx0ZXJcIjtcblxuLyoqXG4gKiBQb2xhIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5Qb2xhRmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5jbGFzcyBQb2xhRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgaWRlbnRpZmllciAoKSB7XG4gICAgcmV0dXJuIFwicG9sYVwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlciAocmVuZGVyZXIpIHtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRmlsdGVyLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgc3RhY2suYWRkKG5ldyBGaWx0ZXIuUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzk0LCA3NF0sXG4gICAgICAgICAgWzE4MSwgMjA1XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFszNCwgMzRdLFxuICAgICAgICAgIFs5OSwgNzZdLFxuICAgICAgICAgIFsxNzYsIDE5MF0sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsxMDIsIDczXSxcbiAgICAgICAgICBbMjI3LCAyMTNdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuU2F0dXJhdGlvbih7XG4gICAgICBzYXR1cmF0aW9uOiAwLjhcbiAgICB9KSk7XG5cbiAgICBzdGFjay5hZGQobmV3IEZpbHRlci5QcmltaXRpdmVzLkNvbnRyYXN0KHtcbiAgICAgIGNvbnRyYXN0OiAxLjVcbiAgICB9KSk7XG5cbiAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvbGFGaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tIFwiLi9maWx0ZXJcIjtcblxuLyoqXG4gKiBQb2xhNjY5IEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5Qb2xhNjY5RmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5jbGFzcyBQb2xhNjY5RmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgaWRlbnRpZmllciAoKSB7XG4gICAgcmV0dXJuIFwicG9sYTY2OVwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlciAocmVuZGVyZXIpIHtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRmlsdGVyLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgc3RhY2suYWRkKG5ldyBGaWx0ZXIuUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzU2LCAxOF0sXG4gICAgICAgICAgWzE5NiwgMjA5XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDM4XSxcbiAgICAgICAgICBbNzEsIDg0XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzEzMSwgMTMzXSxcbiAgICAgICAgICBbMjA0LCAyMTFdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuU2F0dXJhdGlvbih7XG4gICAgICBzYXR1cmF0aW9uOiAwLjhcbiAgICB9KSk7XG5cbiAgICBzdGFjay5hZGQobmV3IEZpbHRlci5QcmltaXRpdmVzLkNvbnRyYXN0KHtcbiAgICAgIGNvbnRyYXN0OiAxLjVcbiAgICB9KSk7XG5cbiAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvbGE2NjlGaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuLyoqXG4gKiBBIGhlbHBlciBjbGFzcyB0aGF0IGNhbiBjb2xsZWN0IHtAbGluayBQcmltaXRpdmV9IGluc3RhbmNlcyBhbmQgcmVuZGVyXG4gKiB0aGUgc3RhY2tcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmVzU3RhY2tcbiAqL1xuY2xhc3MgUHJpbWl0aXZlc1N0YWNrIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGFjayBvZiB7QGxpbmsgSW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZX0gaW5zdGFuY2VzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc3RhY2sgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBwcmltaXRpdmUgdG8gdGhlIHN0YWNrXG4gICAqIEBwYXJhbSB7SW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZX0gcHJpbWl0aXZlXG4gICAqL1xuICBhZGQgKHByaW1pdGl2ZSkge1xuICAgIHRoaXMuX3N0YWNrLnB1c2gocHJpbWl0aXZlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBzdGFjayBvZiBwcmltaXRpdmVzIG9uIHRoZSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIHJlbmRlciAocmVuZGVyZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3N0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJpbWl0aXZlID0gdGhpcy5fc3RhY2tbaV07XG4gICAgICBwcmltaXRpdmUucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJpbWl0aXZlc1N0YWNrO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBQcmltaXRpdmUgZnJvbSBcIi4vcHJpbWl0aXZlXCI7XG5cbi8qKlxuICogQnJpZ2h0bmVzcyBwcmltaXRpdmVcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmVzLkJyaWdodG5lc3NcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXIuUHJpbWl0aXZlfVxuICovXG5jbGFzcyBCcmlnaHRuZXNzIGV4dGVuZHMgUHJpbWl0aXZlIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIHRoaXMuX29wdGlvbnMgPSBfLmRlZmF1bHRzKHRoaXMuX29wdGlvbnMsIHtcbiAgICAgIGJyaWdodG5lc3M6IDEuMFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYWdtZW50IHNoYWRlciBmb3IgdGhpcyBwcmltaXRpdmVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9mcmFnbWVudFNoYWRlciA9IGBcblxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XG4gICAgICB1bmlmb3JtIGZsb2F0IHVfYnJpZ2h0bmVzcztcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCh0ZXhDb2xvci5yZ2IgKyB2ZWMzKHVfYnJpZ2h0bmVzcykpLCB0ZXhDb2xvci5hKTtcbiAgICAgIH1cblxuICAgIGA7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBwcmltaXRpdmUgKFdlYkdMKVxuICAgKiBAcGFyYW0gIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmVuZGVyV2ViR0wgKHJlbmRlcmVyKSB7XG4gICAgcmVuZGVyZXIucnVuU2hhZGVyKG51bGwsIHRoaXMuX2ZyYWdtZW50U2hhZGVyLCB7XG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICB1X2JyaWdodG5lc3M6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiB0aGlzLl9vcHRpb25zLmJyaWdodG5lc3MgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHByaW1pdGl2ZSAoQ2FudmFzKVxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIHJlbmRlckNhbnZhcyAocmVuZGVyZXIpIHtcbiAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG4gICAgdmFyIGltYWdlRGF0YSA9IHJlbmRlcmVyLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB2YXIgYnJpZ2h0bmVzcyA9IHRoaXMuX29wdGlvbnMuYnJpZ2h0bmVzcztcblxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2FudmFzLndpZHRoOyB4KyspIHtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IChjYW52YXMud2lkdGggKiB5ICsgeCkgKiA0O1xuXG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSAgICAgPSBpbWFnZURhdGEuZGF0YVtpbmRleF0gKyBicmlnaHRuZXNzICogMjU1O1xuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSArIGJyaWdodG5lc3MgKiAyNTU7XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdICsgYnJpZ2h0bmVzcyAqIDI1NTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXJlci5nZXRDb250ZXh0KCkucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnJpZ2h0bmVzcztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgUHJpbWl0aXZlIGZyb20gXCIuL3ByaW1pdGl2ZVwiO1xuXG4vKipcbiAqIENvbnRyYXN0IHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZXMuQ29udHJhc3RcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXIuUHJpbWl0aXZlfVxuICovXG5jbGFzcyBDb250cmFzdCBleHRlbmRzIFByaW1pdGl2ZSB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICB0aGlzLl9vcHRpb25zID0gXy5kZWZhdWx0cyh0aGlzLl9vcHRpb25zLCB7XG4gICAgICBjb250cmFzdDogMS4wXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIGZvciB0aGlzIHByaW1pdGl2ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gYFxuXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdV9jb250cmFzdDtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCgodGV4Q29sb3IucmdiIC0gdmVjMygwLjUpKSAqIHVfY29udHJhc3QgKyB2ZWMzKDAuNSkpLCB0ZXhDb2xvci5hKTtcbiAgICAgIH1cblxuICAgIGA7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlIChXZWJHTClcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJlbmRlcldlYkdMIChyZW5kZXJlcikge1xuICAgIHJlbmRlcmVyLnJ1blNoYWRlcihudWxsLCB0aGlzLl9mcmFnbWVudFNoYWRlciwge1xuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdV9jb250cmFzdDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IHRoaXMuX29wdGlvbnMuY29udHJhc3QgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHByaW1pdGl2ZSAoQ2FudmFzKVxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIHJlbmRlckNhbnZhcyAocmVuZGVyZXIpIHtcbiAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG4gICAgdmFyIGltYWdlRGF0YSA9IHJlbmRlcmVyLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB2YXIgY29udHJhc3QgPSB0aGlzLl9vcHRpb25zLmNvbnRyYXN0O1xuXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gKGNhbnZhcy53aWR0aCAqIHkgKyB4KSAqIDQ7XG5cbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXhdICAgICA9IChpbWFnZURhdGEuZGF0YVtpbmRleF0gLSAxMjcpICogY29udHJhc3QgKyAxMjc7XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSAoaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSAtIDEyNykgKiBjb250cmFzdCArIDEyNztcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IChpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdIC0gMTI3KSAqIGNvbnRyYXN0ICsgMTI3O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcmVyLmdldENvbnRleHQoKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb250cmFzdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgUHJpbWl0aXZlIGZyb20gXCIuL3ByaW1pdGl2ZVwiO1xuXG4vKipcbiAqIERlc2F0dXJhdGlvbiBwcmltaXRpdmVcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmVzLkRlc2F0dXJhdGlvblxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmV9XG4gKi9cbmNsYXNzIERlc2F0dXJhdGlvbiBleHRlbmRzIFByaW1pdGl2ZSB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICB0aGlzLl9vcHRpb25zID0gXy5kZWZhdWx0cyh0aGlzLl9vcHRpb25zLCB7XG4gICAgICBkZXNhdHVyYXRpb246IDEuMFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYWdtZW50IHNoYWRlciBmb3IgdGhpcyBwcmltaXRpdmVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9mcmFnbWVudFNoYWRlciA9IGBcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xuICAgICAgdW5pZm9ybSBmbG9hdCB1X2Rlc2F0dXJhdGlvbjtcblxuICAgICAgY29uc3QgdmVjMyBsdW1pbmFuY2VXZWlnaHRpbmcgPSB2ZWMzKDAuMjEyNSwgMC43MTU0LCAwLjA3MjEpO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzMgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCkueHl6O1xuICAgICAgICB2ZWMzIGdyYXlYZmVyID0gdmVjMygwLjMsIDAuNTksIDAuMTEpO1xuICAgICAgICB2ZWMzIGdyYXkgPSB2ZWMzKGRvdChncmF5WGZlciwgdGV4Q29sb3IpKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChtaXgodGV4Q29sb3IsIGdyYXksIHVfZGVzYXR1cmF0aW9uKSwgMS4wKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHByaW1pdGl2ZSAoV2ViR0wpXG4gICAqIEBwYXJhbSAge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZW5kZXJXZWJHTCAocmVuZGVyZXIpIHtcbiAgICByZW5kZXJlci5ydW5TaGFkZXIobnVsbCwgdGhpcy5fZnJhZ21lbnRTaGFkZXIsIHtcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHVfZGVzYXR1cmF0aW9uOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogdGhpcy5fb3B0aW9ucy5kZXNhdHVyYXRpb24gfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHByaW1pdGl2ZSAoQ2FudmFzKVxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIHJlbmRlckNhbnZhcyAocmVuZGVyZXIpIHtcbiAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG4gICAgdmFyIGltYWdlRGF0YSA9IHJlbmRlcmVyLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB2YXIgZGVzYXR1cmF0aW9uID0gdGhpcy5fb3B0aW9ucy5kZXNhdHVyYXRpb247XG5cbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNhbnZhcy53aWR0aDsgeCsrKSB7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICB2YXIgaW5kZXggPSAoY2FudmFzLndpZHRoICogeSArIHgpICogNDtcblxuICAgICAgICB2YXIgbHVtaW5hbmNlID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXhdICogMC4zICsgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSAqIDAuNTkgKyBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdICogMC4xMTtcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXhdID0gbHVtaW5hbmNlICogKDEgLSBkZXNhdHVyYXRpb24pICsgKGltYWdlRGF0YS5kYXRhW2luZGV4XSAqIGRlc2F0dXJhdGlvbik7XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSBsdW1pbmFuY2UgKiAoMSAtIGRlc2F0dXJhdGlvbikgKyAoaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSAqIGRlc2F0dXJhdGlvbik7XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSBsdW1pbmFuY2UgKiAoMSAtIGRlc2F0dXJhdGlvbikgKyAoaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSAqIGRlc2F0dXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyZXIuZ2V0Q29udGV4dCgpLnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERlc2F0dXJhdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgUHJpbWl0aXZlIGZyb20gXCIuL3ByaW1pdGl2ZVwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi8uLi9saWIvY29sb3JcIjtcblxuLyoqXG4gKiBHbG93IHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZXMuR2xvd1xuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmV9XG4gKi9cbmNsYXNzIEdsb3cgZXh0ZW5kcyBQcmltaXRpdmUge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgdGhpcy5fb3B0aW9ucyA9IF8uZGVmYXVsdHModGhpcy5fb3B0aW9ucywge1xuICAgICAgY29sb3I6IG5ldyBDb2xvcigxLCAxLCAxKVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYWdtZW50IHNoYWRlciBmb3IgdGhpcyBwcmltaXRpdmVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9mcmFnbWVudFNoYWRlciA9IGBcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xuXG4gICAgICB1bmlmb3JtIHZlYzMgdV9jb2xvcjtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWMzIHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpLnJnYjtcblxuICAgICAgICB2ZWMyIHRleHR1cmVDb29yZCA9IHZfdGV4Q29vcmQgLSB2ZWMyKDAuNSwgMC41KTtcbiAgICAgICAgdGV4dHVyZUNvb3JkIC89IDAuNzU7XG5cbiAgICAgICAgZmxvYXQgZCA9IDEuMCAtIGRvdCh0ZXh0dXJlQ29vcmQsIHRleHR1cmVDb29yZCk7XG4gICAgICAgIGQgPSBjbGFtcChkLCAwLjIsIDEuMCk7XG4gICAgICAgIHZlYzMgbmV3Q29sb3IgPSB0ZXhDb2xvciAqIGQgKiB1X2NvbG9yLnJnYjtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKG5ld0NvbG9yKSwxLjApO1xuICAgICAgfVxuICAgIGA7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlIChXZWJHTClcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJlbmRlcldlYkdMIChyZW5kZXJlcikge1xuICAgIHJlbmRlcmVyLnJ1blNoYWRlcihudWxsLCB0aGlzLl9mcmFnbWVudFNoYWRlciwge1xuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdV9jb2xvcjogeyB0eXBlOiBcIjNmXCIsIHZhbHVlOiB0aGlzLl9vcHRpb25zLmNvbG9yLnRvUkdCR0xDb2xvcigpfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHByaW1pdGl2ZSAoQ2FudmFzKVxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlckNhbnZhcyAocmVuZGVyZXIpIHtcbiAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG4gICAgdmFyIGltYWdlRGF0YSA9IHJlbmRlcmVyLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB2YXIgY29sb3IgPSB0aGlzLl9vcHRpb25zLmNvbG9yO1xuXG4gICAgdmFyIGQ7XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gKGNhbnZhcy53aWR0aCAqIHkgKyB4KSAqIDQ7XG5cbiAgICAgICAgdmFyIHgwMSA9IHggLyBjYW52YXMud2lkdGg7XG4gICAgICAgIHZhciB5MDEgPSB5IC8gY2FudmFzLmhlaWdodDtcblxuICAgICAgICB2YXIgbnggPSAoeDAxIC0gMC41KSAvIDAuNzU7XG4gICAgICAgIHZhciBueSA9ICh5MDEgLSAwLjUpIC8gMC43NTtcblxuICAgICAgICB2YXIgc2NhbGFyWCA9IG54ICogbng7XG4gICAgICAgIHZhciBzY2FsYXJZID0gbnkgKiBueTtcbiAgICAgICAgZCA9IDEgLSAoc2NhbGFyWCArIHNjYWxhclkpO1xuICAgICAgICBkID0gTWF0aC5taW4oTWF0aC5tYXgoZCwgMC4xKSwgMS4wKTtcblxuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleF0gPSBpbWFnZURhdGEuZGF0YVtpbmRleF0gKiAoZCAqIGNvbG9yWzBdIC8gMjU1KTtcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gKiAoZCAqIGNvbG9yWzFdIC8gMjU1KTtcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gKiAoZCAqIGNvbG9yWzJdIC8gMjU1KTtcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAzXSA9IDI1NTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXJlci5nZXRDb250ZXh0KCkucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgR2xvdztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5pbXBvcnQgUHJpbWl0aXZlIGZyb20gXCIuL3ByaW1pdGl2ZVwiO1xuXG4vKipcbiAqIEdvYmJsaW4gcHJpbWl0aXZlXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXIuUHJpbWl0aXZlcy5Hb2JibGluXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZX1cbiAqL1xuY2xhc3MgR29iYmxpbiBleHRlbmRzIFByaW1pdGl2ZSB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIGZvciB0aGlzIHByaW1pdGl2ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gYFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcbiAgICAgICAgdGV4Q29sb3IuYiA9IHRleENvbG9yLmcgKiAwLjMzO1xuICAgICAgICB0ZXhDb2xvci5yID0gdGV4Q29sb3IuciAqIDAuNjtcbiAgICAgICAgdGV4Q29sb3IuYiArPSB0ZXhDb2xvci5yICogMC4zMztcbiAgICAgICAgdGV4Q29sb3IuZyA9IHRleENvbG9yLmcgKiAwLjc7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleENvbG9yO1xuICAgICAgfVxuICAgIGA7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlIChXZWJHTClcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJlbmRlcldlYkdMIChyZW5kZXJlcikge1xuICAgIHJlbmRlcmVyLnJ1blNoYWRlcihudWxsLCB0aGlzLl9mcmFnbWVudFNoYWRlcik7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlIChDYW52YXMpXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgcmVuZGVyQ2FudmFzIChyZW5kZXJlcikge1xuICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcbiAgICB2YXIgaW1hZ2VEYXRhID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gKGNhbnZhcy53aWR0aCAqIHkgKyB4KSAqIDQ7XG5cbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gKiAwLjMzO1xuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleF0gPSBpbWFnZURhdGEuZGF0YVtpbmRleF0gKiAwLjY7XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gKz0gaW1hZ2VEYXRhLmRhdGFbaW5kZXhdICogMC4zMztcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gKiAwLjc7XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgM10gPSAyNTU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyZXIuZ2V0Q29udGV4dCgpLnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdvYmJsaW47XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IFByaW1pdGl2ZSBmcm9tIFwiLi9wcmltaXRpdmVcIjtcblxuLyoqXG4gKiBHcmF5c2NhbGUgcHJpbWl0aXZlXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXIuUHJpbWl0aXZlcy5HcmF5c2NhbGVcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXIuUHJpbWl0aXZlfVxuICovXG5jbGFzcyBHcmF5c2NhbGUgZXh0ZW5kcyBQcmltaXRpdmUge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYWdtZW50IHNoYWRlciBmb3IgdGhpcyBwcmltaXRpdmVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9mcmFnbWVudFNoYWRlciA9IGBcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xuICAgICAgdmVjMyBXID0gdmVjMygwLjIxMjUsIDAuNzE1NCwgMC4wNzIxKTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWMzIHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpLnJnYjtcbiAgICAgICAgZmxvYXQgbHVtaW5hbmNlID0gZG90KHRleENvbG9yLCBXKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKGx1bWluYW5jZSksIDEuMCk7XG4gICAgICB9XG4gICAgYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBwcmltaXRpdmUgKFdlYkdMKVxuICAgKiBAcGFyYW0gIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmVuZGVyV2ViR0wgKHJlbmRlcmVyKSB7XG4gICAgcmVuZGVyZXIucnVuU2hhZGVyKG51bGwsIHRoaXMuX2ZyYWdtZW50U2hhZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBwcmltaXRpdmUgKENhbnZhcylcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqL1xuICByZW5kZXJDYW52YXMgKHJlbmRlcmVyKSB7XG4gICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgIHZhciBpbWFnZURhdGEgPSByZW5kZXJlci5nZXRDb250ZXh0KCkuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNhbnZhcy53aWR0aDsgeCsrKSB7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICB2YXIgaW5kZXggPSAoY2FudmFzLndpZHRoICogeSArIHgpICogNDtcblxuICAgICAgICB2YXIgbHVtaW5hbmNlID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXhdICogMC4yMTI1ICsgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSAqIDAuNzE1NCArIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gKiAwLjA3MjE7XG5cbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXhdID0gbHVtaW5hbmNlO1xuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdID0gbHVtaW5hbmNlO1xuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdID0gbHVtaW5hbmNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcmVyLmdldENvbnRleHQoKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHcmF5c2NhbGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IFByaW1pdGl2ZSBmcm9tIFwiLi9wcmltaXRpdmVcIjtcblxuLyoqXG4gKiBTdG9yZXMgYSAyNTYgYnl0ZSBsb25nIGxvb2t1cCB0YWJsZSBpbiBhIDJkIHRleHR1cmUgd2hpY2ggd2lsbCBiZVxuICogdXNlZCB0byBsb29rIHVwIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGZvciBlYWNoIGNoYW5uZWwuXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXIuUHJpbWl0aXZlcy5Mb29rdXBUYWJsZVxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmV9XG4gKi9cbmNsYXNzIExvb2t1cFRhYmxlIGV4dGVuZHMgUHJpbWl0aXZlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIFByaW1pdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5fdGV4dHVyZUluZGV4ID0gMztcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIgZm9yIHRoaXMgcHJpbWl0aXZlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZnJhZ21lbnRTaGFkZXIgPSBgXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfbG9va3VwVGFibGU7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcbiAgICAgICAgZmxvYXQgciA9IHRleHR1cmUyRCh1X2xvb2t1cFRhYmxlLCB2ZWMyKHRleENvbG9yLnIsIDAuMCkpLnI7XG4gICAgICAgIGZsb2F0IGcgPSB0ZXh0dXJlMkQodV9sb29rdXBUYWJsZSwgdmVjMih0ZXhDb2xvci5nLCAwLjApKS5nO1xuICAgICAgICBmbG9hdCBiID0gdGV4dHVyZTJEKHVfbG9va3VwVGFibGUsIHZlYzIodGV4Q29sb3IuYiwgMC4wKSkuYjtcblxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHIsIGcsIGIsIHRleENvbG9yLmEpO1xuICAgICAgfVxuICAgIGA7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlIChXZWJHTClcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJlbmRlcldlYkdMIChyZW5kZXJlcikge1xuICAgIHRoaXMuX3VwZGF0ZVRleHR1cmUocmVuZGVyZXIpO1xuXG4gICAgcmVuZGVyZXIucnVuU2hhZGVyKG51bGwsIHRoaXMuX2ZyYWdtZW50U2hhZGVyLCB7XG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICB1X2xvb2t1cFRhYmxlOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMyB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlIChDYW52YXMpXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgcmVuZGVyQ2FudmFzIChyZW5kZXJlcikge1xuICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcbiAgICB2YXIgaW1hZ2VEYXRhID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIHZhciB0YWJsZSA9IHRoaXMuX29wdGlvbnMuZGF0YTtcblxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2FudmFzLndpZHRoOyB4KyspIHtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IChjYW52YXMud2lkdGggKiB5ICsgeCkgKiA0O1xuXG4gICAgICAgIHZhciByID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXhdO1xuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleF0gPSB0YWJsZVtyICogNF07XG4gICAgICAgIHZhciBnID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXTtcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IHRhYmxlWzEgKyBnICogNF07XG4gICAgICAgIHZhciBiID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IHRhYmxlWzIgKyBiICogNF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyZXIuZ2V0Q29udGV4dCgpLnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGxvb2t1cCB0YWJsZSB0ZXh0dXJlIChXZWJHTCBvbmx5KVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgX3VwZGF0ZVRleHR1cmUgKHJlbmRlcmVyKSB7XG4gICAgdmFyIGdsID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvb2t1cFRhYmxlOiBObyBkYXRhIHNwZWNpZmllZC5cIik7XG4gICAgfVxuXG4gICAgdmFyIGRhdGFUeXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fb3B0aW9ucy5kYXRhKTtcblxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLl90ZXh0dXJlSW5kZXgpO1xuICAgIGlmICghdGhpcy5fdGV4dHVyZSkge1xuICAgICAgdGhpcy5fdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICB9XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblxuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMjU2LCAxLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkYXRhVHlwZWRBcnJheSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTG9va3VwVGFibGU7XG4iLCIvKiBqc2hpbnQgdW51c2VkOiBmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgcHJpbWl0aXZlcy4gRXh0ZW5kYWJsZSB2aWEge0BsaW5rIEltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmUjZXh0ZW5kfVxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZVxuICovXG5jbGFzcyBQcmltaXRpdmUge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlXG4gICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJlcikge1xuICAgIGlmIChyZW5kZXJlci5pZGVudGlmaWVyID09PSBcIndlYmdsXCIpIHtcbiAgICAgIHRoaXMucmVuZGVyV2ViR0wocmVuZGVyZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcyhyZW5kZXJlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHByaW1pdGl2ZSAoV2ViR0wpXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmVuZGVyV2ViR0wgKHJlbmRlcmVyKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcmltaXRpdmUjcmVuZGVyV2ViR0wgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MuXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHByaW1pdGl2ZSAoQ2FudmFzMkQpXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgcmVuZGVyQ2FudmFzIChyZW5kZXJlcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJpbWl0aXZlI3JlbmRlckNhbnZhcyBpcyBhYnN0cmFjdCBhbmQgbm90IGltcGxlbWVudGVkIGluIGluaGVyaXRlZCBjbGFzcy5cIik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJpbWl0aXZlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBQcmltaXRpdmUgZnJvbSBcIi4vcHJpbWl0aXZlXCI7XG5cbi8qKlxuICogU2F0dXJhdGlvbiBwcmltaXRpdmVcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmVzLlNhdHVyYXRpb25cbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXIuUHJpbWl0aXZlfVxuICovXG5jbGFzcyBTYXR1cmF0aW9uIGV4dGVuZHMgUHJpbWl0aXZlIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIHRoaXMuX29wdGlvbnMgPSBfLmRlZmF1bHRzKHRoaXMuX29wdGlvbnMsIHtcbiAgICAgIHNhdHVyYXRpb246IDBcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIgZm9yIHRoaXMgcHJpbWl0aXZlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZnJhZ21lbnRTaGFkZXIgPSBgXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdV9zYXR1cmF0aW9uO1xuXG4gICAgICBjb25zdCB2ZWMzIGx1bWluYW5jZVdlaWdodGluZyA9IHZlYzMoMC4yMTI1LCAwLjcxNTQsIDAuMDcyMSk7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcbiAgICAgICAgZmxvYXQgbHVtaW5hbmNlID0gZG90KHRleENvbG9yLnJnYiwgbHVtaW5hbmNlV2VpZ2h0aW5nKTtcblxuICAgICAgICB2ZWMzIGdyZXlTY2FsZUNvbG9yID0gdmVjMyhsdW1pbmFuY2UpO1xuXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQobWl4KGdyZXlTY2FsZUNvbG9yLCB0ZXhDb2xvci5yZ2IsIHVfc2F0dXJhdGlvbiksIHRleENvbG9yLmEpO1xuICAgICAgfVxuICAgIGA7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlIChXZWJHTClcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJlbmRlcldlYkdMIChyZW5kZXJlcikge1xuICAgIHJlbmRlcmVyLnJ1blNoYWRlcihudWxsLCB0aGlzLl9mcmFnbWVudFNoYWRlciwge1xuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdV9zYXR1cmF0aW9uOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogdGhpcy5fb3B0aW9ucy5zYXR1cmF0aW9uIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBwcmltaXRpdmUgKENhbnZhcylcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICByZW5kZXJDYW52YXMgKHJlbmRlcmVyKSB7XG4gICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgIHZhciBpbWFnZURhdGEgPSByZW5kZXJlci5nZXRDb250ZXh0KCkuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgdmFyIHNhdHVyYXRpb24gPSB0aGlzLl9vcHRpb25zLnNhdHVyYXRpb247XG5cbiAgICB2YXIgZDtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNhbnZhcy53aWR0aDsgeCsrKSB7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICB2YXIgaW5kZXggPSAoY2FudmFzLndpZHRoICogeSArIHgpICogNDtcblxuICAgICAgICB2YXIgbHVtaW5hbmNlID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXhdICogMC4yMTI1ICsgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSAqIDAuNzE1NCArIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gKiAwLjA3MjE7XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IGx1bWluYW5jZSAqICgxIC0gc2F0dXJhdGlvbikgKyAoaW1hZ2VEYXRhLmRhdGFbaW5kZXhdICogc2F0dXJhdGlvbik7XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSBsdW1pbmFuY2UgKiAoMSAtIHNhdHVyYXRpb24pICsgKGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gKiBzYXR1cmF0aW9uKTtcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IGx1bWluYW5jZSAqICgxIC0gc2F0dXJhdGlvbikgKyAoaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSAqIHNhdHVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcmVyLmdldENvbnRleHQoKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTYXR1cmF0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBQcmltaXRpdmUgZnJvbSBcIi4vcHJpbWl0aXZlXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uLy4uL2xpYi9jb2xvclwiO1xuXG4vKipcbiAqIFNvZnRDb2xvck92ZXJsYXkgcHJpbWl0aXZlXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXIuUHJpbWl0aXZlcy5Tb2Z0Q29sb3JPdmVybGF5XG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZX1cbiAqL1xuY2xhc3MgU29mdENvbG9yT3ZlcmxheSBleHRlbmRzIFByaW1pdGl2ZSB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICB0aGlzLl9vcHRpb25zID0gXy5kZWZhdWx0cyh0aGlzLl9vcHRpb25zLCB7XG4gICAgICBjb2xvcjogbmV3IENvbG9yKDEuMCwgMS4wLCAxLjApXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIGZvciB0aGlzIHByaW1pdGl2ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gYFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XG4gICAgICB1bmlmb3JtIHZlYzMgdV9vdmVybGF5O1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XG4gICAgICAgIHZlYzQgb3ZlcmxheVZlYzQgPSB2ZWM0KHVfb3ZlcmxheSwgdGV4Q29sb3IuYSk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IG1heChvdmVybGF5VmVjNCwgdGV4Q29sb3IpO1xuICAgICAgfVxuICAgIGA7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlIChXZWJHTClcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJlbmRlcldlYkdMIChyZW5kZXJlcikge1xuICAgIHJlbmRlcmVyLnJ1blNoYWRlcihudWxsLCB0aGlzLl9mcmFnbWVudFNoYWRlciwge1xuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdV9vdmVybGF5OiB7IHR5cGU6IFwiM2ZcIiwgdmFsdWU6IHRoaXMuX29wdGlvbnMuY29sb3IudG9SR0JHTENvbG9yKCkgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHByaW1pdGl2ZSAoQ2FudmFzKVxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIHJlbmRlckNhbnZhcyAocmVuZGVyZXIpIHtcbiAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG4gICAgdmFyIGltYWdlRGF0YSA9IHJlbmRlcmVyLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2FudmFzLndpZHRoOyB4KyspIHtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IChjYW52YXMud2lkdGggKiB5ICsgeCkgKiA0O1xuXG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IE1hdGgubWF4KHRoaXMuX29wdGlvbnMuY29sb3IuciwgaW1hZ2VEYXRhLmRhdGFbaW5kZXhdKTtcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IE1hdGgubWF4KHRoaXMuX29wdGlvbnMuY29sb3IuZywgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSk7XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSBNYXRoLm1heCh0aGlzLl9vcHRpb25zLmNvbG9yLmIsIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcmVyLmdldENvbnRleHQoKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTb2Z0Q29sb3JPdmVybGF5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcbmltcG9ydCBMb29rdXBUYWJsZSBmcm9tIFwiLi9sb29rdXAtdGFibGVcIjtcblxuLyoqXG4gKiBUb25lIGN1cnZlIHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZXMuVG9uZUN1cnZlXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZXMuTG9va3VwVGFibGV9XG4gKi9cbmNsYXNzIFRvbmVDdXJ2ZSBleHRlbmRzIExvb2t1cFRhYmxlIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIHRoaXMuX29wdGlvbnMgPSBfLmRlZmF1bHRzKHRoaXMuX29wdGlvbnMsIHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiB0aGlzLl9vcHRpb25zLmNvbnRyb2xQb2ludHMsXG4gICAgICAgIGdyZWVuOiB0aGlzLl9vcHRpb25zLmNvbnRyb2xQb2ludHMsXG4gICAgICAgIGJsdWU6IHRoaXMuX29wdGlvbnMuY29udHJvbFBvaW50c1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLnJnYkNvbnRyb2xQb2ludHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUxvb2t1cFRhYmxlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGxvb2t1cCB0YWJsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZUxvb2t1cFRhYmxlICgpIHtcbiAgICB2YXIgciA9IHRoaXMuX2NhbGN1bGF0ZVNwbGluZUN1cnZlKHRoaXMuX29wdGlvbnMucmdiQ29udHJvbFBvaW50cy5yZWQpO1xuICAgIHZhciBnID0gdGhpcy5fY2FsY3VsYXRlU3BsaW5lQ3VydmUodGhpcy5fb3B0aW9ucy5yZ2JDb250cm9sUG9pbnRzLmdyZWVuKTtcbiAgICB2YXIgYiA9IHRoaXMuX2NhbGN1bGF0ZVNwbGluZUN1cnZlKHRoaXMuX29wdGlvbnMucmdiQ29udHJvbFBvaW50cy5ibHVlKTtcblxuICAgIHRoaXMuX29wdGlvbnMuZGF0YSA9IHRoaXMuX2J1aWxkTG9va3VwVGFibGUociwgZywgYik7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBsb29rdXAgdGFibGVcbiAgICogQHBhcmFtICB7QXJyYXl9IHJcbiAgICogQHBhcmFtICB7QXJyYXl9IGdcbiAgICogQHBhcmFtICB7QXJyYXl9IGJcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYnVpbGRMb29rdXBUYWJsZSAociwgZywgYikge1xuICAgIHZhciBkYXRhID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBkYXRhLnB1c2goTWF0aC5taW4oTWF0aC5tYXgoaSArIHJbaV0sIDApLCAyNTUpKTtcbiAgICAgIGRhdGEucHVzaChNYXRoLm1pbihNYXRoLm1heChpICsgZ1tpXSwgMCksIDI1NSkpO1xuICAgICAgZGF0YS5wdXNoKE1hdGgubWluKE1hdGgubWF4KGkgKyBiW2ldLCAwKSwgMjU1KSk7XG4gICAgICBkYXRhLnB1c2goMjU1KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBzcGxpbmUgY3VydmUgZGF0YSBmb3IgdGhlIGdpdmVuIHBvaW50c1xuICAgKiBAcGFyYW0gIHtBcnJheS48QXJyYXkuPE51bWJlcj4+fSBwb2ludHNcbiAgICogQHJldHVybiB7QXJyYXkuPE51bWJlcj59XG4gICAqL1xuICBfY2FsY3VsYXRlU3BsaW5lQ3VydmUgKHBvaW50cykge1xuICAgIHBvaW50cyA9IHBvaW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYVswXSA+IGJbMF07XG4gICAgfSk7XG5cbiAgICB2YXIgc3BsaW5lUG9pbnRzID0gdGhpcy5fZ2V0U3BsaW5lQ3VydmUocG9pbnRzKTtcbiAgICB2YXIgZmlyc3RTcGxpbmVQb2ludCA9IHNwbGluZVBvaW50c1swXTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChmaXJzdFNwbGluZVBvaW50WzBdID4gMCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGZpcnN0U3BsaW5lUG9pbnRbMF07IGkrKykge1xuICAgICAgICBzcGxpbmVQb2ludHMudW5zaGlmdChbMCwgMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmVwYXJlZFBvaW50cyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzcGxpbmVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXdQb2ludCA9IHNwbGluZVBvaW50c1tpXTtcbiAgICAgIHZhciBvcmlnUG9pbnQgPSBbbmV3UG9pbnRbMF0sIG5ld1BvaW50WzBdXTtcblxuICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KFxuICAgICAgICBNYXRoLnBvdyhvcmlnUG9pbnRbMF0gLSBuZXdQb2ludFswXSwgMikgK1xuICAgICAgICBNYXRoLnBvdyhvcmlnUG9pbnRbMV0gLSBuZXdQb2ludFsxXSwgMilcbiAgICAgICk7XG5cbiAgICAgIGlmIChvcmlnUG9pbnRbMV0gPiBuZXdQb2ludFsxXSkge1xuICAgICAgICBkaXN0YW5jZSA9IC1kaXN0YW5jZTtcbiAgICAgIH1cblxuICAgICAgcHJlcGFyZWRQb2ludHMucHVzaChkaXN0YW5jZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXBhcmVkUG9pbnRzO1xuICB9XG5cbiAgX2dldFNwbGluZUN1cnZlIChwb2ludHMpIHtcbiAgICB2YXIgc2RBID0gdGhpcy5fc2Vjb25kRGVyaXZhdGl2ZShwb2ludHMpO1xuXG4gICAgdmFyIG4gPSBzZEEubGVuZ3RoO1xuICAgIHZhciBzZCA9IFtdO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgc2RbaV0gPSBzZEFbaV07XG4gICAgfVxuXG4gICAgdmFyIG91dHB1dCA9IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG4tMTsgaSsrKSB7XG4gICAgICB2YXIgY3VyID0gcG9pbnRzW2ldO1xuICAgICAgdmFyIG5leHQgPSBwb2ludHNbaSsxXTtcblxuICAgICAgZm9yICh2YXIgeCA9IGN1clswXTsgeCA8IG5leHRbMF07IHgrKykge1xuICAgICAgICB2YXIgdCA9ICh4IC0gY3VyWzBdKSAvIChuZXh0WzBdIC0gY3VyWzBdKTtcblxuICAgICAgICB2YXIgYSA9IDEgLSB0O1xuICAgICAgICB2YXIgYiA9IHQ7XG4gICAgICAgIHZhciBoID0gbmV4dFswXSAtIGN1clswXTtcblxuICAgICAgICB2YXIgeSA9IGEgKiBjdXJbMV0gKyBiICogbmV4dFsxXSArIChoKmgvNikgKiAoIChhKmEqYS1hKSpzZFtpXSsoYipiKmItYikqc2RbaSsxXSk7XG5cbiAgICAgICAgaWYgKHkgPiAyNTUpIHtcbiAgICAgICAgICB5ID0gMjU1O1xuICAgICAgICB9IGVsc2UgaWYgKHkgPCAwKSB7XG4gICAgICAgICAgeSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQucHVzaChbeCwgeV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvdXRwdXQubGVuZ3RoID09PSAyNTUpIHtcbiAgICAgIG91dHB1dC5wdXNoKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICBfc2Vjb25kRGVyaXZhdGl2ZSAocG9pbnRzKSB7XG4gICAgdmFyIG4gPSBwb2ludHMubGVuZ3RoO1xuICAgIGlmIChuIDw9IDAgfHwgbiA9PT0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1hdHJpeCA9IFtdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgaSwgaztcblxuICAgIG1hdHJpeFswXSA9IFswLCAxLCAwXTtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBuLTE7IGkrKykge1xuICAgICAgdmFyIFAxID0gcG9pbnRzW2kgLSAxXTtcbiAgICAgIHZhciBQMiA9IHBvaW50c1tpXTtcbiAgICAgIHZhciBQMyA9IHBvaW50c1tpICsgMV07XG5cbiAgICAgIG1hdHJpeFtpXSA9IG1hdHJpeFtpXSB8fCBbXTtcbiAgICAgIG1hdHJpeFtpXVswXSA9IChQMlswXSAtIFAxWzBdKSAvIDY7XG4gICAgICBtYXRyaXhbaV1bMV0gPSAoUDNbMF0gLSBQMVswXSkgLyAzO1xuICAgICAgbWF0cml4W2ldWzJdID0gKFAzWzBdIC0gUDJbMF0pIC8gNjtcbiAgICAgIHJlc3VsdFtpXSA9IChQM1sxXSAtIFAyWzFdKSAvIChQM1swXSAtIFAyWzBdKSAtIChQMlsxXSAtIFAxWzFdKSAvIChQMlswXSAtIFAxWzBdKTtcbiAgICB9XG5cbiAgICByZXN1bHRbMF0gPSAwO1xuICAgIHJlc3VsdFtuIC0gMV0gPSAwO1xuXG4gICAgbWF0cml4W24gLSAxXSA9IFswLCAxLCAwXTtcblxuICAgIC8vIFBhc3MgMVxuICAgIGZvciAoaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgIGsgPSBtYXRyaXhbMV1bMF0gLyBtYXRyaXhbaS0xXVsxXTtcbiAgICAgIG1hdHJpeFtpXVsxXSAtPSBrICogbWF0cml4W2ktMV1bMl07XG4gICAgICBtYXRyaXhbaV1bMF0gPSAwO1xuICAgICAgcmVzdWx0W2ldIC09IGsgKiByZXN1bHRbaS0xXTtcbiAgICB9XG5cbiAgICAvLyBQYXNzIDJcbiAgICBmb3IgKGkgPSBuIC0gMjsgaSA+IDA7IGktLSkge1xuICAgICAgayA9IG1hdHJpeFtpXVsyXSAvIG1hdHJpeFtpKzFdWzFdO1xuICAgICAgbWF0cml4W2ldWzFdIC09IGsgKiBtYXRyaXhbaSsxXVswXTtcbiAgICAgIG1hdHJpeFtpXVsyXSA9IDA7XG4gICAgICByZXN1bHRbaV0gLT0gayAqIHJlc3VsdFtpKzFdO1xuICAgIH1cblxuICAgIHZhciB5MiA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIHkyW2ldID0gcmVzdWx0W2ldIC8gbWF0cml4W2ldWzFdO1xuICAgIH1cblxuICAgIHJldHVybiB5MjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUb25lQ3VydmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IFByaW1pdGl2ZSBmcm9tIFwiLi9wcmltaXRpdmVcIjtcblxuLyoqXG4gKiBYNDAwIHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZXMuWDQwMFxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmV9XG4gKi9cbmNsYXNzIFg0MDAgZXh0ZW5kcyBQcmltaXRpdmUge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYWdtZW50IHNoYWRlciBmb3IgdGhpcyBwcmltaXRpdmVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9mcmFnbWVudFNoYWRlciA9IGBcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XG4gICAgICAgIGZsb2F0IGdyYXkgPSB0ZXhDb2xvci5yICogMC4zICsgdGV4Q29sb3IuZyAqIDAuMyArIHRleENvbG9yLmIgKiAwLjM7XG4gICAgICAgIGdyYXkgLT0gMC4yO1xuICAgICAgICBncmF5ID0gY2xhbXAoZ3JheSwgMC4wLCAxLjApO1xuICAgICAgICBncmF5ICs9IDAuMTU7XG4gICAgICAgIGdyYXkgKj0gMS40O1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMoZ3JheSksIDEuMCk7XG4gICAgICB9XG4gICAgYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBwcmltaXRpdmUgKFdlYkdMKVxuICAgKiBAcGFyYW0gIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmVuZGVyV2ViR0wgKHJlbmRlcmVyKSB7XG4gICAgcmVuZGVyZXIucnVuU2hhZGVyKG51bGwsIHRoaXMuX2ZyYWdtZW50U2hhZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBwcmltaXRpdmUgKENhbnZhcylcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqL1xuICByZW5kZXJDYW52YXMgKHJlbmRlcmVyKSB7XG4gICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgIHZhciBpbWFnZURhdGEgPSByZW5kZXJlci5nZXRDb250ZXh0KCkuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNhbnZhcy53aWR0aDsgeCsrKSB7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICB2YXIgaW5kZXggPSAoY2FudmFzLndpZHRoICogeSArIHgpICogNDtcblxuICAgICAgICB2YXIgZ3JheSA9IGltYWdlRGF0YS5kYXRhW2luZGV4XSAvIDI1NSAqIDAuMyArIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gLyAyNTUgKiAwLjMgKyBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdIC8gMjU1ICogMC4zO1xuICAgICAgICBncmF5IC09IDAuMjtcbiAgICAgICAgZ3JheSA9IE1hdGgubWF4KDAuMCwgTWF0aC5taW4oMS4wLCBncmF5KSk7XG4gICAgICAgIGdyYXkgKz0gMC4xNTtcbiAgICAgICAgZ3JheSAqPSAxLjQ7XG5cbiAgICAgICAgZ3JheSAqPSAyNTU7XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IGdyYXk7XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSBncmF5O1xuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdID0gZ3JheTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXJlci5nZXRDb250ZXh0KCkucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgWDQwMDtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gXCIuL2ZpbHRlclwiO1xuXG4vKipcbiAqIFF1b3ppIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5RdW96aUZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuY2xhc3MgUXVvemlGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAqIHRoZSBhY3RpdmUgZmlsdGVyLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBpZGVudGlmaWVyICgpIHtcbiAgICByZXR1cm4gXCJxdW96aVwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlciAocmVuZGVyZXIpIHtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRmlsdGVyLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgLy8gRGVzYXR1cmF0aW9uXG4gICAgc3RhY2suYWRkKG5ldyBGaWx0ZXIuUHJpbWl0aXZlcy5EZXNhdHVyYXRpb24oe1xuICAgICAgZGVzYXR1cmF0aW9uOiAwLjY1XG4gICAgfSkpO1xuXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDUwXSxcbiAgICAgICAgICBbNDAsIDc4XSxcbiAgICAgICAgICBbMTE4LCAxNzBdLFxuICAgICAgICAgIFsxODEsIDIxMV0sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCAyN10sXG4gICAgICAgICAgWzI4LCA0NV0sXG4gICAgICAgICAgWzEwOSwgMTU3XSxcbiAgICAgICAgICBbMTU3LCAxOTVdLFxuICAgICAgICAgIFsxNzksIDIwOF0sXG4gICAgICAgICAgWzIwNiwgMjEyXSxcbiAgICAgICAgICBbMjU1LCAyNDBdXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgNTBdLFxuICAgICAgICAgIFsxMiwgNTVdLFxuICAgICAgICAgIFs0NiwgMTAzXSxcbiAgICAgICAgICBbMTAzLCAxNjJdLFxuICAgICAgICAgIFsxOTQsIDE4Ml0sXG4gICAgICAgICAgWzI0MSwgMjAxXSxcbiAgICAgICAgICBbMjU1LCAyMTldXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFF1b3ppRmlsdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSBcIi4vZmlsdGVyXCI7XG5cbi8qKlxuICogU2VtaXJlZCBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlcnMuU2VtaXJlZEZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuY2xhc3MgU2VtaXJlZEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiBcInNlbWlyZWRcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICByZW5kZXIgKHJlbmRlcmVyKSB7XG4gICAgdmFyIHN0YWNrID0gbmV3IEZpbHRlci5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDEyOV0sXG4gICAgICAgICAgWzc1LCAxNTNdLFxuICAgICAgICAgIFsxODEsIDIyN10sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCA4XSxcbiAgICAgICAgICBbMTExLCA4NV0sXG4gICAgICAgICAgWzIxMiwgMTU4XSxcbiAgICAgICAgICBbMjU1LCAyMjZdXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgNV0sXG4gICAgICAgICAgWzc1LCAyMl0sXG4gICAgICAgICAgWzE5MywgOTBdLFxuICAgICAgICAgIFsyNTUsIDIyOV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuR2xvdygpKTtcblxuICAgIHN0YWNrLnJlbmRlcihyZW5kZXJlcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VtaXJlZEZpbHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gXCIuL2ZpbHRlclwiO1xuXG4vKipcbiAqIFN1bm55IEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5TdW5ueUZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuY2xhc3MgU3VubnlGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAqIHRoZSBhY3RpdmUgZmlsdGVyLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBpZGVudGlmaWVyICgpIHtcbiAgICByZXR1cm4gXCJzdW5ueVwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlciAocmVuZGVyZXIpIHtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRmlsdGVyLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgc3RhY2suYWRkKG5ldyBGaWx0ZXIuUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzYyLCA4Ml0sXG4gICAgICAgICAgWzE0MSwgMTU0XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDM5XSxcbiAgICAgICAgICBbNTYsIDk2XSxcbiAgICAgICAgICBbMTkyLCAxNzZdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXSxcbiAgICAgICAgYmx1ZTogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMTc0LCA5OV0sXG4gICAgICAgICAgWzI1NSwgMjM1XVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgc3RhY2suYWRkKG5ldyBGaWx0ZXIuUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgY29udHJvbFBvaW50czogW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFs1NSwgMjBdLFxuICAgICAgICBbMTU4LCAxOTFdLFxuICAgICAgICBbMjU1LCAyNTVdXG4gICAgICBdXG4gICAgfSkpO1xuXG4gICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdW5ueUZpbHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gXCIuL2ZpbHRlclwiO1xuXG4vKipcbiAqIFRleGFzIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5UZXhhc0ZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuY2xhc3MgVGV4YXNGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAqIHRoZSBhY3RpdmUgZmlsdGVyLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBpZGVudGlmaWVyICgpIHtcbiAgICByZXR1cm4gXCJ0ZXhhc1wiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlciAocmVuZGVyZXIpIHtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRmlsdGVyLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgc3RhY2suYWRkKG5ldyBGaWx0ZXIuUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgNzJdLFxuICAgICAgICAgIFs4OSwgOTldLFxuICAgICAgICAgIFsxNzYsIDIxMl0sXG4gICAgICAgICAgWzI1NSwgMjM3XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCA0OV0sXG4gICAgICAgICAgWzI1NSwgMTkyXVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDcyXSxcbiAgICAgICAgICBbMjU1LCAxNTFdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRleGFzRmlsdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSBcIi4vZmlsdGVyXCI7XG5cbi8qKlxuICogWDQwMCBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlcnMuWDQwMEZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuY2xhc3MgWDQwMEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiBcIng0MDBcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICByZW5kZXIgKHJlbmRlcmVyKSB7XG4gICAgdmFyIHN0YWNrID0gbmV3IEZpbHRlci5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgIHN0YWNrLmFkZChuZXcgRmlsdGVyLlByaW1pdGl2ZXMuWDQwMCgpKTtcblxuICAgIHN0YWNrLnJlbmRlcihyZW5kZXJlcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgWDQwMEZpbHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5pbXBvcnQgT3BlcmF0aW9uIGZyb20gXCIuL29wZXJhdGlvblwiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi9saWIvdXRpbHNcIjtcblxuLyoqXG4gKiBBbiBvcGVyYXRpb24gdGhhdCBjYW4gZmxpcCB0aGUgY2FudmFzXG4gKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuT3BlcmF0aW9ucy5GbGlwT3BlcmF0aW9uXG4gKiBAZXh0ZW5kcyBJbWdseUtpdC5PcGVyYXRpb25cbiAqL1xuY2xhc3MgRmxpcE9wZXJhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgdGhpcy5hdmFpbGFibGVPcHRpb25zID0ge1xuICAgICAgaG9yaXpvbnRhbDogeyB0eXBlOiBcImJvb2xlYW5cIiwgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgIHZlcnRpY2FsOiB7IHR5cGU6IFwiYm9vbGVhblwiLCBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIgdXNlZCBmb3IgdGhpcyBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gYFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XG4gICAgICB1bmlmb3JtIGJvb2wgdV9mbGlwVmVydGljYWw7XG4gICAgICB1bmlmb3JtIGJvb2wgdV9mbGlwSG9yaXpvbnRhbDtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWMyIHRleENvb3JkID0gdmVjMih2X3RleENvb3JkKTtcbiAgICAgICAgaWYgKHVfZmxpcFZlcnRpY2FsKSB7XG4gICAgICAgICAgdGV4Q29vcmQueSA9IDEuMCAtIHRleENvb3JkLnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVfZmxpcEhvcml6b250YWwpIHtcbiAgICAgICAgICB0ZXhDb29yZC54ID0gMS4wIC0gdGV4Q29vcmQueDtcbiAgICAgICAgfVxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdGV4Q29vcmQpO1xuICAgICAgfVxuICAgIGA7XG5cbiAgICBzdXBlciguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogb3BlcmF0aW9ucy5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBpZGVudGlmaWVyICgpIHtcbiAgICByZXR1cm4gXCJmbGlwXCI7XG4gIH1cblxuICAvKipcbiAgICogQ3JvcHMgdGhpcyBpbWFnZSB1c2luZyBXZWJHTFxuICAgKiBAcGFyYW0gIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgX3JlbmRlcldlYkdMIChyZW5kZXJlcikge1xuICAgIHJlbmRlcmVyLnJ1blNoYWRlcihudWxsLCBGbGlwT3BlcmF0aW9uLmZyYWdtZW50U2hhZGVyLCB7XG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICB1X2ZsaXBWZXJ0aWNhbDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IHRoaXMuX29wdGlvbnMudmVydGljYWwgfSxcbiAgICAgICAgdV9mbGlwSG9yaXpvbnRhbDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IHRoaXMuX29wdGlvbnMuaG9yaXpvbnRhbCB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JvcHMgdGhlIGltYWdlIHVzaW5nIENhbnZhczJEXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgX3JlbmRlckNhbnZhcyAocmVuZGVyZXIpIHtcbiAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG4gICAgdmFyIGNvbnRleHQgPSByZW5kZXJlci5nZXRDb250ZXh0KCk7XG5cbiAgICB2YXIgc2NhbGVYID0gMSwgc2NhbGVZID0gMTtcbiAgICB2YXIgdHJhbnNsYXRlWCA9IDAsIHRyYW5zbGF0ZVkgPSAwO1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuaG9yaXpvbnRhbCkge1xuICAgICAgc2NhbGVYID0gLTE7XG4gICAgICB0cmFuc2xhdGVYID0gY2FudmFzLndpZHRoO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnZlcnRpY2FsKSB7XG4gICAgICBzY2FsZVkgPSAtMTtcbiAgICAgIHRyYW5zbGF0ZVkgPSBjYW52YXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgIC8vIEFwcGx5IHRoZSB0cmFuc2Zvcm1hdGlvblxuICAgIGNvbnRleHQudHJhbnNsYXRlKHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVkpO1xuICAgIGNvbnRleHQuc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuXG4gICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGNhbnZhcyBzbyB0aGF0IHdlIGNhbiBkcmF3IHRoZSBpbWFnZVxuICAgIC8vIHdpdGggdGhlIGFwcGxpZWQgdHJhbnNmb3JtYXRpb25cbiAgICB2YXIgdGVtcENhbnZhcyA9IHJlbmRlcmVyLmNsb25lQ2FudmFzKCk7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UodGVtcENhbnZhcywgMCwgMCk7XG5cbiAgICAvLyBSZXN0b3JlIG9sZCB0cmFuc2Zvcm1hdGlvblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZsaXBPcGVyYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IE9wZXJhdGlvbiBmcm9tIFwiLi9vcGVyYXRpb25cIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vbGliL2NvbG9yXCI7XG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIHRoYXQgY2FuIGZyYW1lcyBvbiB0aGUgY2FudmFzXG4gKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuT3BlcmF0aW9ucy5GcmFtZXNPcGVyYXRpb25cbiAqIEBleHRlbmRzIEltZ2x5S2l0Lk9wZXJhdGlvblxuICovXG5jbGFzcyBGcmFtZXNPcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHRoaXMuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgICAgIGNvbG9yOiB7IHR5cGU6IFwiY29sb3JcIiwgZGVmYXVsdDogbmV3IENvbG9yKDAsIDAsIDAsIDEpIH0sXG4gICAgICB0aGlja25lc3M6IHsgdHlwZTogXCJudW1iZXJcIiwgZGVmYXVsdDogMC4wMiB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIGluZGV4IHVzZWQgZm9yIHRoZSBmcmFtZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90ZXh0dXJlSW5kZXggPSAxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYWdtZW50IHNoYWRlciB1c2VkIGZvciB0aGlzIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gYFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ZyYW1lSW1hZ2U7XG4gICAgICB1bmlmb3JtIHZlYzQgdV9jb2xvcjtcbiAgICAgIHVuaWZvcm0gdmVjMiB1X3RoaWNrbmVzcztcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWM0IGZyYWdDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcbiAgICAgICAgaWYgKHZfdGV4Q29vcmQueCA8IHVfdGhpY2tuZXNzLnggfHwgdl90ZXhDb29yZC54ID4gMS4wIC0gdV90aGlja25lc3MueCB8fFxuICAgICAgICAgIHZfdGV4Q29vcmQueSA8IHVfdGhpY2tuZXNzLnkgfHwgdl90ZXhDb29yZC55ID4gMS4wIC0gdV90aGlja25lc3MueSkge1xuICAgICAgICAgICAgZnJhZ0NvbG9yID0gdV9jb2xvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gZnJhZ0NvbG9yO1xuICAgICAgfVxuICAgIGA7XG5cbiAgICBzdXBlciguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogb3BlcmF0aW9ucy5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBpZGVudGlmaWVyICgpIHtcbiAgICByZXR1cm4gXCJmcmFtZXNcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcm9wcyB0aGlzIGltYWdlIHVzaW5nIFdlYkdMXG4gICAqIEBwYXJhbSAge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBfcmVuZGVyV2ViR0wgKHJlbmRlcmVyKSB7XG4gICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuXG4gICAgdmFyIGNvbG9yID0gdGhpcy5fb3B0aW9ucy5jb2xvcjtcbiAgICB2YXIgdGhpY2tuZXNzID0gdGhpcy5fb3B0aW9ucy50aGlja25lc3MgKiBjYW52YXMuaGVpZ2h0O1xuICAgIHZhciB0aGlja25lc3NWZWMyID0gW3RoaWNrbmVzcyAvIGNhbnZhcy53aWR0aCwgdGhpY2tuZXNzIC8gY2FudmFzLmhlaWdodF07XG5cbiAgICByZW5kZXJlci5ydW5TaGFkZXIobnVsbCwgdGhpcy5fZnJhZ21lbnRTaGFkZXIsIHtcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHVfY29sb3I6IHsgdHlwZTogXCI0ZlwiLCB2YWx1ZTogY29sb3IudG9HTENvbG9yKCkgfSxcbiAgICAgICAgdV90aGlja25lc3M6IHsgdHlwZTogXCIyZlwiLCB2YWx1ZTogdGhpY2tuZXNzVmVjMiB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JvcHMgdGhlIGltYWdlIHVzaW5nIENhbnZhczJEXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckNhbnZhcyAocmVuZGVyZXIpIHtcbiAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG4gICAgdmFyIGNvbnRleHQgPSByZW5kZXJlci5nZXRDb250ZXh0KCk7XG5cbiAgICB2YXIgY29sb3IgPSB0aGlzLl9vcHRpb25zLmNvbG9yO1xuICAgIHZhciB0aGlja25lc3MgPSB0aGlzLl9vcHRpb25zLnRoaWNrbmVzcyAqIGNhbnZhcy5oZWlnaHQ7XG5cbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gdGhpY2tuZXNzICogMjtcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3IudG9SR0JBKCk7XG4gICAgY29udGV4dC5yZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGcmFtZXNPcGVyYXRpb247XG4iLCIvKiBqc2hpbnQgdW51c2VkOmZhbHNlICovXG4vKiBqc2hpbnQgLVcwODMgKi9cblwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgVmVjdG9yMiBmcm9tIFwiLi4vbGliL21hdGgvdmVjdG9yMlwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9saWIvY29sb3JcIjtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBPcGVyYXRpb25zLiBFeHRlbmRhYmxlIHZpYSB7QGxpbmsgSW1nbHlLaXQuT3BlcmF0aW9uI2V4dGVuZH0uXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5PcGVyYXRpb25cbiAqL1xuY2xhc3MgT3BlcmF0aW9uIHtcbiAgY29uc3RydWN0b3IgKGtpdCwgb3B0aW9ucykge1xuICAgIGlmIChraXQuY29uc3RydWN0b3IubmFtZSAhPT0gXCJJbWdseUtpdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcGVyYXRpb246IEZpcnN0IHBhcmFtZXRlciBmb3IgY29uc3RydWN0b3IgaGFzIHRvIGJlIGFuIEltZ2x5S2l0IGluc3RhbmNlLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9raXQgPSBraXQ7XG4gICAgdGhpcy5hdmFpbGFibGVPcHRpb25zID0gXy5leHRlbmQodGhpcy5hdmFpbGFibGVPcHRpb25zIHx8IHt9LCB7XG4gICAgICBudW1iZXJGb3JtYXQ6IHsgdHlwZTogXCJzdHJpbmdcIiwgZGVmYXVsdDogXCJyZWxhdGl2ZVwiLCBhdmFpbGFibGU6IFtcImFic29sdXRlXCIsIFwicmVsYXRpdmVcIl0gfVxuICAgIH0pO1xuXG4gICAgdGhpcy5faW5pdE9wdGlvbnMob3B0aW9ucyB8fCB7fSk7XG4gIH1cblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAqIG9wZXJhdGlvbnMuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgaWRlbnRpZmllciAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBPcGVyYXRpb24gY2FuIGJlIGFwcGxpZWQgdGhlIHdheSBpdCBpcyBjb25maWd1cmVkXG4gICAqL1xuICB2YWxpZGF0ZVNldHRpbmdzICgpIHtcbiAgICB2YXIgaWRlbnRpZmllciA9IHRoaXMuaWRlbnRpZmllcjtcblxuICAgIC8vIENoZWNrIGZvciByZXF1aXJlZCBvcHRpb25zXG4gICAgZm9yICh2YXIgb3B0aW9uTmFtZSBpbiB0aGlzLmF2YWlsYWJsZU9wdGlvbnMpIHtcbiAgICAgIHZhciBvcHRpb25Db25maWcgPSB0aGlzLmF2YWlsYWJsZU9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgICBpZiAob3B0aW9uQ29uZmlnLnJlcXVpcmVkICYmIHR5cGVvZiB0aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wZXJhdGlvbiBgXCIgKyBpZGVudGlmaWVyICsgXCJgOiBPcHRpb24gYFwiICsgb3B0aW9uTmFtZSArIFwiYCBpcyByZXF1aXJlZC5cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJlcikge1xuICAgIGlmIChyZW5kZXJlci5pZGVudGlmaWVyID09PSBcIndlYmdsXCIpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB0aGlzLl9yZW5kZXJXZWJHTChyZW5kZXJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlckNhbnZhcyhyZW5kZXJlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBvcGVyYXRpb24gdXNpbmcgV2ViR0xcbiAgICogQHJldHVybiB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJXZWJHTCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT3BlcmF0aW9uI19yZW5kZXJXZWJHTCBpcyBhYnN0cmFjdCBhbmQgbm90IGltcGxlbWVudGVkIGluIGluaGVyaXRlZCBjbGFzcy5cIik7XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIG9wZXJhdGlvbiB1c2luZyBDYW52YXMyRFxuICAgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJDYW52YXMgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk9wZXJhdGlvbiNfcmVuZGVyQ2FudmFzIGlzIGFic3RyYWN0IGFuZCBub3QgaW1wbGVtZW50ZWQgaW4gaW5oZXJpdGVkIGNsYXNzLlwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHb2VzIHRocm91Z2ggdGhlIGF2YWlsYWJsZSBvcHRpb25zLCBzZXRzIF9vcHRpb25zIGRlZmF1bHRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyT3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRPcHRpb25zICh1c2VyT3B0aW9ucykge1xuICAgIHRoaXMuX29wdGlvbnMgPSB7fTtcblxuICAgIC8vIFNldCBkZWZhdWx0cywgY3JlYXRlIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICB2YXIgb3B0aW9uTmFtZSwgb3B0aW9uLCBjYXBpdGFsaXplZDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZm9yIChvcHRpb25OYW1lIGluIHRoaXMuYXZhaWxhYmxlT3B0aW9ucykge1xuICAgICAgb3B0aW9uID0gdGhpcy5hdmFpbGFibGVPcHRpb25zW29wdGlvbk5hbWVdO1xuXG4gICAgICAvLyBTZXQgZGVmYXVsdCBpZiBhdmFpbGFibGVcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uLmRlZmF1bHQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXSA9IG9wdGlvbi5kZWZhdWx0O1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgc2V0dGVyIGFuZCBnZXR0ZXJcbiAgICAgIChmdW5jdGlvbiAob3B0aW9uTmFtZSwgb3B0aW9uKSB7XG4gICAgICAgIGNhcGl0YWxpemVkID0gb3B0aW9uTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG9wdGlvbk5hbWUuc2xpY2UoMSk7XG5cbiAgICAgICAgc2VsZltcInNldFwiICsgY2FwaXRhbGl6ZWRdID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb24uc2V0dGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG9wdGlvbi5zZXR0ZXIuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuX3NldE9wdGlvbihvcHRpb25OYW1lLCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRGVmYXVsdCBnZXR0ZXJcbiAgICAgICAgc2VsZltcImdldFwiICsgY2FwaXRhbGl6ZWRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRPcHRpb24ob3B0aW9uTmFtZSk7XG4gICAgICAgIH07XG4gICAgICB9KShvcHRpb25OYW1lLCBvcHRpb24pO1xuXG4gICAgfVxuXG4gICAgLy8gT3ZlcndyaXRlIG9wdGlvbnMgd2l0aCB0aGUgb25lcyBnaXZlbiBieSB1c2VyXG4gICAgZm9yIChvcHRpb25OYW1lIGluIHVzZXJPcHRpb25zKSB7XG4gICAgICAvLyBDaGVjayBpZiBvcHRpb24gaXMgYXZhaWxhYmxlXG4gICAgICBpZiAodHlwZW9mIHRoaXMuYXZhaWxhYmxlT3B0aW9uc1tvcHRpb25OYW1lXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9wdGlvbjogXCIgKyBvcHRpb25OYW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsbCBzZXR0ZXJcbiAgICAgIGNhcGl0YWxpemVkID0gb3B0aW9uTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG9wdGlvbk5hbWUuc2xpY2UoMSk7XG4gICAgICB0aGlzW1wic2V0XCIgKyBjYXBpdGFsaXplZF0odXNlck9wdGlvbnNbb3B0aW9uTmFtZV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIG9wdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uTmFtZVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldE9wdGlvbiAob3B0aW9uTmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gb3B0aW9uLCB2YWxpZGF0ZXMgaXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbk5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldE9wdGlvbiAob3B0aW9uTmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgb3B0aW9uQ29uZmlnID0gdGhpcy5hdmFpbGFibGVPcHRpb25zW29wdGlvbk5hbWVdO1xuICAgIHZhciBpZGVudGlmaWVyID0gdGhpcy5pZGVudGlmaWVyO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25Db25maWcudmFsaWRhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgb3B0aW9uQ29uZmlnLnZhbGlkYXRpb24odmFsdWUpO1xuICAgIH1cblxuICAgIHN3aXRjaCAob3B0aW9uQ29uZmlnLnR5cGUpIHtcbiAgICAgIC8vIFN0cmluZyBvcHRpb25zXG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcGVyYXRpb24gYFwiICsgaWRlbnRpZmllciArIFwiYDogT3B0aW9uIGBcIiArIG9wdGlvbk5hbWUgKyBcImAgaGFzIHRvIGJlIGEgc3RyaW5nLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0cmluZyB2YWx1ZSByZXN0cmljdGlvbnNcbiAgICAgICAgdmFyIGF2YWlsYWJsZSA9IG9wdGlvbkNvbmZpZy5hdmFpbGFibGU7XG4gICAgICAgIGlmICh0eXBlb2YgYXZhaWxhYmxlICE9PSBcInVuZGVmaW5lZFwiICYmIGF2YWlsYWJsZS5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcGVyYXRpb24gYFwiICsgaWRlbnRpZmllciArIFwiYDogSW52YWxpZCB2YWx1ZSBmb3IgYFwiICsgb3B0aW9uTmFtZSArIFwiYCAodmFsaWQgdmFsdWVzIGFyZTogXCIgKyBvcHRpb25Db25maWcuYXZhaWxhYmxlLmpvaW4oXCIsIFwiKSArIFwiKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIE51bWJlciBvcHRpb25zXG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcGVyYXRpb24gYFwiICsgaWRlbnRpZmllciArIFwiYDogT3B0aW9uIGBcIiArIG9wdGlvbk5hbWUgKyBcImAgaGFzIHRvIGJlIGEgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIEJvb2xlYW4gb3B0aW9uc1xuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcGVyYXRpb24gYFwiICsgaWRlbnRpZmllciArIFwiYDogT3B0aW9uIGBcIiArIG9wdGlvbk5hbWUgKyBcImAgaGFzIHRvIGJlIGEgYm9vbGVhbi5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBWZWN0b3IyIG9wdGlvbnNcbiAgICAgIGNhc2UgXCJ2ZWN0b3IyXCI6XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgVmVjdG9yMikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcGVyYXRpb24gYFwiICsgaWRlbnRpZmllciArIFwiYDogT3B0aW9uIGBcIiArIG9wdGlvbk5hbWUgKyBcImAgaGFzIHRvIGJlIGFuIGluc3RhbmNlIG9mIEltZ2x5S2l0LlZlY3RvcjIuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlLmNsb25lKCk7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIENvbG9yIG9wdGlvbnNcbiAgICAgIGNhc2UgXCJjb2xvclwiOlxuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIENvbG9yKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wZXJhdGlvbiBgXCIgKyBpZGVudGlmaWVyICsgXCJgOiBPcHRpb24gYFwiICsgb3B0aW9uTmFtZSArIFwiYCBoYXMgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgSW1nbHlLaXQuQ29sb3IuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUbyBjcmVhdGUgYW4ge0BsaW5rIEltZ2x5S2l0Lk9wZXJhdGlvbn0gY2xhc3Mgb2YgeW91ciBvd24sIGNhbGwgdGhpc1xuICogbWV0aG9kIGFuZCBwcm92aWRlIGluc3RhbmNlIHByb3BlcnRpZXMgYW5kIGZ1bmN0aW9ucy5cbiAqIEBmdW5jdGlvblxuICovXG5pbXBvcnQgZXh0ZW5kIGZyb20gXCIuLi9saWIvZXh0ZW5kXCI7XG5PcGVyYXRpb24uZXh0ZW5kID0gZXh0ZW5kO1xuXG5leHBvcnQgZGVmYXVsdCBPcGVyYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IE9wZXJhdGlvbiBmcm9tIFwiLi9vcGVyYXRpb25cIjtcbmltcG9ydCBWZWN0b3IyIGZyb20gXCIuLi9saWIvbWF0aC92ZWN0b3IyXCI7XG5pbXBvcnQgU3RhY2tCbHVyIGZyb20gXCIuLi92ZW5kb3Ivc3RhY2stYmx1clwiO1xuXG4vKipcbiAqIEFuIG9wZXJhdGlvbiB0aGF0IGNhbiBjcm9wIG91dCBhIHBhcnQgb2YgdGhlIGltYWdlXG4gKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuT3BlcmF0aW9ucy5SYWRpYWxCbHVyT3BlcmF0aW9uXG4gKiBAZXh0ZW5kcyBJbWdseUtpdC5PcGVyYXRpb25cbiAqL1xuY2xhc3MgUmFkaWFsQmx1ck9wZXJhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgdGhpcy5hdmFpbGFibGVPcHRpb25zID0ge1xuICAgICAgcG9zaXRpb246IHsgdHlwZTogXCJ2ZWN0b3IyXCIsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDAuNSwgMC41KSB9LFxuICAgICAgZ3JhZGllbnRSYWRpdXM6IHsgdHlwZTogXCJudW1iZXJcIiwgZGVmYXVsdDogNTAgfSxcbiAgICAgIGJsdXJSYWRpdXM6IHsgdHlwZTogXCJudW1iZXJcIiwgZGVmYXVsdDogMjAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIHVzZWQgZm9yIHRoaXMgb3BlcmF0aW9uXG4gICAgICogQGludGVybmFsIEJhc2VkIG9uIGV2YW53J3MgZ2xmeC5qcyB0aWx0IHNoaWZ0IHNoYWRlcjpcbiAgICAgKiAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYmx1ci90aWx0c2hpZnQuanNcbiAgICAgKi9cbiAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gYFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xuICAgICAgdW5pZm9ybSBmbG9hdCBibHVyUmFkaXVzO1xuICAgICAgdW5pZm9ybSBmbG9hdCBncmFkaWVudFJhZGl1cztcbiAgICAgIHVuaWZvcm0gdmVjMiBwb3NpdGlvbjtcbiAgICAgIHVuaWZvcm0gdmVjMiBkZWx0YTtcbiAgICAgIHVuaWZvcm0gdmVjMiB0ZXhTaXplO1xuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XG5cbiAgICAgIGZsb2F0IHJhbmRvbSh2ZWMzIHNjYWxlLCBmbG9hdCBzZWVkKSB7XG4gICAgICAgIHJldHVybiBmcmFjdChzaW4oZG90KGdsX0ZyYWdDb29yZC54eXogKyBzZWVkLCBzY2FsZSkpICogNDM3NTguNTQ1MyArIHNlZWQpO1xuICAgICAgfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgdmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcbiAgICAgICAgICBmbG9hdCB0b3RhbCA9IDAuMDtcblxuICAgICAgICAgIGZsb2F0IG9mZnNldCA9IHJhbmRvbSh2ZWMzKDEyLjk4OTgsIDc4LjIzMywgMTUxLjcxODIpLCAwLjApO1xuICAgICAgICAgIGZsb2F0IHJhZGl1cyA9IHNtb290aHN0ZXAoMC4wLCAxLjAsIGFicyhkaXN0YW5jZSh2X3RleENvb3JkICogdGV4U2l6ZSwgcG9zaXRpb24pKSAvIChncmFkaWVudFJhZGl1cyAqIDIuMCkpICogYmx1clJhZGl1cztcbiAgICAgICAgICBmb3IgKGZsb2F0IHQgPSAtMzAuMDsgdCA8PSAzMC4wOyB0KyspIHtcbiAgICAgICAgICAgICAgZmxvYXQgcGVyY2VudCA9ICh0ICsgb2Zmc2V0IC0gMC41KSAvIDMwLjA7XG4gICAgICAgICAgICAgIGZsb2F0IHdlaWdodCA9IDEuMCAtIGFicyhwZXJjZW50KTtcbiAgICAgICAgICAgICAgdmVjNCBzYW1wbGUgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCArIGRlbHRhICogcGVyY2VudCAqIHJhZGl1cyAvIHRleFNpemUpO1xuXG4gICAgICAgICAgICAgIHNhbXBsZS5yZ2IgKj0gc2FtcGxlLmE7XG5cbiAgICAgICAgICAgICAgY29sb3IgKz0gc2FtcGxlICogd2VpZ2h0O1xuICAgICAgICAgICAgICB0b3RhbCArPSB3ZWlnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgLyB0b3RhbDtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IucmdiIC89IGdsX0ZyYWdDb2xvci5hICsgMC4wMDAwMTtcbiAgICAgIH1cbiAgICBgO1xuXG4gICAgc3VwZXIoLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAqIG9wZXJhdGlvbnMuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgaWRlbnRpZmllciAoKSB7XG4gICAgcmV0dXJuIFwicmFkaWFsLWJsdXJcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcm9wcyB0aGlzIGltYWdlIHVzaW5nIFdlYkdMXG4gICAqIEBwYXJhbSAge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBfcmVuZGVyV2ViR0wgKHJlbmRlcmVyKSB7XG4gICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgIHZhciBjYW52YXNTaXplID0gbmV3IFZlY3RvcjIoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX29wdGlvbnMucG9zaXRpb24uY2xvbmUoKTtcbiAgICBwb3NpdGlvbi55ID0gY2FudmFzU2l6ZS55IC0gcG9zaXRpb24ueTtcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLm51bWJlckZvcm1hdCA9PT0gXCJyZWxhdGl2ZVwiKSB7XG4gICAgICBwb3NpdGlvbi5tdWx0aXBseShjYW52YXNTaXplKTtcbiAgICB9XG5cbiAgICB2YXIgdW5pZm9ybXMgPSB7XG4gICAgICBibHVyUmFkaXVzOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogdGhpcy5fb3B0aW9ucy5ibHVyUmFkaXVzIH0sXG4gICAgICBncmFkaWVudFJhZGl1czogeyB0eXBlOiBcImZcIiwgdmFsdWU6IHRoaXMuX29wdGlvbnMuZ3JhZGllbnRSYWRpdXMgfSxcbiAgICAgIHBvc2l0aW9uOiB7IHR5cGU6IFwiMmZcIiwgdmFsdWU6IFtwb3NpdGlvbi54LCBwb3NpdGlvbi55XSB9LFxuICAgICAgdGV4U2l6ZTogeyB0eXBlOiBcIjJmXCIsIHZhbHVlOiBbY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0XSB9LFxuICAgICAgZGVsdGE6IHsgdHlwZTogXCIyZlwiLCB2YWx1ZTogWzEsIDFdIH1cbiAgICB9O1xuXG4gICAgLy8gRmlyc3QgcGFzc1xuICAgIHJlbmRlcmVyLnJ1blNoYWRlcihudWxsLCBSYWRpYWxCbHVyT3BlcmF0aW9uLmZyYWdtZW50U2hhZGVyLCB7XG4gICAgICB1bmlmb3JtczogdW5pZm9ybXNcbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBkZWx0YSBmb3Igc2Vjb25kIHBhc3NcbiAgICB1bmlmb3Jtcy5kZWx0YS52YWx1ZSA9IFstMSwgMV07XG5cbiAgICByZW5kZXJlci5ydW5TaGFkZXIobnVsbCwgUmFkaWFsQmx1ck9wZXJhdGlvbi5mcmFnbWVudFNoYWRlciwge1xuICAgICAgdW5pZm9ybXM6IHVuaWZvcm1zXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JvcHMgdGhlIGltYWdlIHVzaW5nIENhbnZhczJEXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgX3JlbmRlckNhbnZhcyAocmVuZGVyZXIpIHtcbiAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG5cbiAgICB2YXIgYmx1cnJ5Q2FudmFzID0gdGhpcy5fYmx1ckNhbnZhcyhyZW5kZXJlcik7XG4gICAgdmFyIG1hc2tDYW52YXMgPSB0aGlzLl9jcmVhdGVNYXNrKHJlbmRlcmVyKTtcblxuICAgIHRoaXMuX2FwcGx5TWFzayhjYW52YXMsIGJsdXJyeUNhbnZhcywgbWFza0NhbnZhcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGJsdXJyZWQgY29weSBvZiB0aGUgY2FudmFzXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtDYW52YXN9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYmx1ckNhbnZhcyAocmVuZGVyZXIpIHtcbiAgICB2YXIgbmV3Q2FudmFzID0gcmVuZGVyZXIuY2xvbmVDYW52YXMoKTtcbiAgICB2YXIgYmx1cnJ5Q29udGV4dCA9IG5ld0NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgdmFyIGJsdXJyeUltYWdlRGF0YSA9IGJsdXJyeUNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIG5ld0NhbnZhcy53aWR0aCwgbmV3Q2FudmFzLmhlaWdodCk7XG4gICAgU3RhY2tCbHVyLnN0YWNrQmx1ckNhbnZhc1JHQkEoYmx1cnJ5SW1hZ2VEYXRhLCAwLCAwLCBuZXdDYW52YXMud2lkdGgsIG5ld0NhbnZhcy5oZWlnaHQsIHRoaXMuX29wdGlvbnMuYmx1clJhZGl1cyk7XG4gICAgYmx1cnJ5Q29udGV4dC5wdXRJbWFnZURhdGEoYmx1cnJ5SW1hZ2VEYXRhLCAwLCAwKTtcblxuICAgIHJldHVybiBuZXdDYW52YXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgbWFzayBjYW52YXNcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge0NhbnZhc31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVNYXNrIChyZW5kZXJlcikge1xuICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcblxuICAgIHZhciBjYW52YXNTaXplID0gbmV3IFZlY3RvcjIoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB2YXIgZ3JhZGllbnRSYWRpdXMgPSB0aGlzLl9vcHRpb25zLmdyYWRpZW50UmFkaXVzO1xuXG4gICAgdmFyIG1hc2tDYW52YXMgPSByZW5kZXJlci5jcmVhdGVDYW52YXMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB2YXIgbWFza0NvbnRleHQgPSBtYXNrQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX29wdGlvbnMucG9zaXRpb24uY2xvbmUoKTtcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLm51bWJlckZvcm1hdCA9PT0gXCJyZWxhdGl2ZVwiKSB7XG4gICAgICBwb3NpdGlvbi5tdWx0aXBseShjYW52YXNTaXplKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCBncmFkaWVudFxuICAgIHZhciBncmFkaWVudCA9IG1hc2tDb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KFxuICAgICAgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgMCxcbiAgICAgIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIGdyYWRpZW50UmFkaXVzXG4gICAgKTtcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgXCIjRkZGRkZGXCIpO1xuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLjUsIFwiIzAwMDAwMFwiKTtcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgXCIjMDAwMDAwXCIpO1xuXG4gICAgLy8gRHJhdyBncmFkaWVudFxuICAgIG1hc2tDb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgIG1hc2tDb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICByZXR1cm4gbWFza0NhbnZhcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBibHVyIGFuZCBtYXNrIHRvIHRoZSBpbnB1dCBjYW52YXNcbiAgICogQHBhcmFtICB7Q2FudmFzfSBpbnB1dENhbnZhc1xuICAgKiBAcGFyYW0gIHtDYW52YXN9IGJsdXJyeUNhbnZhc1xuICAgKiBAcGFyYW0gIHtDYW52YXN9IG1hc2tDYW52YXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseU1hc2sgKGlucHV0Q2FudmFzLCBibHVycnlDYW52YXMsIG1hc2tDYW52YXMpIHtcbiAgICB2YXIgaW5wdXRDb250ZXh0ID0gaW5wdXRDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIHZhciBibHVycnlDb250ZXh0ID0gYmx1cnJ5Q2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICB2YXIgbWFza0NvbnRleHQgPSBtYXNrQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgIHZhciBpbnB1dEltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW5wdXRDYW52YXMud2lkdGgsIGlucHV0Q2FudmFzLmhlaWdodCk7XG4gICAgdmFyIHBpeGVscyA9IGlucHV0SW1hZ2VEYXRhLmRhdGE7XG4gICAgdmFyIGJsdXJyeVBpeGVscyA9IGJsdXJyeUNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGlucHV0Q2FudmFzLndpZHRoLCBpbnB1dENhbnZhcy5oZWlnaHQpLmRhdGE7XG4gICAgdmFyIG1hc2tQaXhlbHMgPSBtYXNrQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW5wdXRDYW52YXMud2lkdGgsIGlucHV0Q2FudmFzLmhlaWdodCkuZGF0YTtcblxuICAgIHZhciBpbmRleCwgYWxwaGE7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBpbnB1dENhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBpbnB1dENhbnZhcy53aWR0aDsgeCsrKSB7XG4gICAgICAgIGluZGV4ID0gKHkgKiBpbnB1dENhbnZhcy53aWR0aCArIHgpICogNDtcbiAgICAgICAgYWxwaGEgPSBtYXNrUGl4ZWxzW2luZGV4XSAvIDI1NTtcblxuICAgICAgICBwaXhlbHNbaW5kZXhdID0gYWxwaGEgKiBwaXhlbHNbaW5kZXhdICsgKDEgLSBhbHBoYSkgKiBibHVycnlQaXhlbHNbaW5kZXhdO1xuICAgICAgICBwaXhlbHNbaW5kZXggKyAxXSA9IGFscGhhICogcGl4ZWxzW2luZGV4ICsgMV0gKyAoMSAtIGFscGhhKSAqIGJsdXJyeVBpeGVsc1tpbmRleCArIDFdO1xuICAgICAgICBwaXhlbHNbaW5kZXggKyAyXSA9IGFscGhhICogcGl4ZWxzW2luZGV4ICsgMl0gKyAoMSAtIGFscGhhKSAqIGJsdXJyeVBpeGVsc1tpbmRleCArIDJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlucHV0Q29udGV4dC5wdXRJbWFnZURhdGEoaW5wdXRJbWFnZURhdGEsIDAsIDApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJhZGlhbEJsdXJPcGVyYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IE9wZXJhdGlvbiBmcm9tIFwiLi9vcGVyYXRpb25cIjtcblxuLyoqXG4gKiBBbiBvcGVyYXRpb24gdGhhdCBjYW4gcm90YXRlIHRoZSBjYW52YXNcbiAqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5PcGVyYXRpb25zLlJvdGF0aW9uT3BlcmF0aW9uXG4gKiBAZXh0ZW5kcyBJbWdseUtpdC5PcGVyYXRpb25cbiAqL1xuY2xhc3MgUm90YXRpb25PcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHRoaXMuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgICAgIGRlZ3JlZXM6IHsgdHlwZTogXCJudW1iZXJcIiwgZGVmYXVsdDogMCwgdmFsaWRhdGlvbjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAlIDkwICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm90YXRpb25PcGVyYXRpb246IGByb3RhdGlvbmAgaGFzIHRvIGJlIGEgbXVsdGlwbGUgb2YgOTAuXCIpO1xuICAgICAgICB9XG4gICAgICB9fVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIHVzZWQgZm9yIHRoaXMgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSBgXG4gICAgICBhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xuICAgICAgYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xuICAgICAgdW5pZm9ybSBtYXQzIHVfbWF0cml4O1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgodV9tYXRyaXggKiB2ZWMzKGFfcG9zaXRpb24sIDEpKS54eSwgMCwgMSk7XG4gICAgICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xuICAgICAgfVxuICAgIGA7XG5cbiAgICBzdXBlciguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogb3BlcmF0aW9ucy5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBpZGVudGlmaWVyICgpIHtcbiAgICByZXR1cm4gXCJyb3RhdGlvblwiO1xuICB9XG5cbiAgLyoqXG4gICAqIENyb3BzIHRoaXMgaW1hZ2UgdXNpbmcgV2ViR0xcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIF9yZW5kZXJXZWJHTCAocmVuZGVyZXIpIHtcbiAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG4gICAgdmFyIGdsID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpO1xuXG4gICAgdmFyIGFjdHVhbERlZ3JlZXMgPSB0aGlzLl9vcHRpb25zLmRlZ3JlZXMgJSAzNjA7XG4gICAgdmFyIGxhc3RUZXh0dXJlID0gcmVuZGVyZXIuZ2V0TGFzdFRleHR1cmUoKTtcblxuICAgIC8vIElmIHdlJ3JlIG5vdCByb3RhdGluZyBieSAxODAgZGVncmVlcywgd2UgbmVlZCB0byByZXNpemUgdGhlIGNhbnZhc1xuICAgIC8vIGFuZCB0aGUgdGV4dHVyZVxuICAgIGlmIChhY3R1YWxEZWdyZWVzICUgMTgwICE9PSAwKSB7XG4gICAgICAvLyBSZXNpemUgdGhlIGNhbnZhc1xuICAgICAgdmFyIHdpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSB3aWR0aDtcblxuICAgICAgLy8gUmVzaXplIHRoZSBjdXJyZW50IHRleHR1cmVcbiAgICAgIHZhciBjdXJyZW50VGV4dHVyZSA9IHJlbmRlcmVyLmdldEN1cnJlbnRUZXh0dXJlKCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBjdXJyZW50VGV4dHVyZSk7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cbiAgICAgIC8vIFJlc2l6ZSBhbGwgb3RoZXIgdGV4dHVyZXMgZXhjZXB0IHRoZSBpbnB1dCB0ZXh0dXJlXG4gICAgICB2YXIgdGV4dHVyZXMgPSByZW5kZXJlci5nZXRUZXh0dXJlcygpO1xuICAgICAgdmFyIHRleHR1cmU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlc1tpXTtcblxuICAgICAgICAvLyBXZSByZXNpemUgdGhlIGlucHV0IHRleHR1cmUgYXQgdGhlIGVuZFxuICAgICAgICBpZiAodGV4dHVyZSA9PT0gbGFzdFRleHR1cmUpIGNvbnRpbnVlO1xuXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIHJvdGF0aW9uIG1hdHJpeFxuICAgIHZhciByYWRpYW5zID0gYWN0dWFsRGVncmVlcyAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICB2YXIgYyA9IE1hdGguY29zKHJhZGlhbnMpO1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkaWFucyk7XG4gICAgdmFyIHJvdGF0aW9uTWF0cml4ID0gW1xuICAgICAgYywtcywgMCxcbiAgICAgIHMsIGMsIDAsXG4gICAgICAwLCAwLCAxXG4gICAgXTtcblxuICAgIC8vIFJ1biB0aGUgc2hhZGVyXG4gICAgcmVuZGVyZXIucnVuU2hhZGVyKHRoaXMudmVydGV4U2hhZGVyLCBudWxsLCB7XG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICB1X21hdHJpeDogeyB0eXBlOiBcIm1hdDNmdlwiLCB2YWx1ZTogcm90YXRpb25NYXRyaXggfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVzaXplIHRoZSBpbnB1dCB0ZXh0dXJlXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbGFzdFRleHR1cmUpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcm9wcyB0aGUgaW1hZ2UgdXNpbmcgQ2FudmFzMkRcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqL1xuICBfcmVuZGVyQ2FudmFzIChyZW5kZXJlcikge1xuICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcblxuICAgIHZhciBhY3R1YWxEZWdyZWVzID0gdGhpcy5fb3B0aW9ucy5kZWdyZWVzICUgMzYwO1xuICAgIHZhciB3aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcblxuICAgIGlmIChhY3R1YWxEZWdyZWVzICUgMTgwICE9PSAwKSB7XG4gICAgICB3aWR0aCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICBoZWlnaHQgPSBjYW52YXMud2lkdGg7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgcm90YXRlZCBjYW52YXNcbiAgICB2YXIgbmV3Q2FudmFzID0gcmVuZGVyZXIuY3JlYXRlQ2FudmFzKCk7XG4gICAgbmV3Q2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgbmV3Q2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICB2YXIgbmV3Q29udGV4dCA9IG5ld0NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICBuZXdDb250ZXh0LnNhdmUoKTtcblxuICAgIC8vIFRyYW5zbGF0ZSB0aGUgY2FudmFzXG4gICAgbmV3Q29udGV4dC50cmFuc2xhdGUobmV3Q2FudmFzLndpZHRoIC8gMiwgbmV3Q2FudmFzLmhlaWdodCAvIDIpO1xuXG4gICAgLy8gUm90YXRlIHRoZSBjYW52YXNcbiAgICBuZXdDb250ZXh0LnJvdGF0ZShhY3R1YWxEZWdyZWVzICogKE1hdGguUEkgLyAxODApKTtcblxuICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBjYW52YXMgc28gdGhhdCB3ZSBjYW4gZHJhdyB0aGUgaW1hZ2VcbiAgICAvLyB3aXRoIHRoZSBhcHBsaWVkIHRyYW5zZm9ybWF0aW9uXG4gICAgdmFyIHRlbXBDYW52YXMgPSByZW5kZXJlci5jbG9uZUNhbnZhcygpO1xuICAgIG5ld0NvbnRleHQuZHJhd0ltYWdlKHRlbXBDYW52YXMsIC1jYW52YXMud2lkdGggLyAyLCAtY2FudmFzLmhlaWdodCAvIDIpO1xuXG4gICAgLy8gUmVzdG9yZSBvbGQgdHJhbnNmb3JtYXRpb25cbiAgICBuZXdDb250ZXh0LnJlc3RvcmUoKTtcblxuICAgIHJlbmRlcmVyLnNldENhbnZhcyhuZXdDYW52YXMpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJvdGF0aW9uT3BlcmF0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBPcGVyYXRpb24gZnJvbSBcIi4vb3BlcmF0aW9uXCI7XG5pbXBvcnQgUHJpbWl0aXZlc1N0YWNrIGZyb20gXCIuL2ZpbHRlcnMvcHJpbWl0aXZlcy1zdGFja1wiO1xuaW1wb3J0IFNhdHVyYXRpb25QcmltaXRpdmUgZnJvbSBcIi4vZmlsdGVycy9wcmltaXRpdmVzL3NhdHVyYXRpb25cIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5PcGVyYXRpb25zLlNhdHVyYXRpb25PcGVyYXRpb25cbiAqIEBleHRlbmRzIEltZ2x5S2l0Lk9wZXJhdGlvblxuICovXG5jbGFzcyBTYXR1cmF0aW9uT3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gICAgICBzYXR1cmF0aW9uOiB7IHR5cGU6IFwibnVtYmVyXCIsIGRlZmF1bHQ6IDEuMCB9XG4gICAgfTtcblxuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiBvcGVyYXRpb25zLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiBcInNhdHVyYXRpb25cIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICByZW5kZXIgKHJlbmRlcmVyKSB7XG4gICAgdmFyIHN0YWNrID0gbmV3IFByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgc3RhY2suYWRkKG5ldyBTYXR1cmF0aW9uUHJpbWl0aXZlKHtcbiAgICAgIHNhdHVyYXRpb246IHRoaXMuX29wdGlvbnMuc2F0dXJhdGlvblxuICAgIH0pKTtcblxuICAgIHN0YWNrLnJlbmRlcihyZW5kZXJlcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2F0dXJhdGlvbk9wZXJhdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5pbXBvcnQgT3BlcmF0aW9uIGZyb20gXCIuL29wZXJhdGlvblwiO1xuaW1wb3J0IFZlY3RvcjIgZnJvbSBcIi4uL2xpYi9tYXRoL3ZlY3RvcjJcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vbGliL3V0aWxzXCI7XG5pbXBvcnQgYmx1ZWJpcmQgZnJvbSBcImJsdWViaXJkXCI7XG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIHRoYXQgY2FuIGRyYXcgdGV4dCBvbiB0aGUgY2FudmFzXG4gKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuT3BlcmF0aW9ucy5TdGlja2Vyc09wZXJhdGlvblxuICogQGV4dGVuZHMgSW1nbHlLaXQuT3BlcmF0aW9uXG4gKi9cbmNsYXNzIFN0aWNrZXJzT3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gICAgICBzdGlja2VyOiB7IHR5cGU6IFwic3RyaW5nXCIsIHJlcXVpcmVkOiB0cnVlIH0sXG4gICAgICBwb3NpdGlvbjogeyB0eXBlOiBcInZlY3RvcjJcIiwgZGVmYXVsdDogbmV3IFZlY3RvcjIoMCwgMCkgfSxcbiAgICAgIHNpemU6IHsgdHlwZTogXCJ2ZWN0b3IyXCIgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIGluZGV4IHVzZWQgZm9yIHRoZSBzdGlja2VyXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RleHR1cmVJbmRleCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIHVzZWQgZm9yIHRoaXMgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdGhpcy5fZnJhZ21lbnRTaGFkZXIgPSBgXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfc3RpY2tlckltYWdlO1xuICAgICAgdW5pZm9ybSB2ZWMyIHVfcG9zaXRpb247XG4gICAgICB1bmlmb3JtIHZlYzIgdV9zaXplO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzQgY29sb3IwID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xuICAgICAgICB2ZWMyIHJlbGF0aXZlID0gKHZfdGV4Q29vcmQgLSB1X3Bvc2l0aW9uKSAvIHVfc2l6ZTtcblxuICAgICAgICBpZiAocmVsYXRpdmUueCA+PSAwLjAgJiYgcmVsYXRpdmUueCA8PSAxLjAgJiZcbiAgICAgICAgICByZWxhdGl2ZS55ID49IDAuMCAmJiByZWxhdGl2ZS55IDw9IDEuMCkge1xuXG4gICAgICAgICAgICB2ZWM0IGNvbG9yMSA9IHRleHR1cmUyRCh1X3N0aWNrZXJJbWFnZSwgcmVsYXRpdmUpO1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChtaXgoY29sb3IwLnJnYiwgY29sb3IxLnJnYiwgY29sb3IxLmEpLCAxLjApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjA7XG5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIGA7XG5cbiAgICBzdXBlciguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogb3BlcmF0aW9ucy5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBpZGVudGlmaWVyICgpIHtcbiAgICByZXR1cm4gXCJzdGlja2Vyc1wiO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgcmVuZGVyIChyZW5kZXJlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5fbG9hZFN0aWNrZXIoKVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgIGlmIChyZW5kZXJlci5pZGVudGlmaWVyID09PSBcIndlYmdsXCIpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHJldHVybiBzZWxmLl9yZW5kZXJXZWJHTChyZW5kZXJlciwgaW1hZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzZWxmLl9yZW5kZXJDYW52YXMocmVuZGVyZXIsIGltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JvcHMgdGhpcyBpbWFnZSB1c2luZyBXZWJHTFxuICAgKiBAcGFyYW0gIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtJbWFnZX0gaW1hZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIF9yZW5kZXJXZWJHTCAocmVuZGVyZXIsIGltYWdlKSB7XG4gICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgIHZhciBnbCA9IHJlbmRlcmVyLmdldENvbnRleHQoKTtcblxuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX29wdGlvbnMucG9zaXRpb24uY2xvbmUoKTtcbiAgICB2YXIgY2FudmFzU2l6ZSA9IG5ldyBWZWN0b3IyKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5udW1iZXJGb3JtYXQgPT09IFwiYWJzb2x1dGVcIikge1xuICAgICAgcG9zaXRpb24uZGl2aWRlKGNhbnZhc1NpemUpO1xuICAgIH1cblxuICAgIHZhciBzaXplID0gbmV3IFZlY3RvcjIoaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLnNpemUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHNpemUuY29weSh0aGlzLl9vcHRpb25zLnNpemUpO1xuXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5udW1iZXJGb3JtYXQgPT09IFwicmVsYXRpdmVcIikge1xuICAgICAgICBzaXplLm11bHRpcGx5KGNhbnZhc1NpemUpO1xuICAgICAgfVxuICAgIH1cbiAgICBzaXplLmRpdmlkZShjYW52YXNTaXplKTtcblxuICAgIHBvc2l0aW9uLnkgPSAxIC0gcG9zaXRpb24ueTsgLy8gSW52ZXJ0IHlcbiAgICBwb3NpdGlvbi55IC09IHNpemUueTsgLy8gRml4IHlcblxuICAgIC8vIFVwbG9hZCB0aGUgdGV4dHVyZVxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLl90ZXh0dXJlSW5kZXgpO1xuICAgIHRoaXMuX3RleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblxuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuXG4gICAgLy8gRXhlY3V0ZSB0aGUgc2hhZGVyXG4gICAgcmVuZGVyZXIucnVuU2hhZGVyKG51bGwsIHRoaXMuX2ZyYWdtZW50U2hhZGVyLCB7XG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICB1X3N0aWNrZXJJbWFnZTogeyB0eXBlOiBcImlcIiwgdmFsdWU6IHRoaXMuX3RleHR1cmVJbmRleCB9LFxuICAgICAgICB1X3Bvc2l0aW9uOiB7IHR5cGU6IFwiMmZcIiwgdmFsdWU6IFtwb3NpdGlvbi54LCBwb3NpdGlvbi55XSB9LFxuICAgICAgICB1X3NpemU6IHsgdHlwZTogXCIyZlwiLCB2YWx1ZTogW3NpemUueCwgc2l6ZS55XSB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JvcHMgdGhlIGltYWdlIHVzaW5nIENhbnZhczJEXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtJbWFnZX0gaW1hZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJDYW52YXMgKHJlbmRlcmVyLCBpbWFnZSkge1xuICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcbiAgICB2YXIgY29udGV4dCA9IHJlbmRlcmVyLmdldENvbnRleHQoKTtcblxuICAgIHZhciBjYW52YXNTaXplID0gbmV3IFZlY3RvcjIoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB2YXIgc2NhbGVkUG9zaXRpb24gPSB0aGlzLl9vcHRpb25zLnBvc2l0aW9uLmNsb25lKCk7XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5udW1iZXJGb3JtYXQgPT09IFwicmVsYXRpdmVcIikge1xuICAgICAgc2NhbGVkUG9zaXRpb24ubXVsdGlwbHkoY2FudmFzU2l6ZSk7XG4gICAgfVxuXG4gICAgdmFyIHNpemUgPSBuZXcgVmVjdG9yMihpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcbiAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMuc2l6ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgc2l6ZS5jb3B5KHRoaXMuX29wdGlvbnMuc2l6ZSk7XG5cbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLm51bWJlckZvcm1hdCA9PT0gXCJyZWxhdGl2ZVwiKSB7XG4gICAgICAgIHNpemUubXVsdGlwbHkoY2FudmFzU2l6ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsXG4gICAgICAwLCAwLFxuICAgICAgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCxcbiAgICAgIHNjYWxlZFBvc2l0aW9uLngsIHNjYWxlZFBvc2l0aW9uLnksXG4gICAgICBzaXplLngsIHNpemUueSk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgdGhlIHN0aWNrZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sb2FkU3RpY2tlciAoKSB7XG4gICAgdmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgdmFyIHN0aWNrZXJGaWxlTmFtZSA9IFwic3RpY2tlcnMvc3RpY2tlci1cIiArIHRoaXMuX29wdGlvbnMuc3RpY2tlciArIFwiLnBuZ1wiO1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkSW1hZ2VCcm93c2VyKHN0aWNrZXJGaWxlTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkSW1hZ2VOb2RlKHN0aWNrZXJGaWxlTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBnaXZlbiBpbWFnZSB1c2luZyB0aGUgYnJvd3NlcidzIGBJbWFnZWAgY2xhc3NcbiAgICogQHBhcmFtICB7U3RyaW5nfSBmaWxlTmFtZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2xvYWRJbWFnZUJyb3dzZXIgKGZpbGVOYW1lKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNvbHZlKGltYWdlKTtcbiAgICAgIH0pO1xuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNvdWxkIG5vdCBsb2FkIHN0aWNrZXI6IFwiICsgZmlsZU5hbWUpKTtcbiAgICAgIH0pO1xuXG4gICAgICBpbWFnZS5zcmMgPSBzZWxmLl9raXQuZ2V0QXNzZXRQYXRoKGZpbGVOYW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgZ2l2ZW4gaW1hZ2UgdXNpbmcgbm9kZS5qcycgYGZzYCBhbmQgbm9kZS1jYW52YXMgYEltYWdlYFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGZpbGVOYW1lXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbG9hZEltYWdlTm9kZSAoZmlsZU5hbWUpIHtcbiAgICB2YXIgQ2FudmFzID0gcmVxdWlyZShcImNhbnZhc1wiKTtcbiAgICB2YXIgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGltYWdlID0gbmV3IENhbnZhcy5JbWFnZSgpO1xuICAgIHZhciBwYXRoID0gc2VsZi5fa2l0LmdldEFzc2V0UGF0aChmaWxlTmFtZSk7XG5cbiAgICByZXR1cm4gYmx1ZWJpcmQucHJvbWlzaWZ5KGZzLnJlYWRGaWxlKShwYXRoKVxuICAgICAgLnRoZW4oZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIGltYWdlLnNyYyA9IGJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RpY2tlcnNPcGVyYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IE9wZXJhdGlvbiBmcm9tIFwiLi9vcGVyYXRpb25cIjtcbmltcG9ydCBWZWN0b3IyIGZyb20gXCIuLi9saWIvbWF0aC92ZWN0b3IyXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL2xpYi9jb2xvclwiO1xuXG4vKipcbiAqIEFuIG9wZXJhdGlvbiB0aGF0IGNhbiBkcmF3IHRleHQgb24gdGhlIGNhbnZhc1xuICpcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0Lk9wZXJhdGlvbnMuVGV4dE9wZXJhdGlvblxuICogQGV4dGVuZHMgSW1nbHlLaXQuT3BlcmF0aW9uXG4gKi9cbmNsYXNzIFRleHRPcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHRoaXMuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgICAgIGZvbnRTaXplOiB7IHR5cGU6IFwibnVtYmVyXCIsIGRlZmF1bHQ6IDMwIH0sXG4gICAgICBsaW5lSGVpZ2h0OiB7IHR5cGU6IFwibnVtYmVyXCIsIGRlZmF1bHQ6IDEuMSB9LFxuICAgICAgZm9udEZhbWlseTogeyB0eXBlOiBcInN0cmluZ1wiLCBkZWZhdWx0OiBcIlRpbWVzIE5ldyBSb21hblwiIH0sXG4gICAgICBmb250V2VpZ2h0OiB7IHR5cGU6IFwic3RyaW5nXCIsIGRlZmF1bHQ6IFwibm9ybWFsXCIgfSxcbiAgICAgIGFsaWdubWVudDogeyB0eXBlOiBcInN0cmluZ1wiLCBkZWZhdWx0OiBcImxlZnRcIiwgYXZhaWxhYmxlOiBbXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIl0gfSxcbiAgICAgIHZlcnRpY2FsQWxpZ25tZW50OiB7IHR5cGU6IFwic3RyaW5nXCIsIGRlZmF1bHQ6IFwidG9wXCIsIGF2YWlsYWJsZTogW1widG9wXCIsIFwiY2VudGVyXCIsIFwiYm90dG9tXCJdIH0sXG4gICAgICBjb2xvcjogeyB0eXBlOiBcImNvbG9yXCIsIGRlZmF1bHQ6IG5ldyBDb2xvcigwLCAwLCAwLCAxKSB9LFxuICAgICAgcG9zaXRpb246IHsgdHlwZTogXCJ2ZWN0b3IyXCIsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDAsIDApIH0sXG4gICAgICB0ZXh0OiB7IHR5cGU6IFwic3RyaW5nXCIsIHJlcXVpcmVkOiB0cnVlIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHR1cmUgaW5kZXggdXNlZCBmb3IgdGhlIHRleHRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fdGV4dHVyZUluZGV4ID0gMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIgdXNlZCBmb3IgdGhpcyBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0aGlzLl9mcmFnbWVudFNoYWRlciA9IGBcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0SW1hZ2U7XG4gICAgICB1bmlmb3JtIHZlYzIgdV9wb3NpdGlvbjtcbiAgICAgIHVuaWZvcm0gdmVjMiB1X3NpemU7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCBjb2xvcjAgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XG4gICAgICAgIHZlYzIgcmVsYXRpdmUgPSAodl90ZXhDb29yZCAtIHVfcG9zaXRpb24pIC8gdV9zaXplO1xuXG4gICAgICAgIGlmIChyZWxhdGl2ZS54ID49IDAuMCAmJiByZWxhdGl2ZS54IDw9IDEuMCAmJlxuICAgICAgICAgIHJlbGF0aXZlLnkgPj0gMC4wICYmIHJlbGF0aXZlLnkgPD0gMS4wKSB7XG5cbiAgICAgICAgICAgIHZlYzQgY29sb3IxID0gdGV4dHVyZTJEKHVfdGV4dEltYWdlLCByZWxhdGl2ZSk7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KG1peChjb2xvcjAucmdiLCBjb2xvcjEucmdiLCBjb2xvcjEuYSksIDEuMCk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yMDtcblxuICAgICAgICB9XG4gICAgICB9XG4gICAgYDtcblxuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiBvcGVyYXRpb25zLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiBcInRleHRcIjtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENyb3BzIHRoaXMgaW1hZ2UgdXNpbmcgV2ViR0xcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIF9yZW5kZXJXZWJHTCAocmVuZGVyZXIpIHtcbiAgICB2YXIgdGV4dENhbnZhcyA9IHRoaXMuX3JlbmRlclRleHRDYW52YXMocmVuZGVyZXIpO1xuXG4gICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgIHZhciBnbCA9IHJlbmRlcmVyLmdldENvbnRleHQoKTtcblxuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX29wdGlvbnMucG9zaXRpb24uY2xvbmUoKTtcbiAgICB2YXIgY2FudmFzU2l6ZSA9IG5ldyBWZWN0b3IyKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgdmFyIHNpemUgPSBuZXcgVmVjdG9yMih0ZXh0Q2FudmFzLndpZHRoLCB0ZXh0Q2FudmFzLmhlaWdodCkuZGl2aWRlKGNhbnZhc1NpemUpO1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMubnVtYmVyRm9ybWF0ID09PSBcImFic29sdXRlXCIpIHtcbiAgICAgIHBvc2l0aW9uLmRpdmlkZShjYW52YXNTaXplKTtcbiAgICB9XG5cbiAgICBwb3NpdGlvbi55ID0gMSAtIHBvc2l0aW9uLnk7IC8vIEludmVydCB5XG4gICAgcG9zaXRpb24ueSAtPSBzaXplLnk7IC8vIEZpeCB5XG5cbiAgICAvLyBBZGp1c3QgdmVydGljYWwgYWxpZ25tZW50XG4gICAgaWYgKHRoaXMuX29wdGlvbnMudmVydGljYWxBbGlnbm1lbnQgPT09IFwiY2VudGVyXCIpIHtcbiAgICAgIHBvc2l0aW9uLnkgKz0gc2l6ZS55IC8gMjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMudmVydGljYWxBbGlnbm1lbnQgPT09IFwiYm90dG9tXCIpIHtcbiAgICAgIHBvc2l0aW9uLnkgKz0gc2l6ZS55O1xuICAgIH1cblxuICAgIC8vIEFkanVzdCBob3Jpem9udGFsIGFsaWdubWVudFxuICAgIGlmICh0aGlzLl9vcHRpb25zLmFsaWdubWVudCA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgcG9zaXRpb24ueCAtPSBzaXplLnggLyAyO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5hbGlnbm1lbnQgPT09IFwicmlnaHRcIikge1xuICAgICAgcG9zaXRpb24ueCAtPSBzaXplLng7XG4gICAgfVxuXG4gICAgLy8gVXBsb2FkIHRoZSB0ZXh0dXJlXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuX3RleHR1cmVJbmRleCk7XG4gICAgdGhpcy5fdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0ZXh0Q2FudmFzKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcblxuICAgIC8vIEV4ZWN1dGUgdGhlIHNoYWRlclxuICAgIHJlbmRlcmVyLnJ1blNoYWRlcihudWxsLCB0aGlzLl9mcmFnbWVudFNoYWRlciwge1xuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdV90ZXh0SW1hZ2U6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiB0aGlzLl90ZXh0dXJlSW5kZXggfSxcbiAgICAgICAgdV9wb3NpdGlvbjogeyB0eXBlOiBcIjJmXCIsIHZhbHVlOiBbcG9zaXRpb24ueCwgcG9zaXRpb24ueV0gfSxcbiAgICAgICAgdV9zaXplOiB7IHR5cGU6IFwiMmZcIiwgdmFsdWU6IFtzaXplLngsIHNpemUueV0gfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyb3BzIHRoZSBpbWFnZSB1c2luZyBDYW52YXMyRFxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIF9yZW5kZXJDYW52YXMgKHJlbmRlcmVyKSB7XG4gICAgdmFyIHRleHRDYW52YXMgPSB0aGlzLl9yZW5kZXJUZXh0Q2FudmFzKHJlbmRlcmVyKTtcblxuICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcbiAgICB2YXIgY29udGV4dCA9IHJlbmRlcmVyLmdldENvbnRleHQoKTtcblxuICAgIHZhciBjYW52YXNTaXplID0gbmV3IFZlY3RvcjIoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB2YXIgc2NhbGVkUG9zaXRpb24gPSB0aGlzLl9vcHRpb25zLnBvc2l0aW9uLmNsb25lKCk7XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5udW1iZXJGb3JtYXQgPT09IFwicmVsYXRpdmVcIikge1xuICAgICAgc2NhbGVkUG9zaXRpb24ubXVsdGlwbHkoY2FudmFzU2l6ZSk7XG4gICAgfVxuXG4gICAgLy8gQWRqdXN0IHZlcnRpY2FsIGFsaWdubWVudFxuICAgIGlmICh0aGlzLl9vcHRpb25zLnZlcnRpY2FsQWxpZ25tZW50ID09PSBcImNlbnRlclwiKSB7XG4gICAgICBzY2FsZWRQb3NpdGlvbi55IC09IHRleHRDYW52YXMuaGVpZ2h0IC8gMjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMudmVydGljYWxBbGlnbm1lbnQgPT09IFwiYm90dG9tXCIpIHtcbiAgICAgIHNjYWxlZFBvc2l0aW9uLnkgLT0gdGV4dENhbnZhcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gQWRqdXN0IGhvcml6b250YWwgYWxpZ25tZW50XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuYWxpZ25tZW50ID09PSBcImNlbnRlclwiKSB7XG4gICAgICBzY2FsZWRQb3NpdGlvbi54IC09IHRleHRDYW52YXMud2lkdGggLyAyO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5hbGlnbm1lbnQgPT09IFwicmlnaHRcIikge1xuICAgICAgc2NhbGVkUG9zaXRpb24ueCAtPSB0ZXh0Q2FudmFzLndpZHRoO1xuICAgIH1cblxuICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHRDYW52YXMsIHNjYWxlZFBvc2l0aW9uLngsIHNjYWxlZFBvc2l0aW9uLnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHRleHQgY2FudmFzIHRoYXQgd2lsbCBiZSB1c2VkIGFzIGEgdGV4dHVyZSBpbiBXZWJHTFxuICAgKiBhbmQgYXMgYW4gaW1hZ2UgaW4gY2FudmFzXG4gICAqIEByZXR1cm4ge0NhbnZhc31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJUZXh0Q2FudmFzIChyZW5kZXJlcikge1xuICAgIHZhciBsaW5lLCBsaW5lTnVtO1xuICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5jcmVhdGVDYW52YXMoKTtcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgdmFyIG1heFdpZHRoID0gdGhpcy5fb3B0aW9ucy5tYXhXaWR0aDtcbiAgICB2YXIgYWN0dWFsTGluZUhlaWdodCA9IHRoaXMuX29wdGlvbnMubGluZUhlaWdodCAqIHRoaXMuX29wdGlvbnMuZm9udFNpemU7XG5cbiAgICAvLyBBcHBseSB0ZXh0IG9wdGlvbnNcbiAgICB0aGlzLl9hcHBseVRleHRPcHRpb25zKGNvbnRleHQpO1xuXG4gICAgdmFyIGJvdW5kaW5nQm94ID0gbmV3IFZlY3RvcjIoKTtcblxuICAgIHZhciBsaW5lcyA9IHRoaXMuX29wdGlvbnMudGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICBpZiAodHlwZW9mIG1heFdpZHRoICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGJvdW5kaW5nIGJveFxuICAgICAgYm91bmRpbmdCb3gueCA9IHRoaXMuX29wdGlvbnMubWF4V2lkdGg7XG4gICAgICBsaW5lcyA9IHRoaXMuX2J1aWxkT3V0cHV0TGluZXMoY29udGV4dCwgbWF4V2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxpbmVOdW0gPSAwOyBsaW5lTnVtIDwgbGluZXMubGVuZ3RoOyBsaW5lTnVtKyspIHtcbiAgICAgICAgbGluZSA9IGxpbmVzW2xpbmVOdW1dO1xuICAgICAgICBib3VuZGluZ0JveC54ID0gTWF0aC5tYXgoYm91bmRpbmdCb3gueCwgY29udGV4dC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGJvdW5kaW5nYm94IGhlaWdodFxuICAgIGJvdW5kaW5nQm94LnkgPSBhY3R1YWxMaW5lSGVpZ2h0ICogbGluZXMubGVuZ3RoO1xuXG4gICAgLy8gUmVzaXplIHRoZSBjYW52YXNcbiAgICBjYW52YXMud2lkdGggPSBib3VuZGluZ0JveC54O1xuICAgIGNhbnZhcy5oZWlnaHQgPSBib3VuZGluZ0JveC55O1xuXG4gICAgLy8gR2V0IHRoZSBjb250ZXh0IGFnYWluLCBhcHBseSB0ZXh0IG9wdGlvbnNcbiAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICB0aGlzLl9hcHBseVRleHRPcHRpb25zKGNvbnRleHQpO1xuXG4gICAgLy8gRHJhdyBsaW5lc1xuICAgIGZvciAobGluZU51bSA9IDA7IGxpbmVOdW0gPCBsaW5lcy5sZW5ndGg7IGxpbmVOdW0rKykge1xuICAgICAgbGluZSA9IGxpbmVzW2xpbmVOdW1dO1xuICAgICAgdGhpcy5fZHJhd1RleHQoY29udGV4dCwgbGluZSwgYWN0dWFsTGluZUhlaWdodCAqIGxpbmVOdW0pO1xuICAgIH1cblxuICAgIHJldHVybiBjYW52YXM7XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgdGV4dCBvcHRpb25zIG9uIHRoZSBnaXZlbiBjb250ZXh0XG4gICAqIEBwYXJhbSAge1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5VGV4dE9wdGlvbnMgKGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmZvbnQgPSB0aGlzLl9vcHRpb25zLmZvbnRXZWlnaHQgKyBcIiBcIiArXG4gICAgICB0aGlzLl9vcHRpb25zLmZvbnRTaXplICsgXCJweCBcIiArXG4gICAgICB0aGlzLl9vcHRpb25zLmZvbnRGYW1pbHk7XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBcImhhbmdpbmdcIjtcbiAgICBjb250ZXh0LnRleHRBbGlnbiA9IHRoaXMuX29wdGlvbnMuYWxpZ25tZW50O1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fb3B0aW9ucy5jb2xvci50b1JHQkEoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgYWxsIGxpbmVzIGFuZCBzcGxpdCB0aGVtIGludG8gbXVsdGlwbGUgbGluZXMsIGRlcGVuZGluZ1xuICAgKiBvbiB0aGUgd2lkdGggdGhleSBuZWVkXG4gICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dDJkfSBjb250ZXh0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhXaWR0aFxuICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9idWlsZE91dHB1dExpbmVzIChjb250ZXh0LCBtYXhXaWR0aCkge1xuICAgIHZhciBpbnB1dExpbmVzID0gdGhpcy5fb3B0aW9ucy50ZXh0LnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBvdXRwdXRMaW5lcyA9IFtdO1xuICAgIHZhciBjdXJyZW50V29yZHMgPSBbXTtcblxuICAgIGZvciAodmFyIGxpbmVOdW0gPSAwOyBsaW5lTnVtIDwgaW5wdXRMaW5lcy5sZW5ndGg7IGxpbmVOdW0rKykge1xuICAgICAgdmFyIGlucHV0TGluZSA9IGlucHV0TGluZXNbbGluZU51bV07XG4gICAgICB2YXIgbGluZVdvcmRzID0gaW5wdXRMaW5lLnNwbGl0KFwiIFwiKTtcblxuICAgICAgZm9yICh2YXIgd29yZE51bSA9IDA7IHdvcmROdW0gPCBsaW5lV29yZHMubGVuZ3RoOyB3b3JkTnVtKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRXb3JkID0gbGluZVdvcmRzW3dvcmROdW1dO1xuICAgICAgICBjdXJyZW50V29yZHMucHVzaChjdXJyZW50V29yZCk7XG4gICAgICAgIHZhciBjdXJyZW50TGluZSA9IGN1cnJlbnRXb3Jkcy5qb2luKFwiIFwiKTtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQoY3VycmVudExpbmUpLndpZHRoO1xuXG4gICAgICAgIGlmIChsaW5lV2lkdGggPiBtYXhXaWR0aCAmJiBjdXJyZW50V29yZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgb3V0cHV0TGluZXMucHVzaChjdXJyZW50V29yZHNbMF0pO1xuICAgICAgICAgIGN1cnJlbnRXb3JkcyA9IFtdO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbmVXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBsYXN0IHdvcmRcbiAgICAgICAgICB2YXIgbGFzdFdvcmQgPSBjdXJyZW50V29yZHMucG9wKCk7XG5cbiAgICAgICAgICAvLyBBZGQgdGhlIGxpbmUsIGNsZWFyIHRoZSB3b3Jkc1xuICAgICAgICAgIG91dHB1dExpbmVzLnB1c2goY3VycmVudFdvcmRzLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICBjdXJyZW50V29yZHMgPSBbXTtcblxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byB1c2UgdGhlIGxhc3Qgd29yZCBmb3IgdGhlIG5leHQgbGluZVxuICAgICAgICAgIGN1cnJlbnRXb3JkcyA9IFtsYXN0V29yZF07XG4gICAgICAgIH0gZWxzZSBpZiAod29yZE51bSA9PT0gbGluZVdvcmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAvLyBBZGQgdGhlIGxpbmUsIGNsZWFyIHRoZSB3b3Jkc1xuICAgICAgICAgIG91dHB1dExpbmVzLnB1c2goY3VycmVudFdvcmRzLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICBjdXJyZW50V29yZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBMaW5lIGVuZGVkLCBidXQgdGhlcmUncyB3b3JkcyBsZWZ0XG4gICAgICBpZiAoY3VycmVudFdvcmRzLmxlbmd0aCkge1xuICAgICAgICBvdXRwdXRMaW5lcy5wdXNoKGN1cnJlbnRXb3Jkcy5qb2luKFwiIFwiKSk7XG4gICAgICAgIGN1cnJlbnRXb3JkcyA9IFtdO1xuICAgICAgfVxuXG4gICAgfVxuICAgIHJldHVybiBvdXRwdXRMaW5lcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3cyB0aGUgZ2l2ZW4gbGluZSBvbnRvIHRoZSBnaXZlbiBjb250ZXh0IGF0IHRoZSBnaXZlbiBZIHBvc2l0aW9uXG4gICAqIEBwYXJhbSAge1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHRcbiAgICogQHBhcmFtICB7TnVtYmVyfSB5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZHJhd1RleHQgKGNvbnRleHQsIHRleHQsIHkpIHtcbiAgICB2YXIgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuYWxpZ25tZW50ID09PSBcImNlbnRlclwiKSB7XG4gICAgICBjb250ZXh0LmZpbGxUZXh0KHRleHQsIGNhbnZhcy53aWR0aCAvIDIsIHkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5hbGlnbm1lbnQgPT09IFwibGVmdFwiKSB7XG4gICAgICBjb250ZXh0LmZpbGxUZXh0KHRleHQsIDAsIHkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5hbGlnbm1lbnQgPT09IFwicmlnaHRcIikge1xuICAgICAgY29udGV4dC5maWxsVGV4dCh0ZXh0LCBjYW52YXMud2lkdGgsIHkpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUZXh0T3BlcmF0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBPcGVyYXRpb24gZnJvbSBcIi4vb3BlcmF0aW9uXCI7XG5pbXBvcnQgVmVjdG9yMiBmcm9tIFwiLi4vbGliL21hdGgvdmVjdG9yMlwiO1xuaW1wb3J0IFN0YWNrQmx1ciBmcm9tIFwiLi4vdmVuZG9yL3N0YWNrLWJsdXJcIjtcblxuLyoqXG4gKiBBbiBvcGVyYXRpb24gdGhhdCBjYW4gY3JvcCBvdXQgYSBwYXJ0IG9mIHRoZSBpbWFnZVxuICpcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0Lk9wZXJhdGlvbnMuVGlsdFNoaWZ0T3BlcmF0aW9uXG4gKiBAZXh0ZW5kcyBJbWdseUtpdC5PcGVyYXRpb25cbiAqL1xuY2xhc3MgVGlsdFNoaWZ0T3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gICAgICBzdGFydDogeyB0eXBlOiBcInZlY3RvcjJcIiwgZGVmYXVsdDogbmV3IFZlY3RvcjIoMC4wLCAwLjUpIH0sXG4gICAgICBlbmQ6IHsgdHlwZTogXCJ2ZWN0b3IyXCIsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDEuMCwgMC41KSB9LFxuICAgICAgYmx1clJhZGl1czogeyB0eXBlOiBcIm51bWJlclwiLCBkZWZhdWx0OiAzMCB9LFxuICAgICAgZ3JhZGllbnRSYWRpdXM6IHsgdHlwZTogXCJudW1iZXJcIiwgZGVmYXVsdDogNTAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIHVzZWQgZm9yIHRoaXMgb3BlcmF0aW9uXG4gICAgICogQGludGVybmFsIEJhc2VkIG9uIGV2YW53J3MgZ2xmeC5qcyB0aWx0IHNoaWZ0IHNoYWRlcjpcbiAgICAgKiAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYmx1ci90aWx0c2hpZnQuanNcbiAgICAgKi9cbiAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gYFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xuICAgICAgdW5pZm9ybSBmbG9hdCBibHVyUmFkaXVzO1xuICAgICAgdW5pZm9ybSBmbG9hdCBncmFkaWVudFJhZGl1cztcbiAgICAgIHVuaWZvcm0gdmVjMiBzdGFydDtcbiAgICAgIHVuaWZvcm0gdmVjMiBlbmQ7XG4gICAgICB1bmlmb3JtIHZlYzIgZGVsdGE7XG4gICAgICB1bmlmb3JtIHZlYzIgdGV4U2l6ZTtcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xuXG4gICAgICBmbG9hdCByYW5kb20odmVjMyBzY2FsZSwgZmxvYXQgc2VlZCkge1xuICAgICAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChnbF9GcmFnQ29vcmQueHl6ICsgc2VlZCwgc2NhbGUpKSAqIDQzNzU4LjU0NTMgKyBzZWVkKTtcbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XG4gICAgICAgICAgZmxvYXQgdG90YWwgPSAwLjA7XG5cbiAgICAgICAgICBmbG9hdCBvZmZzZXQgPSByYW5kb20odmVjMygxMi45ODk4LCA3OC4yMzMsIDE1MS43MTgyKSwgMC4wKTtcblxuICAgICAgICAgIHZlYzIgbm9ybWFsID0gbm9ybWFsaXplKHZlYzIoc3RhcnQueSAtIGVuZC55LCBlbmQueCAtIHN0YXJ0LngpKTtcbiAgICAgICAgICBmbG9hdCByYWRpdXMgPSBzbW9vdGhzdGVwKDAuMCwgMS4wLCBhYnMoZG90KHZfdGV4Q29vcmQgKiB0ZXhTaXplIC0gc3RhcnQsIG5vcm1hbCkpIC8gZ3JhZGllbnRSYWRpdXMpICogYmx1clJhZGl1cztcbiAgICAgICAgICBmb3IgKGZsb2F0IHQgPSAtMzAuMDsgdCA8PSAzMC4wOyB0KyspIHtcbiAgICAgICAgICAgICAgZmxvYXQgcGVyY2VudCA9ICh0ICsgb2Zmc2V0IC0gMC41KSAvIDMwLjA7XG4gICAgICAgICAgICAgIGZsb2F0IHdlaWdodCA9IDEuMCAtIGFicyhwZXJjZW50KTtcbiAgICAgICAgICAgICAgdmVjNCBzYW1wbGUgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCArIGRlbHRhICogcGVyY2VudCAqIHJhZGl1cyAvIHRleFNpemUpO1xuXG4gICAgICAgICAgICAgIHNhbXBsZS5yZ2IgKj0gc2FtcGxlLmE7XG5cbiAgICAgICAgICAgICAgY29sb3IgKz0gc2FtcGxlICogd2VpZ2h0O1xuICAgICAgICAgICAgICB0b3RhbCArPSB3ZWlnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgLyB0b3RhbDtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IucmdiIC89IGdsX0ZyYWdDb2xvci5hICsgMC4wMDAwMTtcbiAgICAgIH1cbiAgICBgO1xuXG4gICAgc3VwZXIoLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAqIG9wZXJhdGlvbnMuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgaWRlbnRpZmllciAoKSB7XG4gICAgcmV0dXJuIFwidGlsdC1zaGlmdFwiO1xuICB9XG5cbiAgLyoqXG4gICAqIENyb3BzIHRoaXMgaW1hZ2UgdXNpbmcgV2ViR0xcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIF9yZW5kZXJXZWJHTCAocmVuZGVyZXIpIHtcbiAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG4gICAgdmFyIGNhbnZhc1NpemUgPSBuZXcgVmVjdG9yMihjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fb3B0aW9ucy5zdGFydC5jbG9uZSgpO1xuICAgIHZhciBlbmQgPSB0aGlzLl9vcHRpb25zLmVuZC5jbG9uZSgpO1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMubnVtYmVyRm9ybWF0ID09PSBcInJlbGF0aXZlXCIpIHtcbiAgICAgIHN0YXJ0Lm11bHRpcGx5KGNhbnZhc1NpemUpO1xuICAgICAgZW5kLm11bHRpcGx5KGNhbnZhc1NpemUpO1xuICAgIH1cblxuICAgIHN0YXJ0LnkgPSBjYW52YXNTaXplLnkgLSBzdGFydC55O1xuICAgIGVuZC55ID0gY2FudmFzU2l6ZS55IC0gZW5kLnk7XG5cbiAgICB2YXIgZGVsdGEgPSBlbmQuY2xvbmUoKS5zdWJ0cmFjdChzdGFydCk7XG4gICAgdmFyIGQgPSBNYXRoLnNxcnQoZGVsdGEueCAqIGRlbHRhLnggKyBkZWx0YS55ICogZGVsdGEueSk7XG5cbiAgICB2YXIgdW5pZm9ybXMgPSB7XG4gICAgICBibHVyUmFkaXVzOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogdGhpcy5fb3B0aW9ucy5ibHVyUmFkaXVzIH0sXG4gICAgICBncmFkaWVudFJhZGl1czogeyB0eXBlOiBcImZcIiwgdmFsdWU6IHRoaXMuX29wdGlvbnMuZ3JhZGllbnRSYWRpdXMgfSxcbiAgICAgIHN0YXJ0OiB7IHR5cGU6IFwiMmZcIiwgdmFsdWU6IFtzdGFydC54LCBzdGFydC55XSB9LFxuICAgICAgZW5kOiB7IHR5cGU6IFwiMmZcIiwgdmFsdWU6IFtlbmQueCwgZW5kLnldIH0sXG4gICAgICBkZWx0YTogeyB0eXBlOiBcIjJmXCIsIHZhbHVlOiBbZGVsdGEueCAvIGQsIGRlbHRhLnkgLyBkXSB9LFxuICAgICAgdGV4U2l6ZTogeyB0eXBlOiBcIjJmXCIsIHZhbHVlOiBbY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0XSB9XG4gICAgfTtcblxuICAgIHJlbmRlcmVyLnJ1blNoYWRlcihudWxsLCBUaWx0U2hpZnRPcGVyYXRpb24uZnJhZ21lbnRTaGFkZXIsIHtcbiAgICAgIHVuaWZvcm1zOiB1bmlmb3Jtc1xuICAgIH0pO1xuXG4gICAgdW5pZm9ybXMuZGVsdGEudmFsdWUgPSBbLWRlbHRhLnkgLyBkLCBkZWx0YS54IC8gZF07XG5cbiAgICByZW5kZXJlci5ydW5TaGFkZXIobnVsbCwgVGlsdFNoaWZ0T3BlcmF0aW9uLmZyYWdtZW50U2hhZGVyLCB7XG4gICAgICB1bmlmb3JtczogdW5pZm9ybXNcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcm9wcyB0aGUgaW1hZ2UgdXNpbmcgQ2FudmFzMkRcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqL1xuICBfcmVuZGVyQ2FudmFzIChyZW5kZXJlcikge1xuICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcblxuICAgIHZhciBibHVycnlDYW52YXMgPSB0aGlzLl9ibHVyQ2FudmFzKHJlbmRlcmVyKTtcbiAgICB2YXIgbWFza0NhbnZhcyA9IHRoaXMuX2NyZWF0ZU1hc2socmVuZGVyZXIpO1xuXG4gICAgdGhpcy5fYXBwbHlNYXNrKGNhbnZhcywgYmx1cnJ5Q2FudmFzLCBtYXNrQ2FudmFzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYmx1cnJlZCBjb3B5IG9mIHRoZSBjYW52YXNcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge0NhbnZhc31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ibHVyQ2FudmFzIChyZW5kZXJlcikge1xuICAgIHZhciBuZXdDYW52YXMgPSByZW5kZXJlci5jbG9uZUNhbnZhcygpO1xuICAgIHZhciBibHVycnlDb250ZXh0ID0gbmV3Q2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICB2YXIgYmx1cnJ5SW1hZ2VEYXRhID0gYmx1cnJ5Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgbmV3Q2FudmFzLndpZHRoLCBuZXdDYW52YXMuaGVpZ2h0KTtcbiAgICBTdGFja0JsdXIuc3RhY2tCbHVyQ2FudmFzUkdCQShibHVycnlJbWFnZURhdGEsIDAsIDAsIG5ld0NhbnZhcy53aWR0aCwgbmV3Q2FudmFzLmhlaWdodCwgdGhpcy5fb3B0aW9ucy5ibHVyUmFkaXVzKTtcbiAgICBibHVycnlDb250ZXh0LnB1dEltYWdlRGF0YShibHVycnlJbWFnZURhdGEsIDAsIDApO1xuXG4gICAgcmV0dXJuIG5ld0NhbnZhcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBtYXNrIGNhbnZhc1xuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7Q2FudmFzfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZU1hc2sgKHJlbmRlcmVyKSB7XG4gICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuXG4gICAgdmFyIGNhbnZhc1NpemUgPSBuZXcgVmVjdG9yMihjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIHZhciBncmFkaWVudFJhZGl1cyA9IHRoaXMuX29wdGlvbnMuZ3JhZGllbnRSYWRpdXM7XG5cbiAgICB2YXIgbWFza0NhbnZhcyA9IHJlbmRlcmVyLmNyZWF0ZUNhbnZhcyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIHZhciBtYXNrQ29udGV4dCA9IG1hc2tDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5fb3B0aW9ucy5zdGFydC5jbG9uZSgpO1xuICAgIHZhciBlbmQgPSB0aGlzLl9vcHRpb25zLmVuZC5jbG9uZSgpO1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMubnVtYmVyRm9ybWF0ID09PSBcInJlbGF0aXZlXCIpIHtcbiAgICAgIHN0YXJ0Lm11bHRpcGx5KGNhbnZhc1NpemUpO1xuICAgICAgZW5kLm11bHRpcGx5KGNhbnZhc1NpemUpO1xuICAgIH1cblxuICAgIHZhciByYWQgPSBNYXRoLmF0YW4oKGVuZC55IC0gc3RhcnQueSkgLyAoZW5kLnggLSBzdGFydC54KSk7XG5cbiAgICB2YXIgZ3JhZGllbnRTdGFydCA9IHN0YXJ0LmNsb25lKCk7XG4gICAgZ3JhZGllbnRTdGFydC54ICs9IE1hdGguc2luKHJhZCAqIE1hdGguUEkgLyAyKSAqIGdyYWRpZW50UmFkaXVzO1xuICAgIGdyYWRpZW50U3RhcnQueSAtPSBNYXRoLmNvcyhyYWQgKiBNYXRoLlBJIC8gMikgKiBncmFkaWVudFJhZGl1cztcblxuICAgIHZhciBncmFkaWVudEVuZCA9IHN0YXJ0LmNsb25lKCk7XG4gICAgZ3JhZGllbnRFbmQueCAtPSBNYXRoLnNpbihyYWQgKiBNYXRoLlBJIC8gMikgKiBncmFkaWVudFJhZGl1cztcbiAgICBncmFkaWVudEVuZC55ICs9IE1hdGguY29zKHJhZCAqIE1hdGguUEkgLyAyKSAqIGdyYWRpZW50UmFkaXVzO1xuXG4gICAgLy8gQnVpbGQgZ3JhZGllbnRcbiAgICB2YXIgZ3JhZGllbnQgPSBtYXNrQ29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChcbiAgICAgIGdyYWRpZW50U3RhcnQueCwgZ3JhZGllbnRTdGFydC55LFxuICAgICAgZ3JhZGllbnRFbmQueCwgICBncmFkaWVudEVuZC55XG4gICAgKTtcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgXCIjMDAwMDAwXCIpO1xuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLjUsIFwiI0ZGRkZGRlwiKTtcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgXCIjMDAwMDAwXCIpO1xuXG4gICAgLy8gRHJhdyBncmFkaWVudFxuICAgIG1hc2tDb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgIG1hc2tDb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICByZXR1cm4gbWFza0NhbnZhcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBibHVyIGFuZCBtYXNrIHRvIHRoZSBpbnB1dCBjYW52YXNcbiAgICogQHBhcmFtICB7Q2FudmFzfSBpbnB1dENhbnZhc1xuICAgKiBAcGFyYW0gIHtDYW52YXN9IGJsdXJyeUNhbnZhc1xuICAgKiBAcGFyYW0gIHtDYW52YXN9IG1hc2tDYW52YXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseU1hc2sgKGlucHV0Q2FudmFzLCBibHVycnlDYW52YXMsIG1hc2tDYW52YXMpIHtcbiAgICB2YXIgaW5wdXRDb250ZXh0ID0gaW5wdXRDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIHZhciBibHVycnlDb250ZXh0ID0gYmx1cnJ5Q2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICB2YXIgbWFza0NvbnRleHQgPSBtYXNrQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgIHZhciBpbnB1dEltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW5wdXRDYW52YXMud2lkdGgsIGlucHV0Q2FudmFzLmhlaWdodCk7XG4gICAgdmFyIHBpeGVscyA9IGlucHV0SW1hZ2VEYXRhLmRhdGE7XG4gICAgdmFyIGJsdXJyeVBpeGVscyA9IGJsdXJyeUNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGlucHV0Q2FudmFzLndpZHRoLCBpbnB1dENhbnZhcy5oZWlnaHQpLmRhdGE7XG4gICAgdmFyIG1hc2tQaXhlbHMgPSBtYXNrQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW5wdXRDYW52YXMud2lkdGgsIGlucHV0Q2FudmFzLmhlaWdodCkuZGF0YTtcblxuICAgIHZhciBpbmRleCwgYWxwaGE7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBpbnB1dENhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBpbnB1dENhbnZhcy53aWR0aDsgeCsrKSB7XG4gICAgICAgIGluZGV4ID0gKHkgKiBpbnB1dENhbnZhcy53aWR0aCArIHgpICogNDtcbiAgICAgICAgYWxwaGEgPSBtYXNrUGl4ZWxzW2luZGV4XSAvIDI1NTtcblxuICAgICAgICBwaXhlbHNbaW5kZXhdID0gYWxwaGEgKiBwaXhlbHNbaW5kZXhdICsgKDEgLSBhbHBoYSkgKiBibHVycnlQaXhlbHNbaW5kZXhdO1xuICAgICAgICBwaXhlbHNbaW5kZXggKyAxXSA9IGFscGhhICogcGl4ZWxzW2luZGV4ICsgMV0gKyAoMSAtIGFscGhhKSAqIGJsdXJyeVBpeGVsc1tpbmRleCArIDFdO1xuICAgICAgICBwaXhlbHNbaW5kZXggKyAyXSA9IGFscGhhICogcGl4ZWxzW2luZGV4ICsgMl0gKyAoMSAtIGFscGhhKSAqIGJsdXJyeVBpeGVsc1tpbmRleCArIDJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlucHV0Q29udGV4dC5wdXRJbWFnZURhdGEoaW5wdXRJbWFnZURhdGEsIDAsIDApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbHRTaGlmdE9wZXJhdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuaW1wb3J0IFJlbmRlcmVyIGZyb20gXCIuL3JlbmRlcmVyXCI7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuQ2FudmFzUmVuZGVyZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5SZW5kZXJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENhbnZhc1JlbmRlcmVyIGV4dGVuZHMgUmVuZGVyZXIge1xuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIHJlbmRlcmVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlkZW50aWZpZXIgKCkge1xuICAgIHJldHVybiBcImNhbnZhc1wiO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgdHlwZSBvZiByZW5kZXJlciBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnRcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzU3VwcG9ydGVkICgpIHtcbiAgICB2YXIgZWxlbSA9IHRoaXMucHJvdG90eXBlLmNyZWF0ZUNhbnZhcygpO1xuICAgIHJldHVybiAhIShlbGVtLmdldENvbnRleHQgJiYgZWxlbS5nZXRDb250ZXh0KFwiMmRcIikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZyb20gdGhlIENhbnZhXG4gICAqIEByZXR1cm4ge1JlbmRlcmluZ0NvbnRleHR9XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgX2dldENvbnRleHQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIH1cblxuICAvKipcbiAgICogRHJhd3MgdGhlIGdpdmVuIGltYWdlIG9uIHRoZSBjYW52YXNcbiAgICogQHBhcmFtICB7SW1hZ2V9IGltYWdlXG4gICAqL1xuICBkcmF3SW1hZ2UgKGltYWdlKSB7XG4gICAgdGhpcy5fY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIGN1cnJlbnQgY2FudmFzIHBpY3R1cmUgdG8gdGhlIGdpdmVuIGRpbWVuc2lvbnNcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gZGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVzaXplVG8gKGRpbWVuc2lvbnMpIHtcbiAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgY2FudmFzIHRvIGRyYXcgdG9cbiAgICB2YXIgbmV3Q2FudmFzID0gdGhpcy5jcmVhdGVDYW52YXMoKTtcbiAgICBuZXdDYW52YXMud2lkdGggPSBkaW1lbnNpb25zLng7XG4gICAgbmV3Q2FudmFzLmhlaWdodCA9IGRpbWVuc2lvbnMueTtcbiAgICB2YXIgbmV3Q29udGV4dCA9IG5ld0NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAvLyBEcmF3IHRoZSBzb3VyY2UgY2FudmFzIG9udG8gdGhlIG5ldyBvbmVcbiAgICBuZXdDb250ZXh0LmRyYXdJbWFnZSh0aGlzLl9jYW52YXMsXG4gICAgICAwLCAwLFxuICAgICAgdGhpcy5fY2FudmFzLndpZHRoLFxuICAgICAgdGhpcy5fY2FudmFzLmhlaWdodCxcbiAgICAgIDAsIDAsXG4gICAgICBuZXdDYW52YXMud2lkdGgsXG4gICAgICBuZXdDYW52YXMuaGVpZ2h0KTtcblxuICAgIC8vIFNldCB0aGUgbmV3IGNhbnZhcyBhbmQgY29udGV4dFxuICAgIHRoaXMuc2V0Q2FudmFzKG5ld0NhbnZhcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNsb25lZCB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IGNhbnZhc1xuICAgKiBAcmV0dXJuIHtDYW52YXN9XG4gICAqL1xuICBjbG9uZUNhbnZhcyAoKSB7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzKCk7XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgLy8gUmVzaXplIHRoZSBjYW52YXNcbiAgICBjYW52YXMud2lkdGggPSB0aGlzLl9jYW52YXMud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHRoaXMuX2NhbnZhcy5oZWlnaHQ7XG5cbiAgICAvLyBEcmF3IHRoZSBjdXJyZW50IGNhbnZhcyBvbiB0aGUgbmV3IG9uZVxuICAgIGNvbnRleHQuZHJhd0ltYWdlKHRoaXMuX2NhbnZhcywgMCwgMCk7XG5cbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1JlbmRlcmVyO1xuIiwiLypqc2hpbnQgdW51c2VkOmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IFZlY3RvcjIgZnJvbSBcIi4uL2xpYi9tYXRoL3ZlY3RvcjJcIjtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5SZW5kZXJlclxuICogQHBhcmFtIHtWZWN0b3IyfSBkaW1lbnNpb25zXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yIChkaW1lbnNpb25zKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0NhbnZhc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2NhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzKCk7XG5cbiAgICB0aGlzLnNldFNpemUoZGltZW5zaW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UmVuZGVyaW5nQ29udGV4dH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2NvbnRleHQgPSB0aGlzLl9nZXRDb250ZXh0KCk7XG4gIH1cblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIHJlbmRlcmVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgaWRlbnRpZmllciAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyB0eXBlIG9mIHJlbmRlcmVyIGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudFxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVuZGVyZXIjaXNTdXBwb3J0ZWQgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MuXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY2FudmFzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGhdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0XVxuICAgKiBAcmV0dXJuIHtDYW52YXN9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVDYW52YXMgKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICB2YXIgY2FudmFzO1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgQ2FudmFzID0gcmVxdWlyZShcImNhbnZhc1wiKTtcbiAgICAgIGNhbnZhcyA9IG5ldyBDYW52YXMoKTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSB3aWR0aFxuICAgIGlmICh0eXBlb2Ygd2lkdGggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IGhlaWdodFxuICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiBjYW52YXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBjYW52YXNcbiAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICovXG4gIGdldFNpemUgKCkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNhbnZhcyBkaW1lbnNpb25zXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gZGltZW5zaW9uc1xuICAgKi9cbiAgc2V0U2l6ZSAoZGltZW5zaW9ucykge1xuICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IGRpbWVuc2lvbnMueDtcbiAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gZGltZW5zaW9ucy55O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZyb20gdGhlIENhbnZhXG4gICAqIEByZXR1cm4ge1JlbmRlcmluZ0NvbnRleHR9XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgX2dldENvbnRleHQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVuZGVyZXIjX2dldENvbnRleHQgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MuXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIGN1cnJlbnQgY2FudmFzIHBpY3R1cmUgdG8gdGhlIGdpdmVuIGRpbWVuc2lvbnNcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gZGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIHJlc2l6ZVRvIChkaW1lbnNpb25zKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZW5kZXJlciNyZXNpemVUbyBpcyBhYnN0cmFjdCBhbmQgbm90IGltcGxlbWVudGVkIGluIGluaGVyaXRlZCBjbGFzcy5cIik7XG4gIH1cblxuICAvKipcbiAgICogRHJhd3MgdGhlIGdpdmVuIGltYWdlIG9uIHRoZSBjYW52YXNcbiAgICogQHBhcmFtICB7SW1hZ2V9IGltYWdlXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZHJhd0ltYWdlIChpbWFnZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVuZGVyZXIjZHJhd0ltYWdlIGlzIGFic3RyYWN0IGFuZCBub3QgaW1wbGVtZW50ZWQgaW4gaW5oZXJpdGVkIGNsYXNzLlwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhZnRlciB0aGUgc3RhY2sgaGFzIGJlZW4gcmVuZGVyZWRcbiAgICogQHBhcmFtICB7SW1hZ2V9IGltYWdlXG4gICAqL1xuICByZW5kZXJGaW5hbCAoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjYW52YXNcbiAgICogQHJldHVybiB7Q2FudmFzfVxuICAgKi9cbiAgZ2V0Q2FudmFzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbnRleHRcbiAgICogQHJldHVybiB7UmVuZGVyaW5nQ29udGV4dH1cbiAgICovXG4gIGdldENvbnRleHQgKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgY2FudmFzIHRvIHRoZSBnaXZlbiBvbmVcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKi9cbiAgc2V0Q2FudmFzIChjYW52YXMpIHtcbiAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5fY29udGV4dCA9IHRoaXMuX2dldENvbnRleHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IGNvbnRleHQgdG8gdGhlIGdpdmVuIG9uZVxuICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxuICAgKi9cbiAgc2V0Q29udGV4dCAoY29udGV4dCkge1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlcmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBSZW5kZXJlciBmcm9tIFwiLi9yZW5kZXJlclwiO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LldlYkdMUmVuZGVyZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5SZW5kZXJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFdlYkdMUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICB0aGlzLl9kZWZhdWx0UHJvZ3JhbSA9IHRoaXMuc2V0dXBHTFNMUHJvZ3JhbSgpO1xuICAgIHRoaXMuX2xhc3RUZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLl90ZXh0dXJlcyA9IFtdO1xuICAgIHRoaXMuX2ZyYW1lYnVmZmVycyA9IFtdO1xuICAgIHRoaXMuX2J1ZmZlckluZGV4ID0gMDtcbiAgICB0aGlzLl9pbnB1dFRleHR1cmUgPSBudWxsO1xuXG4gICAgdGhpcy5fY3JlYXRlRnJhbWVidWZmZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIHJlbmRlcmVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgaWRlbnRpZmllciAoKSB7XG4gICAgcmV0dXJuIFwid2ViZ2xcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCB2ZXJ0ZXggc2hhZGVyIHdoaWNoIGp1c3QgcGFzc2VzIHRoZSB0ZXhDb29yZCB0byB0aGVcbiAgICogZnJhZ21lbnQgc2hhZGVyLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IGRlZmF1bHRWZXJ0ZXhTaGFkZXIgKCkge1xuICAgIHZhciBzaGFkZXIgPSBgXG4gICAgICBhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xuICAgICAgYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhX3Bvc2l0aW9uLCAwLCAxKTtcbiAgICAgICAgdl90ZXhDb29yZCA9IGFfdGV4Q29vcmQ7XG4gICAgICB9XG4gICAgYDtcbiAgICByZXR1cm4gc2hhZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGZyYWdtZW50IHNoYWRlciB3aGljaCB3aWxsIGp1c3QgbG9vayB1cCB0aGUgY29sb3JzIGZyb20gdGhlXG4gICAqIHRleHR1cmUuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgZGVmYXVsdEZyYWdtZW50U2hhZGVyICgpIHtcbiAgICB2YXIgc2hhZGVyID0gYFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xuICAgICAgfVxuICAgIGA7XG4gICAgcmV0dXJuIHNoYWRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIHR5cGUgb2YgcmVuZGVyZXIgaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50XG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1N1cHBvcnRlZCAoKSB7XG4gICAgcmV0dXJuICEhKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LldlYkdMUmVuZGVyaW5nQ29udGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcmVuZGVyaW5nIGNvbnRleHQgZnJvbSB0aGUgQ2FudmFzXG4gICAqIEByZXR1cm4ge1JlbmRlcmluZ0NvbnRleHR9XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgX2dldENvbnRleHQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIikgfHxcbiAgICAgIHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2wtZXhwZXJpbWVudGFsXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYXdzIHRoZSBnaXZlbiBpbWFnZSBvbiB0aGUgY2FudmFzXG4gICAqIEBwYXJhbSAge0ltYWdlfSBpbWFnZVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZHJhd0ltYWdlIChpbWFnZSkge1xuICAgIHZhciBnbCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgZ2wudXNlUHJvZ3JhbSh0aGlzLl9kZWZhdWx0UHJvZ3JhbSk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIHRleHR1cmVcbiAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuICAgIHRoaXMuX2lucHV0VGV4dHVyZSA9IHRleHR1cmU7XG4gICAgdGhpcy5zZXRMYXN0VGV4dHVyZSh0ZXh0dXJlKTtcblxuICAgIC8vIFVwbG9hZCB0aGUgaW1hZ2UgaW50byB0aGUgdGV4dHVyZVxuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xuXG4gICAgLy8gRHJhdyB0aGUgcmVjdGFuZ2xlXG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgdGhlIGdpdmVuIHNoYWRlclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFt2ZXJ0ZXhTaGFkZXJdXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW2ZyYWdtZW50U2hhZGVyXVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcnVuU2hhZGVyICh2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zID0ge307XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnVuaWZvcm1zID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnVuaWZvcm1zID0ge307XG5cbiAgICB2YXIgZ2wgPSB0aGlzLl9jb250ZXh0O1xuICAgIHZhciBwcm9ncmFtID0gdGhpcy5zZXR1cEdMU0xQcm9ncmFtKHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpO1xuICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICB2YXIgZmJvID0gdGhpcy5nZXRDdXJyZW50RnJhbWVidWZmZXIoKTtcbiAgICB2YXIgdGV4dHVyZSA9IHRoaXMuZ2V0Q3VycmVudFRleHR1cmUoKTtcblxuICAgIC8vIFNlbGVjdCB0aGUgY3VycmVudCBmcmFtZWJ1ZmZlclxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmJvKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHdlIHNlbGVjdCB0aGUgY3VycmVudCB0ZXh0dXJlXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fbGFzdFRleHR1cmUpO1xuXG4gICAgLy8gU2V0IHRoZSB1bmlmb3Jtc1xuICAgIGZvciAodmFyIG5hbWUgaW4gb3B0aW9ucy51bmlmb3Jtcykge1xuICAgICAgdmFyIGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIG5hbWUpO1xuICAgICAgdmFyIHVuaWZvcm0gPSBvcHRpb25zLnVuaWZvcm1zW25hbWVdO1xuXG4gICAgICBzd2l0Y2ggKHVuaWZvcm0udHlwZSkge1xuICAgICAgICBjYXNlIFwiaVwiOlxuICAgICAgICBjYXNlIFwiMWlcIjpcbiAgICAgICAgICBnbC51bmlmb3JtMWkobG9jYXRpb24sIHVuaWZvcm0udmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICBjYXNlIFwiMWZcIjpcbiAgICAgICAgICBnbC51bmlmb3JtMWYobG9jYXRpb24sIHVuaWZvcm0udmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiMmZcIjpcbiAgICAgICAgICBnbC51bmlmb3JtMmYobG9jYXRpb24sIHVuaWZvcm0udmFsdWVbMF0sIHVuaWZvcm0udmFsdWVbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiM2ZcIjpcbiAgICAgICAgICBnbC51bmlmb3JtM2YobG9jYXRpb24sIHVuaWZvcm0udmFsdWVbMF0sIHVuaWZvcm0udmFsdWVbMV0sIHVuaWZvcm0udmFsdWVbMl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiNGZcIjpcbiAgICAgICAgICBnbC51bmlmb3JtNGYobG9jYXRpb24sIHVuaWZvcm0udmFsdWVbMF0sIHVuaWZvcm0udmFsdWVbMV0sIHVuaWZvcm0udmFsdWVbMl0sIHVuaWZvcm0udmFsdWVbM10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiMmZ2XCI6XG4gICAgICAgICAgZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgdW5pZm9ybS52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXQzZnZcIjpcbiAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdW5pZm9ybS52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB1bmlmb3JtIHR5cGU6IFwiICsgdW5pZm9ybS50eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEcmF3IHRoZSByZWN0YW5nbGVcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgNik7XG5cbiAgICB0aGlzLnNldExhc3RUZXh0dXJlKHRleHR1cmUpO1xuICAgIHRoaXMuc2VsZWN0TmV4dEJ1ZmZlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYXdzIHRoZSBsYXN0IHVzZWQgYnVmZmVyIG9udG8gdGhlIGNhbnZhc1xuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmVuZGVyRmluYWwgKCkge1xuICAgIHZhciBnbCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgdmFyIHByb2dyYW0gPSB0aGlzLl9kZWZhdWx0UHJvZ3JhbTtcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgLy8gRG9uJ3QgZHJhdyB0byBmcmFtZWJ1ZmZlclxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIHZpZXdwb3J0IHNpemUgaXMgY29ycmVjdFxuICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XG5cbiAgICAvLyBTZWxlY3QgdGhlIGxhc3QgdGV4dHVyZSB0aGF0IGhhcyBiZWVuIHJlbmRlcmVkIHRvXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fbGFzdFRleHR1cmUpO1xuXG4gICAgLy8gRHJhdyB0aGUgcmVjdGFuZ2xlXG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgYSBHTFNMIHByb2dyYW0uIFVzZXMgdGhlIGRlZmF1bHQgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJcbiAgICogaWYgbm9uZSBhcmUgZ2l2ZW4uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmVydGV4U2hhZGVyXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2ZyYWdtZW50U2hhZGVyXVxuICAgKiBAcmV0dXJuIHtXZWJHTFByb2dyYW19XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBzZXR1cEdMU0xQcm9ncmFtICh2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKSB7XG4gICAgdmFyIGdsID0gdGhpcy5fY29udGV4dDtcbiAgICB2YXIgc2hhZGVycyA9IFtdO1xuXG4gICAgLy8gVXNlIGRlZmF1bHQgdmVydGV4IHNoYWRlclxuICAgIHZlcnRleFNoYWRlciA9IHRoaXMuX2NyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTaGFkZXIgfHwgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZGVmYXVsdFZlcnRleFNoYWRlcik7XG4gICAgc2hhZGVycy5wdXNoKHZlcnRleFNoYWRlcik7XG5cbiAgICAvLyBVc2UgZGVmYXVsdCBmcmFnbWVudCBzaGFkZXJcbiAgICBmcmFnbWVudFNoYWRlciA9IHRoaXMuX2NyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U2hhZGVyIHx8IFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLmRlZmF1bHRGcmFnbWVudFNoYWRlcik7XG4gICAgc2hhZGVycy5wdXNoKGZyYWdtZW50U2hhZGVyKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgcHJvZ3JhbVxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgLy8gQXR0YWNoIHRoZSBzaGFkZXJzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgc2hhZGVyc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gTGluayB0aGUgcHJvZ3JhbVxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgLy8gQ2hlY2sgbGlua2luZyBzdGF0dXNcbiAgICB2YXIgbGlua2VkID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyk7XG4gICAgaWYgKCFsaW5rZWQpIHtcbiAgICAgIHZhciBsYXN0RXJyb3IgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcbiAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBwcm9ncmFtIGxpbmtpbmcgZXJyb3I6IFwiICsgbGFzdEVycm9yKTtcbiAgICB9XG5cbiAgICAvLyBMb29rdXAgdGV4dHVyZSBjb29yZGluYXRlcyBsb2NhdGlvblxuICAgIHZhciBwb3NpdGlvbkxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX3Bvc2l0aW9uXCIpO1xuICAgIHZhciB0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX3RleENvb3JkXCIpO1xuXG4gICAgLy8gUHJvdmlkZSB0ZXh0dXJlIGNvb3JkaW5hdGVzXG4gICAgdmFyIHRleENvb3JkQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRleENvb3JkQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAvLyBGaXJzdCB0cmlhbmdsZVxuICAgICAgMC4wLCAwLjAsXG4gICAgICAxLjAsIDAuMCxcbiAgICAgIDAuMCwgMS4wLFxuXG4gICAgICAvLyBTZWNvbmQgdHJpYW5nbGVcbiAgICAgIDAuMCwgMS4wLFxuICAgICAgMS4wLCAwLjAsXG4gICAgICAxLjAsIDEuMFxuICAgIF0pLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGV4Q29vcmRMb2NhdGlvbik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0ZXhDb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG4gICAgLy8gQ3JlYXRlIGEgYnVmZmVyIGZvciB0aGUgcmVjdGFuZ2xlIHBvc2l0aW9uc1xuICAgIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgLy8gRmlyc3QgdHJpYW5nbGVcbiAgICAgIC0xLjAsIC0xLjAsXG4gICAgICAgMS4wLCAtMS4wLFxuICAgICAgLTEuMCwgIDEuMCxcblxuICAgICAgLy8gU2Vjb25kIHRyaWFuZ2xlXG4gICAgICAtMS4wLCAgMS4wLFxuICAgICAgIDEuMCwgLTEuMCxcbiAgICAgICAxLjAsICAxLjBcbiAgICBdKSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgcmV0dXJuIHByb2dyYW07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFdlYkdMIHNoYWRlciB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBzb3VyY2UgY29kZVxuICAgKiBAcGFyYW0gIHtXZWJHTFNoYWRlclR5cGV9IHNoYWRlclR5cGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzaGFkZXJTb3VyY2VcbiAgICogQHJldHVybiB7V2ViR0xTaGFkZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBfY3JlYXRlU2hhZGVyIChzaGFkZXJUeXBlLCBzaGFkZXJTb3VyY2UpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBzaGFkZXIgYW5kIGNvbXBpbGUgaXRcbiAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gICAgLy8gQ2hlY2sgY29tcGlsYXRpb24gc3RhdHVzXG4gICAgdmFyIGNvbXBpbGVkID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xuICAgIGlmICghY29tcGlsZWQpIHtcbiAgICAgIHZhciBsYXN0RXJyb3IgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYkdMIHNoYWRlciBjb21waWxhdGlvbiBlcnJvcjogXCIgKyBsYXN0RXJyb3IpO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXI7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBlbXB0eSB0ZXh0dXJlXG4gICAqIEByZXR1cm4ge1dlYkdMVGV4dHVyZX1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGNyZWF0ZVRleHR1cmUgKCkge1xuICAgIHZhciBnbCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHR3byB0ZXh0dXJlcyBhbmQgZnJhbWVidWZmZXJzIHRoYXQgYXJlIHVzZWQgZm9yIHRoZSBzdGFja1xuICAgKiByZW5kZXJpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIF9jcmVhdGVGcmFtZWJ1ZmZlcnMgKCkge1xuICAgIHZhciBnbCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAvLyBDcmVhdGUgdGV4dHVyZVxuICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIHRoaXMuX3RleHR1cmVzLnB1c2godGV4dHVyZSk7XG5cbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcblxuICAgICAgLy8gQ3JlYXRlIGZyYW1lYnVmZmVyXG4gICAgICB2YXIgZmJvID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgIHRoaXMuX2ZyYW1lYnVmZmVycy5wdXNoKGZibyk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZibyk7XG5cbiAgICAgIC8vIEF0dGFjaCB0aGUgdGV4dHVyZVxuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzaXplcyB0aGUgY3VycmVudCBjYW52YXMgcGljdHVyZSB0byB0aGUgZ2l2ZW4gZGltZW5zaW9uc1xuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBkaW1lbnNpb25zXG4gICAqIEB0b2RvIFVzZSBhIGRvd25zYW1wbGluZyBzaGFkZXIgZm9yIHNtb290aGVyIGltYWdlIHJlc2l6aW5nXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXNpemVUbyAoZGltZW5zaW9ucykge1xuICAgIHZhciBnbCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICAvLyBSZXNpemUgdGhlIGNhbnZhc1xuICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IGRpbWVuc2lvbnMueDtcbiAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gZGltZW5zaW9ucy55O1xuXG4gICAgLy8gVXBkYXRlIHRoZSB2aWV3cG9ydCBkaW1lbnNpb25zXG4gICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcblxuICAgIC8vIERyYXcgdGhlIHJlY3RhbmdsZVxuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGZyYW1lYnVmZmVyXG4gICAqIEByZXR1cm4ge1dlYkdMRnJhbWVidWZmZXJ9XG4gICAqL1xuICBnZXRDdXJyZW50RnJhbWVidWZmZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9mcmFtZWJ1ZmZlcnNbdGhpcy5fYnVmZmVySW5kZXggJSAyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRleHR1cmVcbiAgICogQHJldHVybiB7V2ViR0xUZXh0dXJlfVxuICAgKi9cbiAgZ2V0Q3VycmVudFRleHR1cmUgKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0dXJlc1t0aGlzLl9idWZmZXJJbmRleCAlIDJdO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlcyB0aGUgYnVmZmVyIGluZGV4XG4gICAqL1xuICBzZWxlY3ROZXh0QnVmZmVyICgpIHtcbiAgICB0aGlzLl9idWZmZXJJbmRleCsrO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlZmF1bHQgcHJvZ3JhbVxuICAgKiBAcmV0dXJuIHtXZWJHTFByb2dyYW19XG4gICAqL1xuICBnZXREZWZhdWx0UHJvZ3JhbSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRQcm9ncmFtO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgdGV4dHVyZSB0aGF0IGhhcyBiZWVuIGRyYXduIHRvXG4gICAqIEByZXR1cm4ge1dlYkdMVGV4dHVyZX1cbiAgICovXG4gIGdldExhc3RUZXh0dXJlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGFzdFRleHR1cmU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdGV4dHVyZXNcbiAgICogQHJldHVybiB7QXJyYXkuPFdlYkdMVGV4dHVyZT59XG4gICAqL1xuICBnZXRUZXh0dXJlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxhc3QgdGV4dHVyZVxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4dHVyZVxuICAgKi9cbiAgc2V0TGFzdFRleHR1cmUgKHRleHR1cmUpIHtcbiAgICB0aGlzLl9sYXN0VGV4dHVyZSA9IHRleHR1cmU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgV2ViR0xSZW5kZXJlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5jbGFzcyBIZWxwZXJzIHtcbiAgY29uc3RydWN0b3IgKGtpdCwgdWksIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9raXQgPSBraXQ7XG4gICAgdGhpcy5fdWkgPSB1aTtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGFzc2V0UGF0aCAoYXNzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5hc3NldHNVcmwgKyBcIi9cIiArIGFzc2V0O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEhlbHBlcnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cbmltcG9ydCBkb3QgZnJvbSBcImRvdFwiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi8uLi9saWIvdXRpbHNcIjtcbmltcG9ydCBIZWxwZXJzIGZyb20gXCIuL2hlbHBlcnNcIjtcblxuY2xhc3MgQmFzZVVJIHtcbiAgY29uc3RydWN0b3IgKGtpdCwgb3B0aW9ucykge1xuICAgIHRoaXMuX2tpdCA9IGtpdDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9vcGVyYXRpb25zID0gW107XG4gICAgdGhpcy5fY29udHJvbHMgPSBbXTtcbiAgICB0aGlzLl9oZWxwZXJzID0gbmV3IEhlbHBlcnModGhpcy5raXQsIHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuc2VsZWN0T3BlcmF0aW9ucyhudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlcyB0aGUgVUkgZm9yIHVzZVxuICAgKi9cbiAgcnVuICgpIHtcbiAgICB0aGlzLl9hdHRhY2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGFuZCBhdHRhY2hlcyB0aGUgVUkgSFRNTFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2F0dGFjaCAoKSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYXNlVUkjYXR0YWNoOiBObyBjb250YWluZXIgc2V0LlwiKTtcbiAgICB9XG5cbiAgICBsZXQgaHRtbCA9IHRoaXMuX3JlbmRlcigpO1xuICAgIHRoaXMuX29wdGlvbnMuY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAvLyBDb250YWluZXIgaGFzIHRvIGJlIHBvc2l0aW9uOiByZWxhdGl2ZVxuICAgIHRoaXMuX29wdGlvbnMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHRlbXBsYXRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX3RlbXBsYXRlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYXNlVUkjX3JlbmRlcjogTm8gdGVtcGxhdGUgc2V0LlwiKTtcbiAgICB9XG5cbiAgICBsZXQgcmVuZGVyRm4gPSBkb3QudGVtcGxhdGUodGhpcy5fdGVtcGxhdGUpO1xuICAgIHJldHVybiByZW5kZXJGbih0aGlzLmNvbnRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgdGhlIGVuYWJsZWQgb3BlcmF0aW9uc1xuICAgKiBAcGFyYW0ge0ltZ2x5S2l0LlNlbGVjdG9yfVxuICAgKi9cbiAgc2VsZWN0T3BlcmF0aW9ucyAoc2VsZWN0b3IpIHtcbiAgICBsZXQgeyByZWdpc3RlcmVkT3BlcmF0aW9ucyB9ID0gdGhpcy5fa2l0O1xuICAgIGxldCBvcGVyYXRpb25JZGVudGlmaWVycyA9IE9iamVjdC5rZXlzKHJlZ2lzdGVyZWRPcGVyYXRpb25zKTtcblxuICAgIGxldCBzZWxlY3RlZE9wZXJhdGlvbnMgPSBVdGlscy5zZWxlY3Qob3BlcmF0aW9uSWRlbnRpZmllcnMsIHNlbGVjdG9yKTtcbiAgICB0aGlzLl9vcGVyYXRpb25zID0gc2VsZWN0ZWRPcGVyYXRpb25zLm1hcCgoaWRlbnRpZmllcikgPT4ge1xuICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRPcGVyYXRpb25zW2lkZW50aWZpZXJdO1xuICAgIH0pO1xuICB9XG5cbiAgaXNPcGVyYXRpb25TZWxlY3RlZCAoaWRlbnRpZmllcikge1xuICAgIGxldCBvcGVyYXRpb25JZGVudGlmaWVycyA9IHRoaXMuX29wZXJhdGlvbnMubWFwKChvcGVyYXRpb24pID0+IHtcbiAgICAgIHJldHVybiBvcGVyYXRpb24ucHJvdG90eXBlLmlkZW50aWZpZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9wZXJhdGlvbklkZW50aWZpZXJzLmluZGV4T2YoaWRlbnRpZmllcikgIT09IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkYXRhIHRoYXQgaXMgcGFzc2VkIHRvIHRoZSB0ZW1wbGF0ZSByZW5kZXJlclxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0IGNvbnRleHQgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVyYXRpb25zOiB0aGlzLl9vcGVyYXRpb25zLFxuICAgICAgaGVscGVyczogdGhpcy5faGVscGVyc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIERPTSBjb250YWluZXJcbiAgICogQHR5cGUge0RPTUVsZW1lbnR9XG4gICAqL1xuICBnZXQgY29udGFpbmVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5jb250YWluZXI7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHNlbGVjdGVkIC8gYWN0aXZlIG9wZXJhdGlvbnNcbiAgICogQHR5cGUge0FycmF5LjxJbWdseUtpdC5PcGVyYXRpb24+fVxuICAgKi9cbiAgZ2V0IG9wZXJhdGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcGVyYXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBvcHRpb25zXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXQgb3B0aW9ucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVVJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBkb3QgZnJvbSBcImRvdFwiO1xuaW1wb3J0IEhlbHBlcnMgZnJvbSBcIi4uLy4uL2Jhc2UvaGVscGVyc1wiO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiLi4vLi4vLi4vbGliL2V2ZW50LWVtaXR0ZXJcIjtcblxuY2xhc3MgQ29udHJvbCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChraXQsIHVpLCBvcGVyYXRpb24sIGNvbnRyb2xzQ29udGFpbmVyLCBjYW52YXNDb250cm9sc0NvbnRhaW5lcikge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9raXQgPSBraXQ7XG4gICAgdGhpcy5fdWkgPSB1aTtcbiAgICB0aGlzLl9vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgdGhpcy5fY29udHJvbHNDb250YWluZXIgPSBjb250cm9sc0NvbnRhaW5lcjtcbiAgICB0aGlzLl9jYW52YXNDb250cm9sc0NvbnRhaW5lciA9IGNhbnZhc0NvbnRyb2xzQ29udGFpbmVyO1xuICAgIHRoaXMuX2hlbHBlcnMgPSBuZXcgSGVscGVycyh0aGlzLl9raXQsIHRoaXMuX3VpLCB0aGlzLl91aS5vcHRpb25zKTtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBlbnRyeSBwb2ludCBmb3IgdGhpcyBjb250cm9sXG4gICAqL1xuICBpbml0ICgpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGNvbnRyb2xzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyQWxsQ29udHJvbHMgKCkge1xuICAgIHRoaXMuX3JlbmRlckNvbnRyb2xzKCk7XG4gICAgdGhpcy5fcmVuZGVyQ2FudmFzQ29udHJvbHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250cm9sc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckNvbnRyb2xzICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2NvbnRyb2xzVGVtcGxhdGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRyb2wjX3JlbmRlck92ZXJ2aWV3Q29udHJvbHM6IENvbnRyb2wgbmVlZHMgdG8gZGVmaW5lIHRoaXMuX2NvbnRyb2xzVGVtcGxhdGUuXCIpO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciB0aGUgdGVtcGxhdGVcbiAgICBsZXQgcmVuZGVyRm4gPSBkb3QudGVtcGxhdGUodGhpcy5fY29udHJvbHNUZW1wbGF0ZSk7XG4gICAgbGV0IGh0bWwgPSByZW5kZXJGbih0aGlzLmNvbnRleHQpO1xuXG4gICAgLy8gQ3JlYXRlIGEgd3JhcHBlclxuICAgIHRoaXMuX2NvbnRyb2xzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLl9jb250cm9scy5pbm5lckhUTUwgPSBodG1sO1xuXG4gICAgLy8gQXBwZW5kIHRvIERPTVxuICAgIHRoaXMuX2NvbnRyb2xzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRyb2xzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjYW52YXMgY29udHJvbHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJDYW52YXNDb250cm9scyAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9jYW52YXNDb250cm9sc1RlbXBsYXRlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm47IC8vIENhbnZhcyBjb250cm9scyBhcmUgb3B0aW9uYWxcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgdGhlIHRlbXBsYXRlXG4gICAgbGV0IHJlbmRlckZuID0gZG90LnRlbXBsYXRlKHRoaXMuX2NhbnZhc0NvbnRyb2xzVGVtcGxhdGUpO1xuICAgIGxldCBodG1sID0gcmVuZGVyRm4odGhpcy5jb250ZXh0KTtcblxuICAgIC8vIENyZWF0ZSBhIHdyYXBwZXJcbiAgICB0aGlzLl9jYW52YXNDb250cm9scyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5fY2FudmFzQ29udHJvbHMuaW5uZXJIVE1MID0gaHRtbDtcblxuICAgIC8vIEFwcGVuZCB0byBET01cbiAgICB0aGlzLl9jYW52YXNDb250cm9sc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXNDb250cm9scyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgY29udHJvbHMgZnJvbSB0aGUgRE9NXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVtb3ZlQ29udHJvbHMgKCkge1xuICAgIHRoaXMuX2NvbnRyb2xzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY29udHJvbHMpO1xuICAgIGlmICh0aGlzLl9jYW52YXNDb250cm9scykge1xuICAgICAgdGhpcy5fY2FudmFzQ29udHJvbHMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9jYW52YXNDb250cm9scyk7XG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUJhY2tBbmREb25lQnV0dG9ucyAoKSB7XG4gICAgLy8gQmFjayBidXR0b25cbiAgICBsZXQgYmFja0J1dHRvbiA9IHRoaXMuX2NvbnRyb2xzLnF1ZXJ5U2VsZWN0b3IoXCIuaW1nbHlraXQtY29udHJvbHMtYmFja1wiKTtcbiAgICBiYWNrQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9vbkJhY2tCdXR0b25DbGljay5iaW5kKHRoaXMpKTtcblxuICAgIC8vIERvbmUgYnV0dG9uXG4gICAgbGV0IGRvbmVCdXR0b24gPSB0aGlzLl9jb250cm9scy5xdWVyeVNlbGVjdG9yKFwiLmltZ2x5a2l0LWNvbnRyb2xzLWRvbmVcIik7XG4gICAgZG9uZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fb25Eb25lQnV0dG9uQ2xpY2suYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgYmFjayBidXR0b24gaGFzIGJlZW4gY2xpY2tlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQmFja0J1dHRvbkNsaWNrICgpIHtcbiAgICB0aGlzLl9vbkJhY2soKTtcbiAgICB0aGlzLmVtaXQoXCJiYWNrXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGRvbmUgYnV0dG9uIGhhcyBiZWVuIGNsaWNrZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkRvbmVCdXR0b25DbGljayAoKSB7XG4gICAgdGhpcy5fb25Eb25lKCk7XG4gICAgdGhpcy5lbWl0KFwiYmFja1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29udHJvbCBpcyBhY3RpdmF0ZWRcbiAgICogQGludGVybmFsIFVzZWQgYnkgdGhlIFNESywgZG9uJ3Qgb3ZlcnJpZGUuXG4gICAqL1xuICBlbnRlciAoKSB7XG4gICAgdGhpcy5fcmVuZGVyQWxsQ29udHJvbHMoKTtcbiAgICB0aGlzLl9oYW5kbGVCYWNrQW5kRG9uZUJ1dHRvbnMoKTtcbiAgICB0aGlzLl9vbkVudGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbnRyb2wgaXMgZGVhY3RpdmF0ZWRcbiAgICogQGludGVybmFsIFVzZWQgYnkgdGhlIFNESywgZG9uJ3Qgb3ZlcnJpZGUuXG4gICAqL1xuICBsZWF2ZSAoKSB7XG4gICAgdGhpcy5fcmVtb3ZlQ29udHJvbHMoKTtcbiAgICB0aGlzLl9vbkxlYXZlKCk7XG4gIH1cblxuICAvLyBQcm90ZWN0ZWQgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29udHJvbCBpcyBhY3RpdmF0ZWQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9vbkVudGVyICgpIHt9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb250cm9sIGlzIGRlYWN0aXZhdGVkXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9vbkxlYXZlICgpIHt9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGJhY2sgYnV0dG9uIGhhcyBiZWVuIGNsaWNrZWRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX29uQmFjayAoKSB7fVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBkb25lIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9vbkRvbmUgKCkge31cblxuICAvKipcbiAgICogVGhlIGRhdGEgdGhhdCBpcyBhdmFpbGFibGUgdG8gdGhlIHRlbXBsYXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXQgY29udGV4dCAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlbHBlcnM6IHRoaXMuX2hlbHBlcnNcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRyb2w7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuaW1wb3J0IENvbnRyb2wgZnJvbSBcIi4vY29udHJvbFwiO1xubGV0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuXG5jbGFzcyBGaWx0ZXJzQ29udHJvbHMgZXh0ZW5kcyBDb250cm9sIHtcbiAgLyoqXG4gICAqIEVudHJ5IHBvaW50IGZvciB0aGlzIGNvbnRyb2xcbiAgICovXG4gIGluaXQgKCkge1xuICAgIGxldCBjYW52YXNUZW1wbGF0ZSA9IGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyBcIi8uLi8uLi8uLi90ZW1wbGF0ZXMvbmlnaHQvb3BlcmF0aW9ucy9maWx0ZXJzX2NhbnZhcy5qc3RcIiwgXCJ1dGYtOFwiKTtcbiAgICB0aGlzLl9jYW52YXNDb250cm9sc1RlbXBsYXRlID0gY2FudmFzVGVtcGxhdGU7XG5cbiAgICBsZXQgY29udHJvbHNUZW1wbGF0ZSA9IGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyBcIi8uLi8uLi8uLi90ZW1wbGF0ZXMvbmlnaHQvb3BlcmF0aW9ucy9maWx0ZXJzX2NvbnRyb2xzLmpzdFwiLCBcInV0Zi04XCIpO1xuICAgIHRoaXMuX2NvbnRyb2xzVGVtcGxhdGUgPSBjb250cm9sc1RlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb250cm9sIGlzIGFjdGl2YXRlZFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF9vbkVudGVyICgpIHtcbiAgICB0aGlzLl9pbml0aWFsRmlsdGVyID0gdGhpcy5fb3BlcmF0aW9uLmdldEZpbHRlcigpO1xuXG4gICAgbGV0IGxpc3RJdGVtcyA9IHRoaXMuX2NvbnRyb2xzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaVwiKTtcbiAgICB0aGlzLl9saXN0SXRlbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0SXRlbXMpO1xuXG4gICAgLy8gTGlzdGVuIHRvIGNsaWNrIGV2ZW50c1xuICAgIGZvciAobGV0IGxpc3RJdGVtIG9mIHRoaXMuX2xpc3RJdGVtcykge1xuICAgICAgbGlzdEl0ZW0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5fb25MaXN0SXRlbUNsaWNrKGxpc3RJdGVtKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEJhY2sgYnV0dG9uXG4gICAgbGV0IGJhY2tCdXR0b24gPSB0aGlzLl9jb250cm9scy5xdWVyeVNlbGVjdG9yKFwiLmltZ2x5a2l0LWNvbnRyb2xzLWJhY2tcIik7XG4gICAgYmFja0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fb25CYWNrQnV0dG9uQ2xpY2suYmluZCh0aGlzKSk7XG5cbiAgICAvLyBEb25lIGJ1dHRvblxuICAgIGxldCBkb25lQnV0dG9uID0gdGhpcy5fY29udHJvbHMucXVlcnlTZWxlY3RvcihcIi5pbWdseWtpdC1jb250cm9scy1kb25lXCIpO1xuICAgIGRvbmVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29uRG9uZUJ1dHRvbkNsaWNrLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgaGl0cyB0aGUgYmFjayBidXR0b25cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBfb25CYWNrICgpIHtcbiAgICB0aGlzLl9vcGVyYXRpb24uc2V0RmlsdGVyKHRoaXMuX2luaXRpYWxGaWx0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tlZCBhIGxpc3QgaXRlbVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uTGlzdEl0ZW1DbGljayAoaXRlbSkge1xuICAgIHRoaXMuX2RlYWN0aXZhdGVBbGxJdGVtcygpO1xuXG4gICAgbGV0IHsgaWRlbnRpZmllciB9ID0gaXRlbS5kYXRhc2V0O1xuICAgIHRoaXMuX29wZXJhdGlvbi5zZXRGaWx0ZXIoaWRlbnRpZmllcik7XG5cbiAgICBpdGVtLmNsYXNzTGlzdC5hZGQoXCJpbWdseWtpdC1jb250cm9scy1pdGVtLWFjdGl2ZVwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlcyBhbGwgbGlzdCBpdGVtc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlYWN0aXZhdGVBbGxJdGVtcyAoKSB7XG4gICAgZm9yIChsZXQgbGlzdEl0ZW0gb2YgdGhpcy5fbGlzdEl0ZW1zKSB7XG4gICAgICBsaXN0SXRlbS5jbGFzc0xpc3QucmVtb3ZlKFwiaW1nbHlraXQtY29udHJvbHMtaXRlbS1hY3RpdmVcIik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkYXRhIHRoYXQgaXMgYXZhaWxhYmxlIHRvIHRoZSB0ZW1wbGF0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldCBjb250ZXh0ICgpIHtcbiAgICBsZXQgY29udGV4dCA9IHN1cGVyLmNvbnRleHQ7XG4gICAgY29udGV4dC5maWx0ZXJzID0gdGhpcy5fb3BlcmF0aW9uLmZpbHRlcnM7XG4gICAgY29udGV4dC5hY3RpdmVGaWx0ZXIgPSB0aGlzLl9vcGVyYXRpb24uZ2V0RmlsdGVyKCk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmlsdGVyc0NvbnRyb2xzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbmltcG9ydCBDb250cm9sIGZyb20gXCIuL2NvbnRyb2xcIjtcbmxldCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcblxuY2xhc3MgUm90YXRpb25Db250cm9scyBleHRlbmRzIENvbnRyb2wge1xuICAvKipcbiAgICogRW50cnkgcG9pbnQgZm9yIHRoaXMgY29udHJvbFxuICAgKi9cbiAgaW5pdCAoKSB7XG4gICAgbGV0IGNvbnRyb2xzVGVtcGxhdGUgPSBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgXCIvLi4vLi4vLi4vdGVtcGxhdGVzL25pZ2h0L29wZXJhdGlvbnMvcm90YXRpb25fY29udHJvbHMuanN0XCIsIFwidXRmLThcIik7XG4gICAgdGhpcy5fY29udHJvbHNUZW1wbGF0ZSA9IGNvbnRyb2xzVGVtcGxhdGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbnRyb2wgaXMgYWN0aXZhdGVkXG4gICAqL1xuICBfb25FbnRlciAoKSB7XG4gICAgdGhpcy5faW5pdGlhbERlZ3JlZXMgPSB0aGlzLl9vcGVyYXRpb24uZ2V0RGVncmVlcygpO1xuXG4gICAgbGV0IGxpc3RJdGVtcyA9IHRoaXMuX2NvbnRyb2xzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaVwiKTtcbiAgICB0aGlzLl9saXN0SXRlbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0SXRlbXMpO1xuXG4gICAgLy8gTGlzdGVuIHRvIGNsaWNrIGV2ZW50c1xuICAgIGZvciAobGV0IGxpc3RJdGVtIG9mIHRoaXMuX2xpc3RJdGVtcykge1xuICAgICAgbGlzdEl0ZW0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5fb25MaXN0SXRlbUNsaWNrKGxpc3RJdGVtKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkxpc3RJdGVtQ2xpY2sgKGl0ZW0pIHtcbiAgICBsZXQgeyBkZWdyZWVzIH0gPSBpdGVtLmRhdGFzZXQ7XG4gICAgZGVncmVlcyA9IHBhcnNlSW50KGRlZ3JlZXMpO1xuXG4gICAgbGV0IGN1cnJlbnREZWdyZWVzID0gdGhpcy5fb3BlcmF0aW9uLmdldERlZ3JlZXMoKTtcbiAgICB0aGlzLl9vcGVyYXRpb24uc2V0RGVncmVlcyhjdXJyZW50RGVncmVlcyArIGRlZ3JlZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGJhY2sgYnV0dG9uIGhhcyBiZWVuIGNsaWNrZWRcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBfb25CYWNrICgpIHtcbiAgICB0aGlzLl9vcGVyYXRpb24uc2V0RGVncmVlcyh0aGlzLl9pbml0aWFsRGVncmVlcyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRhdGEgdGhhdCBpcyBhdmFpbGFibGUgdG8gdGhlIHRlbXBsYXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXQgY29udGV4dCAoKSB7XG4gICAgbGV0IGNvbnRleHQgPSBzdXBlci5jb250ZXh0O1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJvdGF0aW9uQ29udHJvbHM7XG4iLCIvKiBnbG9iYWwgSW1nbHlLaXQgKi9cblwidXNlIHN0cmljdFwiO1xuLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG5sZXQgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5pbXBvcnQgVUkgZnJvbSBcIi4uL2Jhc2UvdWlcIjtcblxuY2xhc3MgTmlnaHRVSSBleHRlbmRzIFVJIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIHRoaXMuX3RlbXBsYXRlID0gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArIFwiLy4uLy4uL3RlbXBsYXRlcy9uaWdodC90ZW1wbGF0ZS5qc3RcIiwgXCJ1dGYtOFwiKTtcbiAgICB0aGlzLl9yZWdpc3RlcmVkQ29udHJvbHMgPSB7fTtcblxuICAgIC8vIFRoZSBgTmlnaHRgIFVJIGhhcyBhIGZpeGVkIG9wZXJhdGlvbiBvcmRlclxuICAgIHRoaXMuX3ByZWZlcnJlZE9wZXJhdGlvbk9yZGVyID0gW1xuICAgICAgLy8gRmlyc3QsIGFsbCBvcGVyYXRpb25zIHRoYXQgYWZmZWN0IHRoZSBpbWFnZSBkaW1lbnNpb25zXG4gICAgICBcImNyb3BcIixcbiAgICAgIFwicm90YXRpb25cIixcbiAgICAgIFwiZmxpcFwiLFxuXG4gICAgICAvLyBUaGVuIGNvbG9yIG9wZXJhdGlvbnMgKGZpcnN0IGZpbHRlcnMsIHRoZW4gZmluZS10dW5pbmcpXG4gICAgICBcImZpbHRlcnNcIixcbiAgICAgIFwiY29udHJhc3RcIixcbiAgICAgIFwiYnJpZ2h0bmVzc1wiLFxuICAgICAgXCJzYXR1cmF0aW9uXCIsXG5cbiAgICAgIC8vIFRoZW4gcG9zdC1wcm9jZXNzaW5nXG4gICAgICBcIm5vaXNlXCIsXG5cbiAgICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBvbiB0b3BcbiAgICAgIFwidGV4dFwiLFxuICAgICAgXCJzdGlja2Vyc1wiLFxuICAgICAgXCJmcmFtZXNcIlxuICAgIF07XG4gIH1cblxuICBydW4gKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBsZXQgeyBjb250YWluZXIgfSA9IHRoaXMuX29wdGlvbnM7XG5cbiAgICB0aGlzLl9jb250cm9sc0NvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLmltZ2x5a2l0LWNvbnRyb2xzXCIpO1xuICAgIHRoaXMuX2NhbnZhc0NvbnRyb2xzQ29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuaW1nbHlraXQtY2FudmFzLWNvbnRyb2xzLWNvbnRhaW5lclwiKTtcbiAgICB0aGlzLl9vdmVydmlld0NvbnRyb2xzQ29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuaW1nbHlraXQtY29udHJvbHMtb3ZlcnZpZXdcIik7XG5cbiAgICB0aGlzLl9vcGVyYXRpb25zTWFwID0ge307XG5cbiAgICB0aGlzLl9pbml0T3BlcmF0aW9ucygpO1xuICAgIHRoaXMuX3JlZ2lzdGVyQ29udHJvbHMoKTtcbiAgICB0aGlzLl9oYW5kbGVPdmVydmlldygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGFsbCBvcGVyYXRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdE9wZXJhdGlvbnMgKCkge1xuICAgIGxldCB7IG9wZXJhdGlvbnNTdGFjaywgcmVnaXN0ZXJlZE9wZXJhdGlvbnMgfSA9IHRoaXMuX2tpdDtcbiAgICBmb3IgKGxldCBvcGVyYXRpb25JZGVudGlmaWVyIG9mIHRoaXMuX3ByZWZlcnJlZE9wZXJhdGlvbk9yZGVyKSB7XG4gICAgICBpZiAodGhpcy5pc09wZXJhdGlvblNlbGVjdGVkKG9wZXJhdGlvbklkZW50aWZpZXIpKSB7XG4gICAgICAgIGxldCBPcGVyYXRpb24gPSByZWdpc3RlcmVkT3BlcmF0aW9uc1tvcGVyYXRpb25JZGVudGlmaWVyXTtcbiAgICAgICAgbGV0IG9wZXJhdGlvbkluc3RhbmNlID0gbmV3IE9wZXJhdGlvbih0aGlzLl9raXQpO1xuICAgICAgICB0aGlzLl9vcGVyYXRpb25zTWFwW29wZXJhdGlvbklkZW50aWZpZXJdID0gb3BlcmF0aW9uSW5zdGFuY2U7XG4gICAgICAgIG9wZXJhdGlvbnNTdGFjay5wdXNoKG9wZXJhdGlvbkluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFsbCBkZWZhdWx0IG9wZXJhdGlvbiBjb250cm9sc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlZ2lzdGVyQ29udHJvbHMgKCkge1xuICAgIHRoaXMucmVnaXN0ZXJDb250cm9sKHRoaXMuX29wZXJhdGlvbnNNYXAuZmlsdGVycywgcmVxdWlyZShcIi4vY29udHJvbHMvZmlsdGVyc1wiKSk7XG4gICAgdGhpcy5yZWdpc3RlckNvbnRyb2wodGhpcy5fb3BlcmF0aW9uc01hcC5yb3RhdGlvbiwgcmVxdWlyZShcIi4vY29udHJvbHMvcm90YXRpb25cIikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIG92ZXJ2aWV3IGJ1dHRvbiBjbGljayBldmVudHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVPdmVydmlldyAoKSB7XG4gICAgbGV0IGxpc3RJdGVtcyA9IHRoaXMuX292ZXJ2aWV3Q29udHJvbHNDb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZSA+IHVsID4gbGlcIik7XG5cbiAgICAvLyBUdXJuIE5vZGVMaXN0IGludG8gYW4gQXJyYXlcbiAgICBsaXN0SXRlbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0SXRlbXMpO1xuXG4gICAgLy8gQWRkIGNsaWNrIGV2ZW50cyB0byBhbGwgaXRlbXNcbiAgICBmb3IgKGxldCBsaXN0SXRlbSBvZiBsaXN0SXRlbXMpIHtcbiAgICAgIGxldCB7IGlkZW50aWZpZXIgfSA9IGxpc3RJdGVtLmRhdGFzZXQ7XG4gICAgICBsaXN0SXRlbS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9vbk92ZXJ2aWV3QnV0dG9uQ2xpY2soaWRlbnRpZmllcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvdmVydmlldyBidXR0b24gaGFzIGJlZW4gY2xpY2tlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3ZlcnZpZXdCdXR0b25DbGljayAoaWRlbnRpZmllcikge1xuICAgIHRoaXMuX292ZXJ2aWV3Q29udHJvbHNDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRDb250cm9sKSB7XG4gICAgICB0aGlzLl9jdXJyZW50Q29udHJvbC5sZWF2ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRDb250cm9sID0gdGhpcy5fcmVnaXN0ZXJlZENvbnRyb2xzW2lkZW50aWZpZXJdO1xuICAgIHRoaXMuX2N1cnJlbnRDb250cm9sLmVudGVyKCk7XG4gICAgdGhpcy5fY3VycmVudENvbnRyb2wub25jZShcImJhY2tcIiwgdGhpcy5fc3dpdGNoVG9PdmVydmlldy5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2l0Y2hlcyBiYWNrIHRvIHRoZSBvdmVydmlldyBjb250cm9sc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N3aXRjaFRvT3ZlcnZpZXcgKCkge1xuICAgIGlmICh0aGlzLl9jdXJyZW50Q29udHJvbCkge1xuICAgICAgdGhpcy5fY3VycmVudENvbnRyb2wubGVhdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50Q29udHJvbCA9IG51bGw7XG4gICAgdGhpcy5fb3ZlcnZpZXdDb250cm9sc0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyB0aGUgY29udHJvbHMgZm9yIGFuIG9wZXJhdGlvblxuICAgKi9cbiAgcmVnaXN0ZXJDb250cm9sIChvcGVyYXRpb24sIENvbnRyb2xzKSB7XG4gICAgbGV0IGluc3RhbmNlID0gbmV3IENvbnRyb2xzKHRoaXMuX2tpdCwgdGhpcywgb3BlcmF0aW9uLCB0aGlzLl9jb250cm9sc0NvbnRhaW5lciwgdGhpcy5fY2FudmFzQ29udHJvbHNDb250YWluZXIpO1xuICAgIHRoaXMuX3JlZ2lzdGVyZWRDb250cm9sc1tvcGVyYXRpb24uaWRlbnRpZmllcl0gPSBpbnN0YW5jZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOaWdodFVJO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuXG5TdGFja0JsdXIgLSBhIGZhc3QgYWxtb3N0IEdhdXNzaWFuIEJsdXIgRm9yIENhbnZhc1xuXG5WZXJzaW9uOiAgMC41XG5BdXRob3I6ICAgTWFyaW8gS2xpbmdlbWFublxuQ29udGFjdDogIG1hcmlvQHF1YXNpbW9uZG8uY29tXG5XZWJzaXRlOiAgaHR0cDovL3d3dy5xdWFzaW1vbmRvLmNvbS9TdGFja0JsdXJGb3JDYW52YXNcblR3aXR0ZXI6ICBAcXVhc2ltb25kb1xuXG5JbiBjYXNlIHlvdSBmaW5kIHRoaXMgY2xhc3MgdXNlZnVsIC0gZXNwZWNpYWxseSBpbiBjb21tZXJjaWFsIHByb2plY3RzIC1cbkkgYW0gbm90IHRvdGFsbHkgdW5oYXBweSBmb3IgYSBzbWFsbCBkb25hdGlvbiB0byBteSBQYXlQYWwgYWNjb3VudFxubWFyaW9AcXVhc2ltb25kby5kZVxuXG5PciBzdXBwb3J0IG1lIG9uIGZsYXR0cjpcbmh0dHBzOi8vZmxhdHRyLmNvbS90aGluZy83Mjc5MS9TdGFja0JsdXItYS1mYXN0LWFsbW9zdC1HYXVzc2lhbi1CbHVyLUVmZmVjdC1mb3ItQ2FudmFzSmF2YXNjcmlwdFxuXG5Db3B5cmlnaHQgKGMpIDIwMTAgTWFyaW8gS2xpbmdlbWFublxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxub2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbmZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxucmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG5jb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG5Tb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG5PRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbkhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG5GUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG5PVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG52YXIgbXVsX3RhYmxlID0gW1xuICAgICAgICA1MTIsNTEyLDQ1Niw1MTIsMzI4LDQ1NiwzMzUsNTEyLDQwNSwzMjgsMjcxLDQ1NiwzODgsMzM1LDI5Miw1MTIsXG4gICAgICAgIDQ1NCw0MDUsMzY0LDMyOCwyOTgsMjcxLDQ5Niw0NTYsNDIwLDM4OCwzNjAsMzM1LDMxMiwyOTIsMjczLDUxMixcbiAgICAgICAgNDgyLDQ1NCw0MjgsNDA1LDM4MywzNjQsMzQ1LDMyOCwzMTIsMjk4LDI4NCwyNzEsMjU5LDQ5Niw0NzUsNDU2LFxuICAgICAgICA0MzcsNDIwLDQwNCwzODgsMzc0LDM2MCwzNDcsMzM1LDMyMywzMTIsMzAyLDI5MiwyODIsMjczLDI2NSw1MTIsXG4gICAgICAgIDQ5Nyw0ODIsNDY4LDQ1NCw0NDEsNDI4LDQxNyw0MDUsMzk0LDM4MywzNzMsMzY0LDM1NCwzNDUsMzM3LDMyOCxcbiAgICAgICAgMzIwLDMxMiwzMDUsMjk4LDI5MSwyODQsMjc4LDI3MSwyNjUsMjU5LDUwNyw0OTYsNDg1LDQ3NSw0NjUsNDU2LFxuICAgICAgICA0NDYsNDM3LDQyOCw0MjAsNDEyLDQwNCwzOTYsMzg4LDM4MSwzNzQsMzY3LDM2MCwzNTQsMzQ3LDM0MSwzMzUsXG4gICAgICAgIDMyOSwzMjMsMzE4LDMxMiwzMDcsMzAyLDI5NywyOTIsMjg3LDI4MiwyNzgsMjczLDI2OSwyNjUsMjYxLDUxMixcbiAgICAgICAgNTA1LDQ5Nyw0ODksNDgyLDQ3NSw0NjgsNDYxLDQ1NCw0NDcsNDQxLDQzNSw0MjgsNDIyLDQxNyw0MTEsNDA1LFxuICAgICAgICAzOTksMzk0LDM4OSwzODMsMzc4LDM3MywzNjgsMzY0LDM1OSwzNTQsMzUwLDM0NSwzNDEsMzM3LDMzMiwzMjgsXG4gICAgICAgIDMyNCwzMjAsMzE2LDMxMiwzMDksMzA1LDMwMSwyOTgsMjk0LDI5MSwyODcsMjg0LDI4MSwyNzgsMjc0LDI3MSxcbiAgICAgICAgMjY4LDI2NSwyNjIsMjU5LDI1Nyw1MDcsNTAxLDQ5Niw0OTEsNDg1LDQ4MCw0NzUsNDcwLDQ2NSw0NjAsNDU2LFxuICAgICAgICA0NTEsNDQ2LDQ0Miw0MzcsNDMzLDQyOCw0MjQsNDIwLDQxNiw0MTIsNDA4LDQwNCw0MDAsMzk2LDM5MiwzODgsXG4gICAgICAgIDM4NSwzODEsMzc3LDM3NCwzNzAsMzY3LDM2MywzNjAsMzU3LDM1NCwzNTAsMzQ3LDM0NCwzNDEsMzM4LDMzNSxcbiAgICAgICAgMzMyLDMyOSwzMjYsMzIzLDMyMCwzMTgsMzE1LDMxMiwzMTAsMzA3LDMwNCwzMDIsMjk5LDI5NywyOTQsMjkyLFxuICAgICAgICAyODksMjg3LDI4NSwyODIsMjgwLDI3OCwyNzUsMjczLDI3MSwyNjksMjY3LDI2NSwyNjMsMjYxLDI1OV07XG5cblxudmFyIHNoZ190YWJsZSA9IFtcbiAgICAgICA5LCAxMSwgMTIsIDEzLCAxMywgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTYsIDE2LCAxNiwgMTYsIDE3LFxuICAgIDE3LCAxNywgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE5LFxuICAgIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLFxuICAgIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIxLFxuICAgIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLFxuICAgIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLFxuICAgIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLFxuICAgIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIzLFxuICAgIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLFxuICAgIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLFxuICAgIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLFxuICAgIDIzLCAyMywgMjMsIDIzLCAyMywgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxuICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxuICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxuICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxuICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQgXTtcblxuZnVuY3Rpb24gc3RhY2tCbHVyQ2FudmFzUkdCQSggaW1hZ2VEYXRhLCB0b3BfeCwgdG9wX3ksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyApXG57XG4gIGlmICggaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPCAxICkgcmV0dXJuO1xuICByYWRpdXMgfD0gMDtcblxuICB2YXIgcGl4ZWxzID0gaW1hZ2VEYXRhLmRhdGE7XG5cbiAgdmFyIHgsIHksIGksIHAsIHlwLCB5aSwgeXcsIHJfc3VtLCBnX3N1bSwgYl9zdW0sIGFfc3VtLFxuICByX291dF9zdW0sIGdfb3V0X3N1bSwgYl9vdXRfc3VtLCBhX291dF9zdW0sXG4gIHJfaW5fc3VtLCBnX2luX3N1bSwgYl9pbl9zdW0sIGFfaW5fc3VtLFxuICBwciwgcGcsIHBiLCBwYSwgcmJzO1xuXG4gIHZhciBkaXYgPSByYWRpdXMgKyByYWRpdXMgKyAxO1xuICB2YXIgd2lkdGhNaW51czEgID0gd2lkdGggLSAxO1xuICB2YXIgaGVpZ2h0TWludXMxID0gaGVpZ2h0IC0gMTtcbiAgdmFyIHJhZGl1c1BsdXMxICA9IHJhZGl1cyArIDE7XG4gIHZhciBzdW1GYWN0b3IgPSByYWRpdXNQbHVzMSAqICggcmFkaXVzUGx1czEgKyAxICkgLyAyO1xuXG4gIHZhciBzdGFja1N0YXJ0ID0gbmV3IEJsdXJTdGFjaygpO1xuICB2YXIgc3RhY2tFbmQ7XG4gIHZhciBzdGFjayA9IHN0YWNrU3RhcnQ7XG4gIGZvciAoIGkgPSAxOyBpIDwgZGl2OyBpKysgKVxuICB7XG4gICAgc3RhY2sgPSBzdGFjay5uZXh0ID0gbmV3IEJsdXJTdGFjaygpO1xuICAgIGlmICggaSA9PSByYWRpdXNQbHVzMSApIHN0YWNrRW5kID0gc3RhY2s7XG4gIH1cbiAgc3RhY2submV4dCA9IHN0YWNrU3RhcnQ7XG4gIHZhciBzdGFja0luID0gbnVsbDtcbiAgdmFyIHN0YWNrT3V0ID0gbnVsbDtcblxuICB5dyA9IHlpID0gMDtcblxuICB2YXIgbXVsX3N1bSA9IG11bF90YWJsZVtyYWRpdXNdO1xuICB2YXIgc2hnX3N1bSA9IHNoZ190YWJsZVtyYWRpdXNdO1xuXG4gIGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KysgKVxuICB7XG4gICAgcl9pbl9zdW0gPSBnX2luX3N1bSA9IGJfaW5fc3VtID0gYV9pbl9zdW0gPSByX3N1bSA9IGdfc3VtID0gYl9zdW0gPSBhX3N1bSA9IDA7XG5cbiAgICByX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcHIgPSBwaXhlbHNbeWldICk7XG4gICAgZ19vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBnID0gcGl4ZWxzW3lpKzFdICk7XG4gICAgYl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBiID0gcGl4ZWxzW3lpKzJdICk7XG4gICAgYV9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBhID0gcGl4ZWxzW3lpKzNdICk7XG5cbiAgICByX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcbiAgICBnX3N1bSArPSBzdW1GYWN0b3IgKiBwZztcbiAgICBiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcbiAgICBhX3N1bSArPSBzdW1GYWN0b3IgKiBwYTtcblxuICAgIHN0YWNrID0gc3RhY2tTdGFydDtcblxuICAgIGZvciggaSA9IDA7IGkgPCByYWRpdXNQbHVzMTsgaSsrIClcbiAgICB7XG4gICAgICBzdGFjay5yID0gcHI7XG4gICAgICBzdGFjay5nID0gcGc7XG4gICAgICBzdGFjay5iID0gcGI7XG4gICAgICBzdGFjay5hID0gcGE7XG4gICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgfVxuXG4gICAgZm9yKCBpID0gMTsgaSA8IHJhZGl1c1BsdXMxOyBpKysgKVxuICAgIHtcbiAgICAgIHAgPSB5aSArICgoIHdpZHRoTWludXMxIDwgaSA/IHdpZHRoTWludXMxIDogaSApIDw8IDIgKTtcbiAgICAgIHJfc3VtICs9ICggc3RhY2suciA9ICggcHIgPSBwaXhlbHNbcF0pKSAqICggcmJzID0gcmFkaXVzUGx1czEgLSBpICk7XG4gICAgICBnX3N1bSArPSAoIHN0YWNrLmcgPSAoIHBnID0gcGl4ZWxzW3ArMV0pKSAqIHJicztcbiAgICAgIGJfc3VtICs9ICggc3RhY2suYiA9ICggcGIgPSBwaXhlbHNbcCsyXSkpICogcmJzO1xuICAgICAgYV9zdW0gKz0gKCBzdGFjay5hID0gKCBwYSA9IHBpeGVsc1twKzNdKSkgKiByYnM7XG5cbiAgICAgIHJfaW5fc3VtICs9IHByO1xuICAgICAgZ19pbl9zdW0gKz0gcGc7XG4gICAgICBiX2luX3N1bSArPSBwYjtcbiAgICAgIGFfaW5fc3VtICs9IHBhO1xuXG4gICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgfVxuXG5cbiAgICBzdGFja0luID0gc3RhY2tTdGFydDtcbiAgICBzdGFja091dCA9IHN0YWNrRW5kO1xuICAgIGZvciAoIHggPSAwOyB4IDwgd2lkdGg7IHgrKyApXG4gICAge1xuICAgICAgcGl4ZWxzW3lpKzNdID0gcGEgPSAoYV9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtO1xuICAgICAgaWYgKCBwYSAhPT0gMCApXG4gICAgICB7XG4gICAgICAgIHBhID0gMjU1IC8gcGE7XG4gICAgICAgIHBpeGVsc1t5aV0gICA9ICgocl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuICAgICAgICBwaXhlbHNbeWkrMV0gPSAoKGdfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgcGl4ZWxzW3lpKzJdID0gKChiX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaXhlbHNbeWldID0gcGl4ZWxzW3lpKzFdID0gcGl4ZWxzW3lpKzJdID0gMDtcbiAgICAgIH1cblxuICAgICAgcl9zdW0gLT0gcl9vdXRfc3VtO1xuICAgICAgZ19zdW0gLT0gZ19vdXRfc3VtO1xuICAgICAgYl9zdW0gLT0gYl9vdXRfc3VtO1xuICAgICAgYV9zdW0gLT0gYV9vdXRfc3VtO1xuXG4gICAgICByX291dF9zdW0gLT0gc3RhY2tJbi5yO1xuICAgICAgZ19vdXRfc3VtIC09IHN0YWNrSW4uZztcbiAgICAgIGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG4gICAgICBhX291dF9zdW0gLT0gc3RhY2tJbi5hO1xuXG4gICAgICBwID0gICggeXcgKyAoICggcCA9IHggKyByYWRpdXMgKyAxICkgPCB3aWR0aE1pbnVzMSA/IHAgOiB3aWR0aE1pbnVzMSApICkgPDwgMjtcblxuICAgICAgcl9pbl9zdW0gKz0gKCBzdGFja0luLnIgPSBwaXhlbHNbcF0pO1xuICAgICAgZ19pbl9zdW0gKz0gKCBzdGFja0luLmcgPSBwaXhlbHNbcCsxXSk7XG4gICAgICBiX2luX3N1bSArPSAoIHN0YWNrSW4uYiA9IHBpeGVsc1twKzJdKTtcbiAgICAgIGFfaW5fc3VtICs9ICggc3RhY2tJbi5hID0gcGl4ZWxzW3ArM10pO1xuXG4gICAgICByX3N1bSArPSByX2luX3N1bTtcbiAgICAgIGdfc3VtICs9IGdfaW5fc3VtO1xuICAgICAgYl9zdW0gKz0gYl9pbl9zdW07XG4gICAgICBhX3N1bSArPSBhX2luX3N1bTtcblxuICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcblxuICAgICAgcl9vdXRfc3VtICs9ICggcHIgPSBzdGFja091dC5yICk7XG4gICAgICBnX291dF9zdW0gKz0gKCBwZyA9IHN0YWNrT3V0LmcgKTtcbiAgICAgIGJfb3V0X3N1bSArPSAoIHBiID0gc3RhY2tPdXQuYiApO1xuICAgICAgYV9vdXRfc3VtICs9ICggcGEgPSBzdGFja091dC5hICk7XG5cbiAgICAgIHJfaW5fc3VtIC09IHByO1xuICAgICAgZ19pbl9zdW0gLT0gcGc7XG4gICAgICBiX2luX3N1bSAtPSBwYjtcbiAgICAgIGFfaW5fc3VtIC09IHBhO1xuXG4gICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG5cbiAgICAgIHlpICs9IDQ7XG4gICAgfVxuICAgIHl3ICs9IHdpZHRoO1xuICB9XG5cblxuICBmb3IgKCB4ID0gMDsgeCA8IHdpZHRoOyB4KysgKVxuICB7XG4gICAgZ19pbl9zdW0gPSBiX2luX3N1bSA9IGFfaW5fc3VtID0gcl9pbl9zdW0gPSBnX3N1bSA9IGJfc3VtID0gYV9zdW0gPSByX3N1bSA9IDA7XG5cbiAgICB5aSA9IHggPDwgMjtcbiAgICByX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcHIgPSBwaXhlbHNbeWldKTtcbiAgICBnX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGcgPSBwaXhlbHNbeWkrMV0pO1xuICAgIGJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwYiA9IHBpeGVsc1t5aSsyXSk7XG4gICAgYV9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBhID0gcGl4ZWxzW3lpKzNdKTtcblxuICAgIHJfc3VtICs9IHN1bUZhY3RvciAqIHByO1xuICAgIGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xuICAgIGJfc3VtICs9IHN1bUZhY3RvciAqIHBiO1xuICAgIGFfc3VtICs9IHN1bUZhY3RvciAqIHBhO1xuXG4gICAgc3RhY2sgPSBzdGFja1N0YXJ0O1xuXG4gICAgZm9yKCBpID0gMDsgaSA8IHJhZGl1c1BsdXMxOyBpKysgKVxuICAgIHtcbiAgICAgIHN0YWNrLnIgPSBwcjtcbiAgICAgIHN0YWNrLmcgPSBwZztcbiAgICAgIHN0YWNrLmIgPSBwYjtcbiAgICAgIHN0YWNrLmEgPSBwYTtcbiAgICAgIHN0YWNrID0gc3RhY2submV4dDtcbiAgICB9XG5cbiAgICB5cCA9IHdpZHRoO1xuXG4gICAgZm9yKCBpID0gMTsgaSA8PSByYWRpdXM7IGkrKyApXG4gICAge1xuICAgICAgeWkgPSAoIHlwICsgeCApIDw8IDI7XG5cbiAgICAgIHJfc3VtICs9ICggc3RhY2suciA9ICggcHIgPSBwaXhlbHNbeWldKSkgKiAoIHJicyA9IHJhZGl1c1BsdXMxIC0gaSApO1xuICAgICAgZ19zdW0gKz0gKCBzdGFjay5nID0gKCBwZyA9IHBpeGVsc1t5aSsxXSkpICogcmJzO1xuICAgICAgYl9zdW0gKz0gKCBzdGFjay5iID0gKCBwYiA9IHBpeGVsc1t5aSsyXSkpICogcmJzO1xuICAgICAgYV9zdW0gKz0gKCBzdGFjay5hID0gKCBwYSA9IHBpeGVsc1t5aSszXSkpICogcmJzO1xuXG4gICAgICByX2luX3N1bSArPSBwcjtcbiAgICAgIGdfaW5fc3VtICs9IHBnO1xuICAgICAgYl9pbl9zdW0gKz0gcGI7XG4gICAgICBhX2luX3N1bSArPSBwYTtcblxuICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuXG4gICAgICBpZiggaSA8IGhlaWdodE1pbnVzMSApXG4gICAgICB7XG4gICAgICAgIHlwICs9IHdpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHlpID0geDtcbiAgICBzdGFja0luID0gc3RhY2tTdGFydDtcbiAgICBzdGFja091dCA9IHN0YWNrRW5kO1xuICAgIGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KysgKVxuICAgIHtcbiAgICAgIHAgPSB5aSA8PCAyO1xuICAgICAgcGl4ZWxzW3ArM10gPSBwYSA9IChhX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW07XG4gICAgICBpZiAoIHBhID4gMCApXG4gICAgICB7XG4gICAgICAgIHBhID0gMjU1IC8gcGE7XG4gICAgICAgIHBpeGVsc1twXSAgID0gKChyX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0gKSAqIHBhO1xuICAgICAgICBwaXhlbHNbcCsxXSA9ICgoZ19zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtICkgKiBwYTtcbiAgICAgICAgcGl4ZWxzW3ArMl0gPSAoKGJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSApICogcGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaXhlbHNbcF0gPSBwaXhlbHNbcCsxXSA9IHBpeGVsc1twKzJdID0gMDtcbiAgICAgIH1cblxuICAgICAgcl9zdW0gLT0gcl9vdXRfc3VtO1xuICAgICAgZ19zdW0gLT0gZ19vdXRfc3VtO1xuICAgICAgYl9zdW0gLT0gYl9vdXRfc3VtO1xuICAgICAgYV9zdW0gLT0gYV9vdXRfc3VtO1xuXG4gICAgICByX291dF9zdW0gLT0gc3RhY2tJbi5yO1xuICAgICAgZ19vdXRfc3VtIC09IHN0YWNrSW4uZztcbiAgICAgIGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG4gICAgICBhX291dF9zdW0gLT0gc3RhY2tJbi5hO1xuXG4gICAgICBwID0gKCB4ICsgKCggKCBwID0geSArIHJhZGl1c1BsdXMxKSA8IGhlaWdodE1pbnVzMSA/IHAgOiBoZWlnaHRNaW51czEgKSAqIHdpZHRoICkpIDw8IDI7XG5cbiAgICAgIHJfc3VtICs9ICggcl9pbl9zdW0gKz0gKCBzdGFja0luLnIgPSBwaXhlbHNbcF0pKTtcbiAgICAgIGdfc3VtICs9ICggZ19pbl9zdW0gKz0gKCBzdGFja0luLmcgPSBwaXhlbHNbcCsxXSkpO1xuICAgICAgYl9zdW0gKz0gKCBiX2luX3N1bSArPSAoIHN0YWNrSW4uYiA9IHBpeGVsc1twKzJdKSk7XG4gICAgICBhX3N1bSArPSAoIGFfaW5fc3VtICs9ICggc3RhY2tJbi5hID0gcGl4ZWxzW3ArM10pKTtcblxuICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcblxuICAgICAgcl9vdXRfc3VtICs9ICggcHIgPSBzdGFja091dC5yICk7XG4gICAgICBnX291dF9zdW0gKz0gKCBwZyA9IHN0YWNrT3V0LmcgKTtcbiAgICAgIGJfb3V0X3N1bSArPSAoIHBiID0gc3RhY2tPdXQuYiApO1xuICAgICAgYV9vdXRfc3VtICs9ICggcGEgPSBzdGFja091dC5hICk7XG5cbiAgICAgIHJfaW5fc3VtIC09IHByO1xuICAgICAgZ19pbl9zdW0gLT0gcGc7XG4gICAgICBiX2luX3N1bSAtPSBwYjtcbiAgICAgIGFfaW5fc3VtIC09IHBhO1xuXG4gICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG5cbiAgICAgIHlpICs9IHdpZHRoO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBCbHVyU3RhY2soKVxue1xuICB0aGlzLnIgPSAwO1xuICB0aGlzLmcgPSAwO1xuICB0aGlzLmIgPSAwO1xuICB0aGlzLmEgPSAwO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RhY2tCbHVyQ2FudmFzUkdCQTogc3RhY2tCbHVyQ2FudmFzUkdCQVxufTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIExvLURhc2ggMi40LjEgKEN1c3RvbSBCdWlsZCkgPGh0dHA6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIGluY2x1ZGU9XCJkZWZhdWx0cyxleHRlbmRcImBcbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuNS4yIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGludGVybmFsbHkgdG8gaW5kaWNhdGUgdmFyaW91cyB0aGluZ3MgKi9cbiAgdmFyIGluZGljYXRvck9iamVjdCA9IHt9O1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdGVkIG5hbWVkIGZ1bmN0aW9ucyAqL1xuICB2YXIgcmVGdW5jTmFtZSA9IC9eXFxzKmZ1bmN0aW9uWyBcXG5cXHJcXHRdK1xcdy87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGZ1bmN0aW9ucyBjb250YWluaW5nIGEgYHRoaXNgIHJlZmVyZW5jZSAqL1xuICB2YXIgcmVUaGlzID0gL1xcYnRoaXNcXGIvO1xuXG4gIC8qKiBVc2VkIHRvIGZpeCB0aGUgSlNjcmlwdCBbW0RvbnRFbnVtXV0gYnVnICovXG4gIHZhciBzaGFkb3dlZFByb3BzID0gW1xuICAgICdjb25zdHJ1Y3RvcicsICdoYXNPd25Qcm9wZXJ0eScsICdpc1Byb3RvdHlwZU9mJywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAndG9Mb2NhbGVTdHJpbmcnLCAndG9TdHJpbmcnLCAndmFsdWVPZidcbiAgXTtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHNob3J0Y3V0cyAqL1xuICB2YXIgYXJnc0NsYXNzID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheUNsYXNzID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGJvb2xDbGFzcyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVDbGFzcyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGVycm9yQ2xhc3MgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY0NsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIG51bWJlckNsYXNzID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBvYmplY3RDbGFzcyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcmVnZXhwQ2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHN0cmluZ0NsYXNzID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIGBfX2JpbmREYXRhX19gICovXG4gIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICdjb25maWd1cmFibGUnOiBmYWxzZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IG51bGwsXG4gICAgJ3dyaXRhYmxlJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCBhcyB0aGUgZGF0YSBvYmplY3QgZm9yIGBpdGVyYXRvclRlbXBsYXRlYCAqL1xuICB2YXIgaXRlcmF0b3JEYXRhID0ge1xuICAgICdhcmdzJzogJycsXG4gICAgJ2FycmF5JzogbnVsbCxcbiAgICAnYm90dG9tJzogJycsXG4gICAgJ2ZpcnN0QXJnJzogJycsXG4gICAgJ2luaXQnOiAnJyxcbiAgICAna2V5cyc6IG51bGwsXG4gICAgJ2xvb3AnOiAnJyxcbiAgICAnc2hhZG93ZWRQcm9wcyc6IG51bGwsXG4gICAgJ3N1cHBvcnQnOiBudWxsLFxuICAgICd0b3AnOiAnJyxcbiAgICAndXNlSGFzJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBPYmplY3QgKi9cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdib29sZWFuJzogZmFsc2UsXG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZSxcbiAgICAnbnVtYmVyJzogZmFsc2UsXG4gICAgJ3N0cmluZyc6IGZhbHNlLFxuICAgICd1bmRlZmluZWQnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0ICovXG4gIHZhciByb290ID0gKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdykgfHwgdGhpcztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgICovXG4gIHZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AgKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMgJiYgZnJlZUV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSBhbmQgdXNlIGl0IGFzIGByb290YCAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IG9iamVjdFR5cGVzW3R5cGVvZiBnbG9iYWxdICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFNsaWNlcyB0aGUgYGNvbGxlY3Rpb25gIGZyb20gdGhlIGBzdGFydGAgaW5kZXggdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLFxuICAgKiB0aGUgYGVuZGAgaW5kZXguXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbnN0ZWFkIG9mIGBBcnJheSNzbGljZWAgdG8gc3VwcG9ydCBub2RlIGxpc3RzXG4gICAqIGluIElFIDwgOSBhbmQgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIGluZGV4LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0IHx8IDAsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVXNlZCBmb3IgYEFycmF5YCBtZXRob2QgcmVmZXJlbmNlcy5cbiAgICpcbiAgICogTm9ybWFsbHkgYEFycmF5LnByb3RvdHlwZWAgd291bGQgc3VmZmljZSwgaG93ZXZlciwgdXNpbmcgYW4gYXJyYXkgbGl0ZXJhbFxuICAgKiBhdm9pZHMgaXNzdWVzIGluIE5hcndoYWwuXG4gICAqL1xuICB2YXIgYXJyYXlSZWYgPSBbXTtcblxuICAvKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzICovXG4gIHZhciBlcnJvclByb3RvID0gRXJyb3IucHJvdG90eXBlLFxuICAgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgc3RyaW5nUHJvdG8gPSBTdHJpbmcucHJvdG90eXBlO1xuXG4gIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGludGVybmFsIFtbQ2xhc3NdXSBvZiB2YWx1ZXMgKi9cbiAgdmFyIHRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZSAqL1xuICB2YXIgcmVOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICBTdHJpbmcodG9TdHJpbmcpXG4gICAgICAucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKVxuICAgICAgLnJlcGxhY2UoL3RvU3RyaW5nfCBmb3IgW15cXF1dKy9nLCAnLio/JykgKyAnJCdcbiAgKTtcblxuICAvKiogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgKi9cbiAgdmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5LFxuICAgICAgcHVzaCA9IGFycmF5UmVmLnB1c2gsXG4gICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgdW5zaGlmdCA9IGFycmF5UmVmLnVuc2hpZnQ7XG5cbiAgLyoqIFVzZWQgdG8gc2V0IG1ldGEgZGF0YSBvbiBmdW5jdGlvbnMgKi9cbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICAgIC8vIElFIDggb25seSBhY2NlcHRzIERPTSBlbGVtZW50c1xuICAgIHRyeSB7XG4gICAgICB2YXIgbyA9IHt9LFxuICAgICAgICAgIGZ1bmMgPSBpc05hdGl2ZShmdW5jID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KSAmJiBmdW5jLFxuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMobywgbywgbykgJiYgZnVuYztcbiAgICB9IGNhdGNoKGUpIHsgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0oKSk7XG5cbiAgLyogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgZm9yIG1ldGhvZHMgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMgKi9cbiAgdmFyIG5hdGl2ZUNyZWF0ZSA9IGlzTmF0aXZlKG5hdGl2ZUNyZWF0ZSA9IE9iamVjdC5jcmVhdGUpICYmIG5hdGl2ZUNyZWF0ZSxcbiAgICAgIG5hdGl2ZUlzQXJyYXkgPSBpc05hdGl2ZShuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSkgJiYgbmF0aXZlSXNBcnJheSxcbiAgICAgIG5hdGl2ZUtleXMgPSBpc05hdGl2ZShuYXRpdmVLZXlzID0gT2JqZWN0LmtleXMpICYmIG5hdGl2ZUtleXM7XG5cbiAgLyoqIFVzZWQgdG8gYXZvaWQgaXRlcmF0aW5nIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW4gSUUgPCA5ICovXG4gIHZhciBub25FbnVtUHJvcHMgPSB7fTtcbiAgbm9uRW51bVByb3BzW2FycmF5Q2xhc3NdID0gbm9uRW51bVByb3BzW2RhdGVDbGFzc10gPSBub25FbnVtUHJvcHNbbnVtYmVyQ2xhc3NdID0geyAnY29uc3RydWN0b3InOiB0cnVlLCAndG9Mb2NhbGVTdHJpbmcnOiB0cnVlLCAndG9TdHJpbmcnOiB0cnVlLCAndmFsdWVPZic6IHRydWUgfTtcbiAgbm9uRW51bVByb3BzW2Jvb2xDbGFzc10gPSBub25FbnVtUHJvcHNbc3RyaW5nQ2xhc3NdID0geyAnY29uc3RydWN0b3InOiB0cnVlLCAndG9TdHJpbmcnOiB0cnVlLCAndmFsdWVPZic6IHRydWUgfTtcbiAgbm9uRW51bVByb3BzW2Vycm9yQ2xhc3NdID0gbm9uRW51bVByb3BzW2Z1bmNDbGFzc10gPSBub25FbnVtUHJvcHNbcmVnZXhwQ2xhc3NdID0geyAnY29uc3RydWN0b3InOiB0cnVlLCAndG9TdHJpbmcnOiB0cnVlIH07XG4gIG5vbkVudW1Qcm9wc1tvYmplY3RDbGFzc10gPSB7ICdjb25zdHJ1Y3Rvcic6IHRydWUgfTtcblxuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbmd0aCA9IHNoYWRvd2VkUHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHNoYWRvd2VkUHJvcHNbbGVuZ3RoXTtcbiAgICAgIGZvciAodmFyIGNsYXNzTmFtZSBpbiBub25FbnVtUHJvcHMpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwobm9uRW51bVByb3BzLCBjbGFzc05hbWUpICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG5vbkVudW1Qcm9wc1tjbGFzc05hbWVdLCBrZXkpKSB7XG4gICAgICAgICAgbm9uRW51bVByb3BzW2NsYXNzTmFtZV1ba2V5XSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KCkpO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIHRoZSBnaXZlbiB2YWx1ZSB0byBlbmFibGUgaW50dWl0aXZlXG4gICAqIG1ldGhvZCBjaGFpbmluZy5cbiAgICpcbiAgICogSW4gYWRkaXRpb24gdG8gTG8tRGFzaCBtZXRob2RzLCB3cmFwcGVycyBhbHNvIGhhdmUgdGhlIGZvbGxvd2luZyBgQXJyYXlgIG1ldGhvZHM6XG4gICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGByZXZlcnNlYCwgYHNoaWZ0YCwgYHNsaWNlYCwgYHNvcnRgLCBgc3BsaWNlYCxcbiAgICogYW5kIGB1bnNoaWZ0YFxuICAgKlxuICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgdmFsdWVgIG1ldGhvZCBpc1xuICAgKiBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgKlxuICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICogYGFmdGVyYCwgYGFzc2lnbmAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjaGFpbmAsIGBjb21wYWN0YCxcbiAgICogYGNvbXBvc2VgLCBgY29uY2F0YCwgYGNvdW50QnlgLCBgY3JlYXRlYCwgYGNyZWF0ZUNhbGxiYWNrYCwgYGN1cnJ5YCxcbiAgICogYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmVyYCwgYGRlbGF5YCwgYGRpZmZlcmVuY2VgLCBgZmlsdGVyYCwgYGZsYXR0ZW5gLFxuICAgKiBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLCBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLFxuICAgKiBgZnVuY3Rpb25zYCwgYGdyb3VwQnlgLCBgaW5kZXhCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnZlcnRgLFxuICAgKiBgaW52b2tlYCwgYGtleXNgLCBgbWFwYCwgYG1heGAsIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1pbmAsIGBvYmplY3RgLCBgb21pdGAsXG4gICAqIGBvbmNlYCwgYHBhaXJzYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBpY2tgLCBgcGx1Y2tgLCBgcHVsbGAsIGBwdXNoYCxcbiAgICogYHJhbmdlYCwgYHJlamVjdGAsIGByZW1vdmVgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNodWZmbGVgLCBgc2xpY2VgLCBgc29ydGAsXG4gICAqIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aW1lc2AsIGB0b0FycmF5YCwgYHRyYW5zZm9ybWAsXG4gICAqIGB1bmlvbmAsIGB1bmlxYCwgYHVuc2hpZnRgLCBgdW56aXBgLCBgdmFsdWVzYCwgYHdoZXJlYCwgYHdpdGhvdXRgLCBgd3JhcGAsXG4gICAqIGFuZCBgemlwYFxuICAgKlxuICAgKiBUaGUgbm9uLWNoYWluYWJsZSB3cmFwcGVyIGZ1bmN0aW9ucyBhcmU6XG4gICAqIGBjbG9uZWAsIGBjbG9uZURlZXBgLCBgY29udGFpbnNgLCBgZXNjYXBlYCwgYGV2ZXJ5YCwgYGZpbmRgLCBgZmluZEluZGV4YCxcbiAgICogYGZpbmRLZXlgLCBgZmluZExhc3RgLCBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBoYXNgLCBgaWRlbnRpdHlgLFxuICAgKiBgaW5kZXhPZmAsIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQm9vbGVhbmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCxcbiAgICogYGlzRW1wdHlgLCBgaXNFcXVhbGAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzTmFOYCwgYGlzTnVsbGAsIGBpc051bWJlcmAsXG4gICAqIGBpc09iamVjdGAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGpvaW5gLFxuICAgKiBgbGFzdEluZGV4T2ZgLCBgbWl4aW5gLCBgbm9Db25mbGljdGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsXG4gICAqIGByZWR1Y2VSaWdodGAsIGByZXN1bHRgLCBgc2hpZnRgLCBgc2l6ZWAsIGBzb21lYCwgYHNvcnRlZEluZGV4YCwgYHJ1bkluQ29udGV4dGAsXG4gICAqIGB0ZW1wbGF0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGFuZCBgdmFsdWVgXG4gICAqXG4gICAqIFRoZSB3cmFwcGVyIGZ1bmN0aW9ucyBgZmlyc3RgIGFuZCBgbGFzdGAgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIHdoZW4gYG5gIGlzXG4gICAqIHByb3ZpZGVkLCBvdGhlcndpc2UgdGhleSByZXR1cm4gdW53cmFwcGVkIHZhbHVlcy5cbiAgICpcbiAgICogRXhwbGljaXQgY2hhaW5pbmcgY2FuIGJlIGVuYWJsZWQgYnkgdXNpbmcgdGhlIGBfLmNoYWluYCBtZXRob2QuXG4gICAqXG4gICAqIEBuYW1lIF9cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XG4gICAqXG4gICAqIC8vIHJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlXG4gICAqIHdyYXBwZWQucmVkdWNlKGZ1bmN0aW9uKHN1bSwgbnVtKSB7XG4gICAqICAgcmV0dXJuIHN1bSArIG51bTtcbiAgICogfSk7XG4gICAqIC8vID0+IDZcbiAgICpcbiAgICogLy8gcmV0dXJucyBhIHdyYXBwZWQgdmFsdWVcbiAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChmdW5jdGlvbihudW0pIHtcbiAgICogICByZXR1cm4gbnVtICogbnVtO1xuICAgKiB9KTtcbiAgICpcbiAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gbG9kYXNoKCkge1xuICAgIC8vIG5vIG9wZXJhdGlvbiBwZXJmb3JtZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgdXNlZCB0byBmbGFnIGVudmlyb25tZW50cyBmZWF0dXJlcy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAdHlwZSBPYmplY3RcbiAgICovXG4gIHZhciBzdXBwb3J0ID0gbG9kYXNoLnN1cHBvcnQgPSB7fTtcblxuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0b3IgPSBmdW5jdGlvbigpIHsgdGhpcy54ID0gMTsgfSxcbiAgICAgICAgb2JqZWN0ID0geyAnMCc6IDEsICdsZW5ndGgnOiAxIH0sXG4gICAgICAgIHByb3BzID0gW107XG5cbiAgICBjdG9yLnByb3RvdHlwZSA9IHsgJ3ZhbHVlT2YnOiAxLCAneSc6IDEgfTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmV3IGN0b3IpIHsgcHJvcHMucHVzaChrZXkpOyB9XG4gICAgZm9yIChrZXkgaW4gYXJndW1lbnRzKSB7IH1cblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBhbiBgYXJndW1lbnRzYCBvYmplY3QncyBbW0NsYXNzXV0gaXMgcmVzb2x2YWJsZSAoYWxsIGJ1dCBGaXJlZm94IDwgNCwgSUUgPCA5KS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC5hcmdzQ2xhc3MgPSB0b1N0cmluZy5jYWxsKGFyZ3VtZW50cykgPT0gYXJnc0NsYXNzO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgKGFsbCBidXQgTmFyd2hhbCBhbmQgT3BlcmEgPCAxMC41KS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC5hcmdzT2JqZWN0ID0gYXJndW1lbnRzLmNvbnN0cnVjdG9yID09IE9iamVjdCAmJiAhKGFyZ3VtZW50cyBpbnN0YW5jZW9mIEFycmF5KTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBgbmFtZWAgb3IgYG1lc3NhZ2VgIHByb3BlcnRpZXMgb2YgYEVycm9yLnByb3RvdHlwZWAgYXJlXG4gICAgICogZW51bWVyYWJsZSBieSBkZWZhdWx0LiAoSUUgPCA5LCBTYWZhcmkgPCA1LjEpXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnQuZW51bUVycm9yUHJvcHMgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGVycm9yUHJvdG8sICdtZXNzYWdlJykgfHwgcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlcnJvclByb3RvLCAnbmFtZScpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGBwcm90b3R5cGVgIHByb3BlcnRpZXMgYXJlIGVudW1lcmFibGUgYnkgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIEZpcmVmb3ggPCAzLjYsIE9wZXJhID4gOS41MCAtIE9wZXJhIDwgMTEuNjAsIGFuZCBTYWZhcmkgPCA1LjFcbiAgICAgKiAoaWYgdGhlIHByb3RvdHlwZSBvciBhIHByb3BlcnR5IG9uIHRoZSBwcm90b3R5cGUgaGFzIGJlZW4gc2V0KVxuICAgICAqIGluY29ycmVjdGx5IHNldHMgYSBmdW5jdGlvbidzIGBwcm90b3R5cGVgIHByb3BlcnR5IFtbRW51bWVyYWJsZV1dXG4gICAgICogdmFsdWUgdG8gYHRydWVgLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmVudW1Qcm90b3R5cGVzID0gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChjdG9yLCAncHJvdG90eXBlJyk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgZnVuY3Rpb25zIGNhbiBiZSBkZWNvbXBpbGVkIGJ5IGBGdW5jdGlvbiN0b1N0cmluZ2BcbiAgICAgKiAoYWxsIGJ1dCBQUzMgYW5kIG9sZGVyIE9wZXJhIG1vYmlsZSBicm93c2VycyAmIGF2b2lkZWQgaW4gV2luZG93cyA4IGFwcHMpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNEZWNvbXAgPSAhaXNOYXRpdmUocm9vdC5XaW5SVEVycm9yKSAmJiByZVRoaXMudGVzdChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGBGdW5jdGlvbiNuYW1lYCBpcyBzdXBwb3J0ZWQgKGFsbCBidXQgSUUpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNOYW1lcyA9IHR5cGVvZiBGdW5jdGlvbi5uYW1lID09ICdzdHJpbmcnO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGBhcmd1bWVudHNgIG9iamVjdCBpbmRleGVzIGFyZSBub24tZW51bWVyYWJsZVxuICAgICAqIChGaXJlZm94IDwgNCwgSUUgPCA5LCBQaGFudG9tSlMsIFNhZmFyaSA8IDUuMSkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnQubm9uRW51bUFyZ3MgPSBrZXkgIT0gMDtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBwcm9wZXJ0aWVzIHNoYWRvd2luZyB0aG9zZSBvbiBgT2JqZWN0LnByb3RvdHlwZWAgYXJlIG5vbi1lbnVtZXJhYmxlLlxuICAgICAqXG4gICAgICogSW4gSUUgPCA5IGFuIG9iamVjdHMgb3duIHByb3BlcnRpZXMsIHNoYWRvd2luZyBub24tZW51bWVyYWJsZSBvbmVzLCBhcmVcbiAgICAgKiBtYWRlIG5vbi1lbnVtZXJhYmxlIGFzIHdlbGwgKGEuay5hIHRoZSBKU2NyaXB0IFtbRG9udEVudW1dXSBidWcpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0Lm5vbkVudW1TaGFkb3dzID0gIS92YWx1ZU9mLy50ZXN0KHByb3BzKTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBgQXJyYXkjc2hpZnRgIGFuZCBgQXJyYXkjc3BsaWNlYCBhdWdtZW50IGFycmF5LWxpa2Ugb2JqZWN0cyBjb3JyZWN0bHkuXG4gICAgICpcbiAgICAgKiBGaXJlZm94IDwgMTAsIElFIGNvbXBhdGliaWxpdHkgbW9kZSwgYW5kIElFIDwgOSBoYXZlIGJ1Z2d5IEFycmF5IGBzaGlmdCgpYFxuICAgICAqIGFuZCBgc3BsaWNlKClgIGZ1bmN0aW9ucyB0aGF0IGZhaWwgdG8gcmVtb3ZlIHRoZSBsYXN0IGVsZW1lbnQsIGB2YWx1ZVswXWAsXG4gICAgICogb2YgYXJyYXktbGlrZSBvYmplY3RzIGV2ZW4gdGhvdWdoIHRoZSBgbGVuZ3RoYCBwcm9wZXJ0eSBpcyBzZXQgdG8gYDBgLlxuICAgICAqIFRoZSBgc2hpZnQoKWAgbWV0aG9kIGlzIGJ1Z2d5IGluIElFIDggY29tcGF0aWJpbGl0eSBtb2RlLCB3aGlsZSBgc3BsaWNlKClgXG4gICAgICogaXMgYnVnZ3kgcmVnYXJkbGVzcyBvZiBtb2RlIGluIElFIDwgOSBhbmQgYnVnZ3kgaW4gY29tcGF0aWJpbGl0eSBtb2RlIGluIElFIDkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIHN1cHBvcnQuc3BsaWNlT2JqZWN0cyA9IChhcnJheVJlZi5zcGxpY2UuY2FsbChvYmplY3QsIDAsIDEpLCAhb2JqZWN0WzBdKTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBsYWNrIG9mIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgKlxuICAgICAqIElFIDwgOCBjYW4ndCBhY2Nlc3MgY2hhcmFjdGVycyBieSBpbmRleCBhbmQgSUUgOCBjYW4gb25seSBhY2Nlc3NcbiAgICAgKiBjaGFyYWN0ZXJzIGJ5IGluZGV4IG9uIHN0cmluZyBsaXRlcmFscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC51bmluZGV4ZWRDaGFycyA9ICgneCdbMF0gKyBPYmplY3QoJ3gnKVswXSkgIT0gJ3h4JztcbiAgfSgxKSk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSB0ZW1wbGF0ZSB1c2VkIHRvIGNyZWF0ZSBpdGVyYXRvciBmdW5jdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIG9iamVjdCB1c2VkIHRvIHBvcHVsYXRlIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBpbnRlcnBvbGF0ZWQgdGV4dC5cbiAgICovXG4gIHZhciBpdGVyYXRvclRlbXBsYXRlID0gZnVuY3Rpb24ob2JqKSB7XG5cbiAgICB2YXIgX19wID0gJ3ZhciBpbmRleCwgaXRlcmFibGUgPSAnICtcbiAgICAob2JqLmZpcnN0QXJnKSArXG4gICAgJywgcmVzdWx0ID0gJyArXG4gICAgKG9iai5pbml0KSArXG4gICAgJztcXG5pZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xcbicgK1xuICAgIChvYmoudG9wKSArXG4gICAgJzsnO1xuICAgICBpZiAob2JqLmFycmF5KSB7XG4gICAgX19wICs9ICdcXG52YXIgbGVuZ3RoID0gaXRlcmFibGUubGVuZ3RoOyBpbmRleCA9IC0xO1xcbmlmICgnICtcbiAgICAob2JqLmFycmF5KSArXG4gICAgJykgeyAgJztcbiAgICAgaWYgKHN1cHBvcnQudW5pbmRleGVkQ2hhcnMpIHtcbiAgICBfX3AgKz0gJ1xcbiAgaWYgKGlzU3RyaW5nKGl0ZXJhYmxlKSkge1xcbiAgICBpdGVyYWJsZSA9IGl0ZXJhYmxlLnNwbGl0KFxcJ1xcJylcXG4gIH0gICc7XG4gICAgIH1cbiAgICBfX3AgKz0gJ1xcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgJyArXG4gICAgKG9iai5sb29wKSArXG4gICAgJztcXG4gIH1cXG59XFxuZWxzZSB7ICAnO1xuICAgICB9IGVsc2UgaWYgKHN1cHBvcnQubm9uRW51bUFyZ3MpIHtcbiAgICBfX3AgKz0gJ1xcbiAgdmFyIGxlbmd0aCA9IGl0ZXJhYmxlLmxlbmd0aDsgaW5kZXggPSAtMTtcXG4gIGlmIChsZW5ndGggJiYgaXNBcmd1bWVudHMoaXRlcmFibGUpKSB7XFxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuICAgICAgaW5kZXggKz0gXFwnXFwnO1xcbiAgICAgICcgK1xuICAgIChvYmoubG9vcCkgK1xuICAgICc7XFxuICAgIH1cXG4gIH0gZWxzZSB7ICAnO1xuICAgICB9XG5cbiAgICAgaWYgKHN1cHBvcnQuZW51bVByb3RvdHlwZXMpIHtcbiAgICBfX3AgKz0gJ1xcbiAgdmFyIHNraXBQcm90byA9IHR5cGVvZiBpdGVyYWJsZSA9PSBcXCdmdW5jdGlvblxcJztcXG4gICc7XG4gICAgIH1cblxuICAgICBpZiAoc3VwcG9ydC5lbnVtRXJyb3JQcm9wcykge1xuICAgIF9fcCArPSAnXFxuICB2YXIgc2tpcEVycm9yUHJvcHMgPSBpdGVyYWJsZSA9PT0gZXJyb3JQcm90byB8fCBpdGVyYWJsZSBpbnN0YW5jZW9mIEVycm9yO1xcbiAgJztcbiAgICAgfVxuXG4gICAgICAgIHZhciBjb25kaXRpb25zID0gW107ICAgIGlmIChzdXBwb3J0LmVudW1Qcm90b3R5cGVzKSB7IGNvbmRpdGlvbnMucHVzaCgnIShza2lwUHJvdG8gJiYgaW5kZXggPT0gXCJwcm90b3R5cGVcIiknKTsgfSAgICBpZiAoc3VwcG9ydC5lbnVtRXJyb3JQcm9wcykgIHsgY29uZGl0aW9ucy5wdXNoKCchKHNraXBFcnJvclByb3BzICYmIChpbmRleCA9PSBcIm1lc3NhZ2VcIiB8fCBpbmRleCA9PSBcIm5hbWVcIikpJyk7IH1cblxuICAgICBpZiAob2JqLnVzZUhhcyAmJiBvYmoua2V5cykge1xuICAgIF9fcCArPSAnXFxuICB2YXIgb3duSW5kZXggPSAtMSxcXG4gICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXFxuICAgICAgbGVuZ3RoID0gb3duUHJvcHMgPyBvd25Qcm9wcy5sZW5ndGggOiAwO1xcblxcbiAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcXG4gICAgaW5kZXggPSBvd25Qcm9wc1tvd25JbmRleF07XFxuJztcbiAgICAgICAgaWYgKGNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgX19wICs9ICcgICAgaWYgKCcgK1xuICAgIChjb25kaXRpb25zLmpvaW4oJyAmJiAnKSkgK1xuICAgICcpIHtcXG4gICc7XG4gICAgIH1cbiAgICBfX3AgKz1cbiAgICAob2JqLmxvb3ApICtcbiAgICAnOyAgICAnO1xuICAgICBpZiAoY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICBfX3AgKz0gJ1xcbiAgICB9JztcbiAgICAgfVxuICAgIF9fcCArPSAnXFxuICB9ICAnO1xuICAgICB9IGVsc2Uge1xuICAgIF9fcCArPSAnXFxuICBmb3IgKGluZGV4IGluIGl0ZXJhYmxlKSB7XFxuJztcbiAgICAgICAgaWYgKG9iai51c2VIYXMpIHsgY29uZGl0aW9ucy5wdXNoKFwiaGFzT3duUHJvcGVydHkuY2FsbChpdGVyYWJsZSwgaW5kZXgpXCIpOyB9ICAgIGlmIChjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIF9fcCArPSAnICAgIGlmICgnICtcbiAgICAoY29uZGl0aW9ucy5qb2luKCcgJiYgJykpICtcbiAgICAnKSB7XFxuICAnO1xuICAgICB9XG4gICAgX19wICs9XG4gICAgKG9iai5sb29wKSArXG4gICAgJzsgICAgJztcbiAgICAgaWYgKGNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgX19wICs9ICdcXG4gICAgfSc7XG4gICAgIH1cbiAgICBfX3AgKz0gJ1xcbiAgfSAgICAnO1xuICAgICBpZiAoc3VwcG9ydC5ub25FbnVtU2hhZG93cykge1xuICAgIF9fcCArPSAnXFxuXFxuICBpZiAoaXRlcmFibGUgIT09IG9iamVjdFByb3RvKSB7XFxuICAgIHZhciBjdG9yID0gaXRlcmFibGUuY29uc3RydWN0b3IsXFxuICAgICAgICBpc1Byb3RvID0gaXRlcmFibGUgPT09IChjdG9yICYmIGN0b3IucHJvdG90eXBlKSxcXG4gICAgICAgIGNsYXNzTmFtZSA9IGl0ZXJhYmxlID09PSBzdHJpbmdQcm90byA/IHN0cmluZ0NsYXNzIDogaXRlcmFibGUgPT09IGVycm9yUHJvdG8gPyBlcnJvckNsYXNzIDogdG9TdHJpbmcuY2FsbChpdGVyYWJsZSksXFxuICAgICAgICBub25FbnVtID0gbm9uRW51bVByb3BzW2NsYXNzTmFtZV07XFxuICAgICAgJztcbiAgICAgZm9yIChrID0gMDsgayA8IDc7IGsrKykge1xuICAgIF9fcCArPSAnXFxuICAgIGluZGV4ID0gXFwnJyArXG4gICAgKG9iai5zaGFkb3dlZFByb3BzW2tdKSArXG4gICAgJ1xcJztcXG4gICAgaWYgKCghKGlzUHJvdG8gJiYgbm9uRW51bVtpbmRleF0pICYmIGhhc093blByb3BlcnR5LmNhbGwoaXRlcmFibGUsIGluZGV4KSknO1xuICAgICAgICAgICAgaWYgKCFvYmoudXNlSGFzKSB7XG4gICAgX19wICs9ICcgfHwgKCFub25FbnVtW2luZGV4XSAmJiBpdGVyYWJsZVtpbmRleF0gIT09IG9iamVjdFByb3RvW2luZGV4XSknO1xuICAgICB9XG4gICAgX19wICs9ICcpIHtcXG4gICAgICAnICtcbiAgICAob2JqLmxvb3ApICtcbiAgICAnO1xcbiAgICB9ICAgICAgJztcbiAgICAgfVxuICAgIF9fcCArPSAnXFxuICB9ICAgICc7XG4gICAgIH1cblxuICAgICB9XG5cbiAgICAgaWYgKG9iai5hcnJheSB8fCBzdXBwb3J0Lm5vbkVudW1BcmdzKSB7XG4gICAgX19wICs9ICdcXG59JztcbiAgICAgfVxuICAgIF9fcCArPVxuICAgIChvYmouYm90dG9tKSArXG4gICAgJztcXG5yZXR1cm4gcmVzdWx0JztcblxuICAgIHJldHVybiBfX3BcbiAgfTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYmluZGAgdGhhdCBjcmVhdGVzIHRoZSBib3VuZCBmdW5jdGlvbiBhbmRcbiAgICogc2V0cyBpdHMgbWV0YSBkYXRhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBiaW5kRGF0YSBUaGUgYmluZCBkYXRhIGFycmF5LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VCaW5kKGJpbmREYXRhKSB7XG4gICAgdmFyIGZ1bmMgPSBiaW5kRGF0YVswXSxcbiAgICAgICAgcGFydGlhbEFyZ3MgPSBiaW5kRGF0YVsyXSxcbiAgICAgICAgdGhpc0FyZyA9IGJpbmREYXRhWzRdO1xuXG4gICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAvLyBgRnVuY3Rpb24jYmluZGAgc3BlY1xuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4zLjQuNVxuICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgIC8vIGF2b2lkIGBhcmd1bWVudHNgIG9iamVjdCBkZW9wdGltaXphdGlvbnMgYnkgdXNpbmcgYHNsaWNlYCBpbnN0ZWFkXG4gICAgICAgIC8vIG9mIGBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbGAgYW5kIG5vdCBhc3NpZ25pbmcgYGFyZ3VtZW50c2AgdG8gYVxuICAgICAgICAvLyB2YXJpYWJsZSBhcyBhIHRlcm5hcnkgZXhwcmVzc2lvblxuICAgICAgICB2YXIgYXJncyA9IHNsaWNlKHBhcnRpYWxBcmdzKTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgLy8gbWltaWMgdGhlIGNvbnN0cnVjdG9yJ3MgYHJldHVybmAgYmVoYXZpb3JcbiAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yXG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgIC8vIGVuc3VyZSBgbmV3IGJvdW5kYCBpcyBhbiBpbnN0YW5jZSBvZiBgZnVuY2BcbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShmdW5jLnByb3RvdHlwZSksXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHNldEJpbmREYXRhKGJvdW5kLCBiaW5kRGF0YSk7XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlQ3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgIHJldHVybiBpc09iamVjdChwcm90b3R5cGUpID8gbmF0aXZlQ3JlYXRlKHByb3RvdHlwZSkgOiB7fTtcbiAgfVxuICAvLyBmYWxsYmFjayBmb3IgYnJvd3NlcnMgd2l0aG91dCBgT2JqZWN0LmNyZWF0ZWBcbiAgaWYgKCFuYXRpdmVDcmVhdGUpIHtcbiAgICBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gT2JqZWN0KCkge31cbiAgICAgIHJldHVybiBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSkpIHtcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgT2JqZWN0O1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgcm9vdC5PYmplY3QoKTtcbiAgICAgIH07XG4gICAgfSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVDYWxsYmFja2Agd2l0aG91dCBzdXBwb3J0IGZvciBjcmVhdGluZ1xuICAgKiBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gW2Z1bmM9aWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdGhlIGNhbGxiYWNrIGFjY2VwdHMuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUNyZWF0ZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICB9XG4gICAgLy8gZXhpdCBlYXJseSBmb3Igbm8gYHRoaXNBcmdgIG9yIGFscmVhZHkgYm91bmQgYnkgYEZ1bmN0aW9uI2JpbmRgXG4gICAgaWYgKHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnIHx8ICEoJ3Byb3RvdHlwZScgaW4gZnVuYykpIHtcbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH1cbiAgICB2YXIgYmluZERhdGEgPSBmdW5jLl9fYmluZERhdGFfXztcbiAgICBpZiAodHlwZW9mIGJpbmREYXRhID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoc3VwcG9ydC5mdW5jTmFtZXMpIHtcbiAgICAgICAgYmluZERhdGEgPSAhZnVuYy5uYW1lO1xuICAgICAgfVxuICAgICAgYmluZERhdGEgPSBiaW5kRGF0YSB8fCAhc3VwcG9ydC5mdW5jRGVjb21wO1xuICAgICAgaWYgKCFiaW5kRGF0YSkge1xuICAgICAgICB2YXIgc291cmNlID0gZm5Ub1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgICBpZiAoIXN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICAgICAgYmluZERhdGEgPSAhcmVGdW5jTmFtZS50ZXN0KHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFiaW5kRGF0YSkge1xuICAgICAgICAgIC8vIGNoZWNrcyBpZiBgZnVuY2AgcmVmZXJlbmNlcyB0aGUgYHRoaXNgIGtleXdvcmQgYW5kIHN0b3JlcyB0aGUgcmVzdWx0XG4gICAgICAgICAgYmluZERhdGEgPSByZVRoaXMudGVzdChzb3VyY2UpO1xuICAgICAgICAgIHNldEJpbmREYXRhKGZ1bmMsIGJpbmREYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBleGl0IGVhcmx5IGlmIHRoZXJlIGFyZSBubyBgdGhpc2AgcmVmZXJlbmNlcyBvciBgZnVuY2AgaXMgYm91bmRcbiAgICBpZiAoYmluZERhdGEgPT09IGZhbHNlIHx8IChiaW5kRGF0YSAhPT0gdHJ1ZSAmJiBiaW5kRGF0YVsxXSAmIDEpKSB7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9XG4gICAgc3dpdGNoIChhcmdDb3VudCkge1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGEsIGIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGJpbmQoZnVuYywgdGhpc0FyZyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGNyZWF0ZVdyYXBwZXJgIHRoYXQgY3JlYXRlcyB0aGUgd3JhcHBlciBhbmRcbiAgICogc2V0cyBpdHMgbWV0YSBkYXRhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBiaW5kRGF0YSBUaGUgYmluZCBkYXRhIGFycmF5LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VDcmVhdGVXcmFwcGVyKGJpbmREYXRhKSB7XG4gICAgdmFyIGZ1bmMgPSBiaW5kRGF0YVswXSxcbiAgICAgICAgYml0bWFzayA9IGJpbmREYXRhWzFdLFxuICAgICAgICBwYXJ0aWFsQXJncyA9IGJpbmREYXRhWzJdLFxuICAgICAgICBwYXJ0aWFsUmlnaHRBcmdzID0gYmluZERhdGFbM10sXG4gICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XSxcbiAgICAgICAgYXJpdHkgPSBiaW5kRGF0YVs1XTtcblxuICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgMSxcbiAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIDIsXG4gICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgNCxcbiAgICAgICAgaXNDdXJyeUJvdW5kID0gYml0bWFzayAmIDgsXG4gICAgICAgIGtleSA9IGZ1bmM7XG5cbiAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzO1xuICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgIHZhciBhcmdzID0gc2xpY2UocGFydGlhbEFyZ3MpO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAocGFydGlhbFJpZ2h0QXJncyB8fCBpc0N1cnJ5KSB7XG4gICAgICAgIGFyZ3MgfHwgKGFyZ3MgPSBzbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgaWYgKHBhcnRpYWxSaWdodEFyZ3MpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0N1cnJ5ICYmIGFyZ3MubGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICBiaXRtYXNrIHw9IDE2ICYgfjMyO1xuICAgICAgICAgIHJldHVybiBiYXNlQ3JlYXRlV3JhcHBlcihbZnVuYywgKGlzQ3VycnlCb3VuZCA/IGJpdG1hc2sgOiBiaXRtYXNrICYgfjMpLCBhcmdzLCBudWxsLCB0aGlzQXJnLCBhcml0eV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzIHx8IChhcmdzID0gYXJndW1lbnRzKTtcbiAgICAgIGlmIChpc0JpbmRLZXkpIHtcbiAgICAgICAgZnVuYyA9IHRoaXNCaW5kaW5nW2tleV07XG4gICAgICB9XG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShmdW5jLnByb3RvdHlwZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICB9XG4gICAgc2V0QmluZERhdGEoYm91bmQsIGJpbmREYXRhKTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYFxuICAgKiB3aXRoIGFuIG9wdGlvbmFsIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byByZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIG1ldGhvZCBmbGFncyB0byBjb21wb3NlLlxuICAgKiAgVGhlIGJpdG1hc2sgbWF5IGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZmxhZ3M6XG4gICAqICAxIC0gYF8uYmluZGBcbiAgICogIDIgLSBgXy5iaW5kS2V5YFxuICAgKiAgNCAtIGBfLmN1cnJ5YFxuICAgKiAgOCAtIGBfLmN1cnJ5YCAoYm91bmQpXG4gICAqICAxNiAtIGBfLnBhcnRpYWxgXG4gICAqICAzMiAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxBcmdzXSBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZVxuICAgKiAgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxSaWdodEFyZ3NdIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2VcbiAgICogIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlV3JhcHBlcihmdW5jLCBiaXRtYXNrLCBwYXJ0aWFsQXJncywgcGFydGlhbFJpZ2h0QXJncywgdGhpc0FyZywgYXJpdHkpIHtcbiAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIDEsXG4gICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiAyLFxuICAgICAgICBpc0N1cnJ5ID0gYml0bWFzayAmIDQsXG4gICAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiA4LFxuICAgICAgICBpc1BhcnRpYWwgPSBiaXRtYXNrICYgMTYsXG4gICAgICAgIGlzUGFydGlhbFJpZ2h0ID0gYml0bWFzayAmIDMyO1xuXG4gICAgaWYgKCFpc0JpbmRLZXkgJiYgIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgfVxuICAgIGlmIChpc1BhcnRpYWwgJiYgIXBhcnRpYWxBcmdzLmxlbmd0aCkge1xuICAgICAgYml0bWFzayAmPSB+MTY7XG4gICAgICBpc1BhcnRpYWwgPSBwYXJ0aWFsQXJncyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNQYXJ0aWFsUmlnaHQgJiYgIXBhcnRpYWxSaWdodEFyZ3MubGVuZ3RoKSB7XG4gICAgICBiaXRtYXNrICY9IH4zMjtcbiAgICAgIGlzUGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0QXJncyA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgYmluZERhdGEgPSBmdW5jICYmIGZ1bmMuX19iaW5kRGF0YV9fO1xuICAgIGlmIChiaW5kRGF0YSAmJiBiaW5kRGF0YSAhPT0gdHJ1ZSkge1xuICAgICAgLy8gY2xvbmUgYGJpbmREYXRhYFxuICAgICAgYmluZERhdGEgPSBzbGljZShiaW5kRGF0YSk7XG4gICAgICBpZiAoYmluZERhdGFbMl0pIHtcbiAgICAgICAgYmluZERhdGFbMl0gPSBzbGljZShiaW5kRGF0YVsyXSk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZERhdGFbM10pIHtcbiAgICAgICAgYmluZERhdGFbM10gPSBzbGljZShiaW5kRGF0YVszXSk7XG4gICAgICB9XG4gICAgICAvLyBzZXQgYHRoaXNCaW5kaW5nYCBpcyBub3QgcHJldmlvdXNseSBib3VuZFxuICAgICAgaWYgKGlzQmluZCAmJiAhKGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgYmluZERhdGFbNF0gPSB0aGlzQXJnO1xuICAgICAgfVxuICAgICAgLy8gc2V0IGlmIHByZXZpb3VzbHkgYm91bmQgYnV0IG5vdCBjdXJyZW50bHkgKHN1YnNlcXVlbnQgY3VycmllZCBmdW5jdGlvbnMpXG4gICAgICBpZiAoIWlzQmluZCAmJiBiaW5kRGF0YVsxXSAmIDEpIHtcbiAgICAgICAgYml0bWFzayB8PSA4O1xuICAgICAgfVxuICAgICAgLy8gc2V0IGN1cnJpZWQgYXJpdHkgaWYgbm90IHlldCBzZXRcbiAgICAgIGlmIChpc0N1cnJ5ICYmICEoYmluZERhdGFbMV0gJiA0KSkge1xuICAgICAgICBiaW5kRGF0YVs1XSA9IGFyaXR5O1xuICAgICAgfVxuICAgICAgLy8gYXBwZW5kIHBhcnRpYWwgbGVmdCBhcmd1bWVudHNcbiAgICAgIGlmIChpc1BhcnRpYWwpIHtcbiAgICAgICAgcHVzaC5hcHBseShiaW5kRGF0YVsyXSB8fCAoYmluZERhdGFbMl0gPSBbXSksIHBhcnRpYWxBcmdzKTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50c1xuICAgICAgaWYgKGlzUGFydGlhbFJpZ2h0KSB7XG4gICAgICAgIHVuc2hpZnQuYXBwbHkoYmluZERhdGFbM10gfHwgKGJpbmREYXRhWzNdID0gW10pLCBwYXJ0aWFsUmlnaHRBcmdzKTtcbiAgICAgIH1cbiAgICAgIC8vIG1lcmdlIGZsYWdzXG4gICAgICBiaW5kRGF0YVsxXSB8PSBiaXRtYXNrO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIuYXBwbHkobnVsbCwgYmluZERhdGEpO1xuICAgIH1cbiAgICAvLyBmYXN0IHBhdGggZm9yIGBfLmJpbmRgXG4gICAgdmFyIGNyZWF0ZXIgPSAoYml0bWFzayA9PSAxIHx8IGJpdG1hc2sgPT09IDE3KSA/IGJhc2VCaW5kIDogYmFzZUNyZWF0ZVdyYXBwZXI7XG4gICAgcmV0dXJuIGNyZWF0ZXIoW2Z1bmMsIGJpdG1hc2ssIHBhcnRpYWxBcmdzLCBwYXJ0aWFsUmlnaHRBcmdzLCB0aGlzQXJnLCBhcml0eV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgY29tcGlsZWQgaXRlcmF0aW9uIGZ1bmN0aW9ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtvcHRpb25zXSBUaGUgY29tcGlsZSBvcHRpb25zIG9iamVjdChzKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFycmF5XSBDb2RlIHRvIGRldGVybWluZSBpZiB0aGUgaXRlcmFibGUgaXMgYW4gYXJyYXkgb3IgYXJyYXktbGlrZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51c2VIYXNdIFNwZWNpZnkgdXNpbmcgYGhhc093blByb3BlcnR5YCBjaGVja3MgaW4gdGhlIG9iamVjdCBsb29wLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5rZXlzXSBBIHJlZmVyZW5jZSB0byBgXy5rZXlzYCBmb3IgdXNlIGluIG93biBwcm9wZXJ0eSBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hcmdzXSBBIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcgb2YgaXRlcmF0aW9uIGZ1bmN0aW9uIGFyZ3VtZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRvcF0gQ29kZSB0byBleGVjdXRlIGJlZm9yZSB0aGUgaXRlcmF0aW9uIGJyYW5jaGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9vcF0gQ29kZSB0byBleGVjdXRlIGluIHRoZSBvYmplY3QgbG9vcC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJvdHRvbV0gQ29kZSB0byBleGVjdXRlIGFmdGVyIHRoZSBpdGVyYXRpb24gYnJhbmNoZXMuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVJdGVyYXRvcigpIHtcbiAgICAvLyBkYXRhIHByb3BlcnRpZXNcbiAgICBpdGVyYXRvckRhdGEuc2hhZG93ZWRQcm9wcyA9IHNoYWRvd2VkUHJvcHM7XG5cbiAgICAvLyBpdGVyYXRvciBvcHRpb25zXG4gICAgaXRlcmF0b3JEYXRhLmFycmF5ID0gaXRlcmF0b3JEYXRhLmJvdHRvbSA9IGl0ZXJhdG9yRGF0YS5sb29wID0gaXRlcmF0b3JEYXRhLnRvcCA9ICcnO1xuICAgIGl0ZXJhdG9yRGF0YS5pbml0ID0gJ2l0ZXJhYmxlJztcbiAgICBpdGVyYXRvckRhdGEudXNlSGFzID0gdHJ1ZTtcblxuICAgIC8vIG1lcmdlIG9wdGlvbnMgaW50byBhIHRlbXBsYXRlIGRhdGEgb2JqZWN0XG4gICAgZm9yICh2YXIgb2JqZWN0LCBpbmRleCA9IDA7IG9iamVjdCA9IGFyZ3VtZW50c1tpbmRleF07IGluZGV4KyspIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaXRlcmF0b3JEYXRhW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBpdGVyYXRvckRhdGEuYXJncztcbiAgICBpdGVyYXRvckRhdGEuZmlyc3RBcmcgPSAvXlteLF0rLy5leGVjKGFyZ3MpWzBdO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBmdW5jdGlvbiBmYWN0b3J5XG4gICAgdmFyIGZhY3RvcnkgPSBGdW5jdGlvbihcbiAgICAgICAgJ2Jhc2VDcmVhdGVDYWxsYmFjaywgZXJyb3JDbGFzcywgZXJyb3JQcm90bywgaGFzT3duUHJvcGVydHksICcgK1xuICAgICAgICAnaW5kaWNhdG9yT2JqZWN0LCBpc0FyZ3VtZW50cywgaXNBcnJheSwgaXNTdHJpbmcsIGtleXMsIG9iamVjdFByb3RvLCAnICtcbiAgICAgICAgJ29iamVjdFR5cGVzLCBub25FbnVtUHJvcHMsIHN0cmluZ0NsYXNzLCBzdHJpbmdQcm90bywgdG9TdHJpbmcnLFxuICAgICAgJ3JldHVybiBmdW5jdGlvbignICsgYXJncyArICcpIHtcXG4nICsgaXRlcmF0b3JUZW1wbGF0ZShpdGVyYXRvckRhdGEpICsgJ1xcbn0nXG4gICAgKTtcblxuICAgIC8vIHJldHVybiB0aGUgY29tcGlsZWQgZnVuY3Rpb25cbiAgICByZXR1cm4gZmFjdG9yeShcbiAgICAgIGJhc2VDcmVhdGVDYWxsYmFjaywgZXJyb3JDbGFzcywgZXJyb3JQcm90bywgaGFzT3duUHJvcGVydHksXG4gICAgICBpbmRpY2F0b3JPYmplY3QsIGlzQXJndW1lbnRzLCBpc0FycmF5LCBpc1N0cmluZywgaXRlcmF0b3JEYXRhLmtleXMsIG9iamVjdFByb3RvLFxuICAgICAgb2JqZWN0VHlwZXMsIG5vbkVudW1Qcm9wcywgc3RyaW5nQ2xhc3MsIHN0cmluZ1Byb3RvLCB0b1N0cmluZ1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nICYmIHJlTmF0aXZlLnRlc3QodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYHRoaXNgIGJpbmRpbmcgZGF0YSBvbiBhIGdpdmVuIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzZXQgZGF0YSBvbi5cbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWUgVGhlIGRhdGEgYXJyYXkgdG8gc2V0LlxuICAgKi9cbiAgdmFyIHNldEJpbmREYXRhID0gIWRlZmluZVByb3BlcnR5ID8gbm9vcCA6IGZ1bmN0aW9uKGZ1bmMsIHZhbHVlKSB7XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IHZhbHVlO1xuICAgIGRlZmluZVByb3BlcnR5KGZ1bmMsICdfX2JpbmREYXRhX18nLCBkZXNjcmlwdG9yKTtcbiAgfTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8uaXNBcmd1bWVudHMoYXJndW1lbnRzKTsgfSkoMSwgMiwgMyk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICAgIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NDbGFzcyB8fCBmYWxzZTtcbiAgfVxuICAvLyBmYWxsYmFjayBmb3IgYnJvd3NlcnMgdGhhdCBjYW4ndCBkZXRlY3QgYGFyZ3VtZW50c2Agb2JqZWN0cyBieSBbW0NsYXNzXV1cbiAgaWYgKCFzdXBwb3J0LmFyZ3NDbGFzcykge1xuICAgIGlzQXJndW1lbnRzID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiYgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy5pc0FycmF5KGFyZ3VtZW50cyk7IH0pKCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICB2YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICAgIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MgfHwgZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB3aGljaCBwcm9kdWNlcyBhbiBhcnJheSBvZiB0aGVcbiAgICogZ2l2ZW4gb2JqZWN0J3Mgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAqL1xuICB2YXIgc2hpbUtleXMgPSBjcmVhdGVJdGVyYXRvcih7XG4gICAgJ2FyZ3MnOiAnb2JqZWN0JyxcbiAgICAnaW5pdCc6ICdbXScsXG4gICAgJ3RvcCc6ICdpZiAoIShvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0XSkpIHJldHVybiByZXN1bHQnLFxuICAgICdsb29wJzogJ3Jlc3VsdC5wdXNoKGluZGV4KSdcbiAgfSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgY29tcG9zZWQgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmtleXMoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAqIC8vID0+IFsnb25lJywgJ3R3bycsICd0aHJlZSddIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgKi9cbiAgdmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICgoc3VwcG9ydC5lbnVtUHJvdG90eXBlcyAmJiB0eXBlb2Ygb2JqZWN0ID09ICdmdW5jdGlvbicpIHx8XG4gICAgICAgIChzdXBwb3J0Lm5vbkVudW1BcmdzICYmIG9iamVjdC5sZW5ndGggJiYgaXNBcmd1bWVudHMob2JqZWN0KSkpIHtcbiAgICAgIHJldHVybiBzaGltS2V5cyhvYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9O1xuXG4gIC8qKiBSZXVzYWJsZSBpdGVyYXRvciBvcHRpb25zIGZvciBgYXNzaWduYCBhbmQgYGRlZmF1bHRzYCAqL1xuICB2YXIgZGVmYXVsdHNJdGVyYXRvck9wdGlvbnMgPSB7XG4gICAgJ2FyZ3MnOiAnb2JqZWN0LCBzb3VyY2UsIGd1YXJkJyxcbiAgICAndG9wJzpcbiAgICAgICd2YXIgYXJncyA9IGFyZ3VtZW50cyxcXG4nICtcbiAgICAgICcgICAgYXJnc0luZGV4ID0gMCxcXG4nICtcbiAgICAgIFwiICAgIGFyZ3NMZW5ndGggPSB0eXBlb2YgZ3VhcmQgPT0gJ251bWJlcicgPyAyIDogYXJncy5sZW5ndGg7XFxuXCIgK1xuICAgICAgJ3doaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcXG4nICtcbiAgICAgICcgIGl0ZXJhYmxlID0gYXJnc1thcmdzSW5kZXhdO1xcbicgK1xuICAgICAgJyAgaWYgKGl0ZXJhYmxlICYmIG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHsnLFxuICAgICdrZXlzJzoga2V5cyxcbiAgICAnbG9vcCc6IFwiaWYgKHR5cGVvZiByZXN1bHRbaW5kZXhdID09ICd1bmRlZmluZWQnKSByZXN1bHRbaW5kZXhdID0gaXRlcmFibGVbaW5kZXhdXCIsXG4gICAgJ2JvdHRvbSc6ICcgIH1cXG59J1xuICB9O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICogb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXMgd2lsbCBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXNcbiAgICogc291cmNlcy4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlXG4gICAqIGFzc2lnbmVkIHZhbHVlcy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHR3b1xuICAgKiBhcmd1bWVudHM7IChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAqIEBhbGlhcyBleHRlbmRcbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduaW5nIHZhbHVlcy5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5hc3NpZ24oeyAnbmFtZSc6ICdmcmVkJyB9LCB7ICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgKlxuICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbiwgZnVuY3Rpb24oYSwgYikge1xuICAgKiAgIHJldHVybiB0eXBlb2YgYSA9PSAndW5kZWZpbmVkJyA/IGIgOiBhO1xuICAgKiB9KTtcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnYmFybmV5JyB9O1xuICAgKiBkZWZhdWx0cyhvYmplY3QsIHsgJ25hbWUnOiAnZnJlZCcsICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XG4gICAqL1xuICB2YXIgYXNzaWduID0gY3JlYXRlSXRlcmF0b3IoZGVmYXVsdHNJdGVyYXRvck9wdGlvbnMsIHtcbiAgICAndG9wJzpcbiAgICAgIGRlZmF1bHRzSXRlcmF0b3JPcHRpb25zLnRvcC5yZXBsYWNlKCc7JyxcbiAgICAgICAgJztcXG4nICtcbiAgICAgICAgXCJpZiAoYXJnc0xlbmd0aCA+IDMgJiYgdHlwZW9mIGFyZ3NbYXJnc0xlbmd0aCAtIDJdID09ICdmdW5jdGlvbicpIHtcXG5cIiArXG4gICAgICAgICcgIHZhciBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhhcmdzWy0tYXJnc0xlbmd0aCAtIDFdLCBhcmdzW2FyZ3NMZW5ndGgtLV0sIDIpO1xcbicgK1xuICAgICAgICBcIn0gZWxzZSBpZiAoYXJnc0xlbmd0aCA+IDIgJiYgdHlwZW9mIGFyZ3NbYXJnc0xlbmd0aCAtIDFdID09ICdmdW5jdGlvbicpIHtcXG5cIiArXG4gICAgICAgICcgIGNhbGxiYWNrID0gYXJnc1stLWFyZ3NMZW5ndGhdO1xcbicgK1xuICAgICAgICAnfSdcbiAgICAgICksXG4gICAgJ2xvb3AnOiAncmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrID8gY2FsbGJhY2socmVzdWx0W2luZGV4XSwgaXRlcmFibGVbaW5kZXhdKSA6IGl0ZXJhYmxlW2luZGV4XSdcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgKiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gT25jZSBhXG4gICAqIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCBkZWZhdWx0cyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHR5cGUgRnVuY3Rpb25cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gQWxsb3dzIHdvcmtpbmcgd2l0aCBgXy5yZWR1Y2VgIHdpdGhvdXQgdXNpbmcgaXRzXG4gICAqICBga2V5YCBhbmQgYG9iamVjdGAgYXJndW1lbnRzIGFzIHNvdXJjZXMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnYmFybmV5JyB9O1xuICAgKiBfLmRlZmF1bHRzKG9iamVjdCwgeyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1cbiAgICovXG4gIHZhciBkZWZhdWx0cyA9IGNyZWF0ZUl0ZXJhdG9yKGRlZmF1bHRzSXRlcmF0b3JPcHRpb25zKTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nO1xuICB9XG4gIC8vIGZhbGxiYWNrIGZvciBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaVxuICBpZiAoaXNGdW5jdGlvbigveC8pKSB7XG4gICAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY0NsYXNzO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0LlxuICAgKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdCgxKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIHZhbHVlIGlzIHRoZSBFQ01BU2NyaXB0IGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3g4XG4gICAgLy8gYW5kIGF2b2lkIGEgVjggYnVnXG4gICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MVxuICAgIHJldHVybiAhISh2YWx1ZSAmJiBvYmplY3RUeXBlc1t0eXBlb2YgdmFsdWVdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNTdHJpbmcoJ2ZyZWQnKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nQ2xhc3MgfHwgZmFsc2U7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2BcbiAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBiaW5kYCBhcmd1bWVudHMgdG8gdGhvc2VcbiAgICogcHJvdmlkZWQgdG8gdGhlIGJvdW5kIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgZnVuYyA9IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy5uYW1lO1xuICAgKiB9O1xuICAgKlxuICAgKiBmdW5jID0gXy5iaW5kKGZ1bmMsIHsgJ25hbWUnOiAnZnJlZCcgfSwgJ2hpJyk7XG4gICAqIGZ1bmMoKTtcbiAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAqL1xuICBmdW5jdGlvbiBiaW5kKGZ1bmMsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDJcbiAgICAgID8gY3JlYXRlV3JhcHBlcihmdW5jLCAxNywgc2xpY2UoYXJndW1lbnRzLCAyKSwgbnVsbCwgdGhpc0FyZylcbiAgICAgIDogY3JlYXRlV3JhcHBlcihmdW5jLCAxLCBudWxsLCBudWxsLCB0aGlzQXJnKTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQSBuby1vcGVyYXRpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgKiBfLm5vb3Aob2JqZWN0KSA9PT0gdW5kZWZpbmVkO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBub29wKCkge1xuICAgIC8vIG5vIG9wZXJhdGlvbiBwZXJmb3JtZWRcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIGxvZGFzaC5rZXlzID0ga2V5cztcblxuICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgbG9kYXNoLm5vb3AgPSBub29wO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHR5cGUgc3RyaW5nXG4gICAqL1xuICBsb2Rhc2guVkVSU0lPTiA9ICcyLjQuMSc7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gc29tZSBBTUQgYnVpbGQgb3B0aW1pemVycyBsaWtlIHIuanMgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBMby1EYXNoIHRvIHRoZSBnbG9iYWwgb2JqZWN0IGV2ZW4gd2hlbiBhbiBBTUQgbG9hZGVyIGlzIHByZXNlbnQgaW5cbiAgICAvLyBjYXNlIExvLURhc2ggaXMgbG9hZGVkIHdpdGggYSBSZXF1aXJlSlMgc2hpbSBjb25maWcuXG4gICAgLy8gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvYXBpLmh0bWwjY29uZmlnLXNoaW1cbiAgICByb290Ll8gPSBsb2Rhc2g7XG5cbiAgICAvLyBkZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZVxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBsb2Rhc2g7XG4gICAgfSk7XG4gIH1cbiAgLy8gY2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgYW4gYGV4cG9ydHNgIG9iamVjdFxuICBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG4gICAgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTXG4gICAgaWYgKG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBsb2Rhc2gpLl8gPSBsb2Rhc2g7XG4gICAgfVxuICAgIC8vIGluIE5hcndoYWwgb3IgUmhpbm8gLXJlcXVpcmVcbiAgICBlbHNlIHtcbiAgICAgIGZyZWVFeHBvcnRzLl8gPSBsb2Rhc2g7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGluIGEgYnJvd3NlciBvciBSaGlub1xuICAgIHJvb3QuXyA9IGxvZGFzaDtcbiAgfVxufS5jYWxsKHRoaXMpKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIl19
